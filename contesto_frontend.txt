CONTESTO REACT/VITE (kor35-app)


==================================================
FILE: eslint.config.js
==================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


==================================================
FILE: index.html
==================================================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <link rel="icon" type="image/png" href="/Logo Kor-AD.png" /> 
    
    <link rel="manifest" href="/manifest.webmanifest">
    
    <title>KOR-35 Gestione personaggi</title>
</head>
<body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
</body>
</html>

==================================================
FILE: package.json
==================================================
{
  "name": "kor35-app",
  "private": true,
  "version": "0.4.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "patch-push": "npm version patch && git push --follow-tags"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.9",
    "@heroicons/react": "^2.2.0",
    "@tailwindcss/postcss": "^4.1.16",
    "@tanstack/react-query": "^5.90.11",
    "decimal.js": "^10.6.0",
    "dompurify": "^3.3.0",
    "html5-qrcode": "^2.3.8",
    "lucide-react": "^0.548.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-quill-new": "^3.7.0",
    "react-router-dom": "^7.12.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/typography": "^0.5.19",
    "@tailwindcss/vite": "^4.1.16",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-basic-ssl": "^2.1.0",
    "@vitejs/plugin-react": "^5.0.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.16",
    "vite": "^7.1.7",
    "vite-plugin-mkcert": "^1.17.9",
    "vite-plugin-pwa": "^1.1.0"
  }
}


==================================================
FILE: postcss.config.js
==================================================
export default {
  plugins: {
    // Aggiornato per usare la sintassi corretta per le nuove versioni
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}



==================================================
FILE: tailwind.config.js
==================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [
    require('@tailwindcss/typography'),
  ],
}

==================================================
FILE: vite.config.js
==================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import basicSsl from '@vitejs/plugin-basic-ssl'
import { VitePWA } from 'vite-plugin-pwa'
import packageJson from './package.json'

export default defineConfig(({ command, mode }) => {
  const plugins = [
    
    react(),
    // Configurazione PWA
    VitePWA({
      // --- MODIFICHE PER WEB PUSH (Livello 2) ---
      strategies: 'injectManifest', // Usa il nostro service worker custom
      srcDir: 'src',                // Cartella dove si trova il file sorgente
      filename: 'sw.js',            // Nome del file sorgente (creato nel passo precedente)
      // ------------------------------------------
      
      registerType: 'autoUpdate', // Aggiorna l'app appena c'è una nuova versione
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'masked-icon.svg'],
      
      // Permette di testare la PWA in modalità dev (npm run dev)
      devOptions: {
        enabled: true,
        type: 'module', // Spesso necessario con injectManifest in dev
      },

      manifest: {
        name: 'KOR-35 Gestione personaggi',
        short_name: 'KOR-35 PG',
        description: 'Web app per il gioco di ruolo dal vivo (LARP) KOR-35 per la gestione dei propri personaggi',
        theme_color: '#ffffff',
        background_color: '#ffffff',
        display: 'standalone',
        orientation: 'portrait',
        scope: '/',
        start_url: '/',
        icons: [
          {
            src: '/pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: '/pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          },
          {
            src: '/pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable'
          }
        ],
        screenshots: [
          {
            src: 'screenshots/desktop-home.png',
            sizes: '1577x998',
            type: 'image/png',
            form_factor: 'wide'
          },
          {
            src: 'screenshots/mobile-home.png',
            sizes: '981x2048',
            type: 'image/png'
          }
        ]
      }
    })
  ];

  // Attiva basicSsl SOLO se stiamo eseguendo il server di sviluppo ('serve')
  if (command === 'serve') {
    plugins.push(basicSsl());
  }

  return {
    plugins: plugins,
    define: {
      '__APP_VERSION__': JSON.stringify(packageJson.version),
    },
    server: {
      host: true,
      https: command === 'serve', 
    }
  };
});

==================================================
FILE: dev-dist\registerSW.js
==================================================
if('serviceWorker' in navigator) navigator.serviceWorker.register('/dev-sw.js?dev-sw', { scope: '/', type: 'module' })

==================================================
FILE: dev-dist\sw.js
==================================================
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// If the loader is already loaded, just stop.
if (!self.define) {
  let registry = {};

  // Used for `eval` and `importScripts` where we can't get script URL by other means.
  // In both cases, it's safe to use a global var because those functions are synchronous.
  let nextDefineUri;

  const singleRequire = (uri, parentUri) => {
    uri = new URL(uri + ".js", parentUri).href;
    return registry[uri] || (
      
        new Promise(resolve => {
          if ("document" in self) {
            const script = document.createElement("script");
            script.src = uri;
            script.onload = resolve;
            document.head.appendChild(script);
          } else {
            nextDefineUri = uri;
            importScripts(uri);
            resolve();
          }
        })
      
      .then(() => {
        let promise = registry[uri];
        if (!promise) {
          throw new Error(`Module ${uri} didn’t register its module`);
        }
        return promise;
      })
    );
  };

  self.define = (depsNames, factory) => {
    const uri = nextDefineUri || ("document" in self ? document.currentScript.src : "") || location.href;
    if (registry[uri]) {
      // Module is already loading or loaded.
      return;
    }
    let exports = {};
    const require = depUri => singleRequire(depUri, uri);
    const specialDeps = {
      module: { uri },
      exports,
      require
    };
    registry[uri] = Promise.all(depsNames.map(
      depName => specialDeps[depName] || require(depName)
    )).then(deps => {
      factory(...deps);
      return exports;
    });
  };
}
define(['./workbox-5a5d9309'], (function (workbox) { 'use strict';

  self.skipWaiting();
  workbox.clientsClaim();

  /**
   * The precacheAndRoute() method efficiently caches and responds to
   * requests for URLs in the manifest.
   * See https://goo.gl/S9QRab
   */
  workbox.precacheAndRoute([{
    "url": "registerSW.js",
    "revision": "3ca0b8505b4bec776b69afdba2768812"
  }, {
    "url": "index.html",
    "revision": "0.uhhokh3mp84"
  }], {});
  workbox.cleanupOutdatedCaches();
  workbox.registerRoute(new workbox.NavigationRoute(workbox.createHandlerBoundToURL("index.html"), {
    allowlist: [/^\/$/]
  }));

}));


==================================================
FILE: dev-dist\workbox-5a5d9309.js
==================================================
define(['exports'], (function (exports) { 'use strict';

    // @ts-ignore
    try {
      self['workbox:core:7.3.0'] && _();
    } catch (e) {}

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Claim any currently available clients once the service worker
     * becomes active. This is normally used in conjunction with `skipWaiting()`.
     *
     * @memberof workbox-core
     */
    function clientsClaim() {
      self.addEventListener('activate', () => self.clients.claim());
    }

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const logger = (() => {
      // Don't overwrite this value if it's already set.
      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
      if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {
        self.__WB_DISABLE_DEV_LOGS = false;
      }
      let inGroup = false;
      const methodToColorMap = {
        debug: `#7f8c8d`,
        log: `#2ecc71`,
        warn: `#f39c12`,
        error: `#c0392b`,
        groupCollapsed: `#3498db`,
        groupEnd: null // No colored prefix on groupEnd
      };
      const print = function (method, args) {
        if (self.__WB_DISABLE_DEV_LOGS) {
          return;
        }
        if (method === 'groupCollapsed') {
          // Safari doesn't print all console.groupCollapsed() arguments:
          // https://bugs.webkit.org/show_bug.cgi?id=182754
          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            console[method](...args);
            return;
          }
        }
        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`];
        // When in a group, the workbox prefix is not displayed.
        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
        console[method](...logPrefix, ...args);
        if (method === 'groupCollapsed') {
          inGroup = true;
        }
        if (method === 'groupEnd') {
          inGroup = false;
        }
      };
      // eslint-disable-next-line @typescript-eslint/ban-types
      const api = {};
      const loggerMethods = Object.keys(methodToColorMap);
      for (const key of loggerMethods) {
        const method = key;
        api[method] = (...args) => {
          print(method, args);
        };
      }
      return api;
    })();

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const messages = {
      'invalid-value': ({
        paramName,
        validValueDescription,
        value
      }) => {
        if (!paramName || !validValueDescription) {
          throw new Error(`Unexpected input to 'invalid-value' error.`);
        }
        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;
      },
      'not-an-array': ({
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        if (!moduleName || !className || !funcName || !paramName) {
          throw new Error(`Unexpected input to 'not-an-array' error.`);
        }
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;
      },
      'incorrect-type': ({
        expectedType,
        paramName,
        moduleName,
        className,
        funcName
      }) => {
        if (!expectedType || !paramName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'incorrect-type' error.`);
        }
        const classNameStr = className ? `${className}.` : '';
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;
      },
      'incorrect-class': ({
        expectedClassName,
        paramName,
        moduleName,
        className,
        funcName,
        isReturnValueProblem
      }) => {
        if (!expectedClassName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'incorrect-class' error.`);
        }
        const classNameStr = className ? `${className}.` : '';
        if (isReturnValueProblem) {
          return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
        }
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
      },
      'missing-a-method': ({
        expectedMethod,
        paramName,
        moduleName,
        className,
        funcName
      }) => {
        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {
          throw new Error(`Unexpected input to 'missing-a-method' error.`);
        }
        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
      },
      'add-to-cache-list-unexpected-type': ({
        entry
      }) => {
        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;
      },
      'add-to-cache-list-conflicting-entries': ({
        firstEntry,
        secondEntry
      }) => {
        if (!firstEntry || !secondEntry) {
          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);
        }
        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;
      },
      'plugin-error-request-will-fetch': ({
        thrownErrorMessage
      }) => {
        if (!thrownErrorMessage) {
          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);
        }
        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;
      },
      'invalid-cache-name': ({
        cacheNameId,
        value
      }) => {
        if (!cacheNameId) {
          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
        }
        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;
      },
      'unregister-route-but-not-found-with-method': ({
        method
      }) => {
        if (!method) {
          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);
        }
        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;
      },
      'unregister-route-route-not-registered': () => {
        return `The route you're trying to unregister was not previously ` + `registered.`;
      },
      'queue-replay-failed': ({
        name
      }) => {
        return `Replaying the background sync queue '${name}' failed.`;
      },
      'duplicate-queue-name': ({
        name
      }) => {
        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;
      },
      'expired-test-without-max-age': ({
        methodName,
        paramName
      }) => {
        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;
      },
      'unsupported-route-type': ({
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;
      },
      'not-array-of-class': ({
        value,
        expectedClass,
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;
      },
      'max-entries-or-age-required': ({
        moduleName,
        className,
        funcName
      }) => {
        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;
      },
      'statuses-or-headers-required': ({
        moduleName,
        className,
        funcName
      }) => {
        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;
      },
      'invalid-string': ({
        moduleName,
        funcName,
        paramName
      }) => {
        if (!paramName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'invalid-string' error.`);
        }
        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;
      },
      'channel-name-required': () => {
        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;
      },
      'invalid-responses-are-same-args': () => {
        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;
      },
      'expire-custom-caches-only': () => {
        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;
      },
      'unit-must-be-bytes': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
        }
        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was "${normalizedRangeHeader}"`;
      },
      'single-range-only': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'single-range-only' error.`);
        }
        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `"${normalizedRangeHeader}"`;
      },
      'invalid-range-values': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'invalid-range-values' error.`);
        }
        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `"${normalizedRangeHeader}"`;
      },
      'no-range-header': () => {
        return `No Range header was found in the Request provided.`;
      },
      'range-not-satisfiable': ({
        size,
        start,
        end
      }) => {
        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;
      },
      'attempt-to-cache-non-get-request': ({
        url,
        method
      }) => {
        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;
      },
      'cache-put-with-no-response': ({
        url
      }) => {
        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;
      },
      'no-response': ({
        url,
        error
      }) => {
        let message = `The strategy could not generate a response for '${url}'.`;
        if (error) {
          message += ` The underlying error is ${error}.`;
        }
        return message;
      },
      'bad-precaching-response': ({
        url,
        status
      }) => {
        return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);
      },
      'non-precached-url': ({
        url
      }) => {
        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;
      },
      'add-to-cache-list-conflicting-integrities': ({
        url
      }) => {
        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;
      },
      'missing-precache-entry': ({
        cacheName,
        url
      }) => {
        return `Unable to find a precached response in ${cacheName} for ${url}.`;
      },
      'cross-origin-copy-response': ({
        origin
      }) => {
        return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;
      },
      'opaque-streams-source': ({
        type
      }) => {
        const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;
        if (type === 'opaqueredirect') {
          return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;
        }
        return `${message} Please ensure your sources are CORS-enabled.`;
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const generatorFunction = (code, details = {}) => {
      const message = messages[code];
      if (!message) {
        throw new Error(`Unable to find message for code '${code}'.`);
      }
      return message(details);
    };
    const messageGenerator = generatorFunction;

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Workbox errors should be thrown with this class.
     * This allows use to ensure the type easily in tests,
     * helps developers identify errors from workbox
     * easily and allows use to optimise error
     * messages correctly.
     *
     * @private
     */
    class WorkboxError extends Error {
      /**
       *
       * @param {string} errorCode The error code that
       * identifies this particular error.
       * @param {Object=} details Any relevant arguments
       * that will help developers identify issues should
       * be added as a key on the context object.
       */
      constructor(errorCode, details) {
        const message = messageGenerator(errorCode, details);
        super(message);
        this.name = errorCode;
        this.details = details;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /*
     * This method throws if the supplied value is not an array.
     * The destructed values are required to produce a meaningful error for users.
     * The destructed and restructured object is so it's clear what is
     * needed.
     */
    const isArray = (value, details) => {
      if (!Array.isArray(value)) {
        throw new WorkboxError('not-an-array', details);
      }
    };
    const hasMethod = (object, expectedMethod, details) => {
      const type = typeof object[expectedMethod];
      if (type !== 'function') {
        details['expectedMethod'] = expectedMethod;
        throw new WorkboxError('missing-a-method', details);
      }
    };
    const isType = (object, expectedType, details) => {
      if (typeof object !== expectedType) {
        details['expectedType'] = expectedType;
        throw new WorkboxError('incorrect-type', details);
      }
    };
    const isInstance = (object,
    // Need the general type to do the check later.
    // eslint-disable-next-line @typescript-eslint/ban-types
    expectedClass, details) => {
      if (!(object instanceof expectedClass)) {
        details['expectedClassName'] = expectedClass.name;
        throw new WorkboxError('incorrect-class', details);
      }
    };
    const isOneOf = (value, validValues, details) => {
      if (!validValues.includes(value)) {
        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;
        throw new WorkboxError('invalid-value', details);
      }
    };
    const isArrayOfClass = (value,
    // Need general type to do check later.
    expectedClass,
    // eslint-disable-line
    details) => {
      const error = new WorkboxError('not-array-of-class', details);
      if (!Array.isArray(value)) {
        throw error;
      }
      for (const item of value) {
        if (!(item instanceof expectedClass)) {
          throw error;
        }
      }
    };
    const finalAssertExports = {
      hasMethod,
      isArray,
      isInstance,
      isOneOf,
      isType,
      isArrayOfClass
    };

    // @ts-ignore
    try {
      self['workbox:routing:7.3.0'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The default HTTP method, 'GET', used when there's no specific method
     * configured for a route.
     *
     * @type {string}
     *
     * @private
     */
    const defaultMethod = 'GET';
    /**
     * The list of valid HTTP methods associated with requests that could be routed.
     *
     * @type {Array<string>}
     *
     * @private
     */
    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * @param {function()|Object} handler Either a function, or an object with a
     * 'handle' method.
     * @return {Object} An object with a handle method.
     *
     * @private
     */
    const normalizeHandler = handler => {
      if (handler && typeof handler === 'object') {
        {
          finalAssertExports.hasMethod(handler, 'handle', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'handler'
          });
        }
        return handler;
      } else {
        {
          finalAssertExports.isType(handler, 'function', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'handler'
          });
        }
        return {
          handle: handler
        };
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A `Route` consists of a pair of callback functions, "match" and "handler".
     * The "match" callback determine if a route should be used to "handle" a
     * request by returning a non-falsy value if it can. The "handler" callback
     * is called when there is a match and should return a Promise that resolves
     * to a `Response`.
     *
     * @memberof workbox-routing
     */
    class Route {
      /**
       * Constructor for Route class.
       *
       * @param {workbox-routing~matchCallback} match
       * A callback function that determines whether the route matches a given
       * `fetch` event by returning a non-falsy value.
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resolving to a Response.
       * @param {string} [method='GET'] The HTTP method to match the Route
       * against.
       */
      constructor(match, handler, method = defaultMethod) {
        {
          finalAssertExports.isType(match, 'function', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'match'
          });
          if (method) {
            finalAssertExports.isOneOf(method, validMethods, {
              paramName: 'method'
            });
          }
        }
        // These values are referenced directly by Router so cannot be
        // altered by minificaton.
        this.handler = normalizeHandler(handler);
        this.match = match;
        this.method = method;
      }
      /**
       *
       * @param {workbox-routing-handlerCallback} handler A callback
       * function that returns a Promise resolving to a Response
       */
      setCatchHandler(handler) {
        this.catchHandler = normalizeHandler(handler);
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * RegExpRoute makes it easy to create a regular expression based
     * {@link workbox-routing.Route}.
     *
     * For same-origin requests the RegExp only needs to match part of the URL. For
     * requests against third-party servers, you must define a RegExp that matches
     * the start of the URL.
     *
     * @memberof workbox-routing
     * @extends workbox-routing.Route
     */
    class RegExpRoute extends Route {
      /**
       * If the regular expression contains
       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
       * the captured values will be passed to the
       * {@link workbox-routing~handlerCallback} `params`
       * argument.
       *
       * @param {RegExp} regExp The regular expression to match against URLs.
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {string} [method='GET'] The HTTP method to match the Route
       * against.
       */
      constructor(regExp, handler, method) {
        {
          finalAssertExports.isInstance(regExp, RegExp, {
            moduleName: 'workbox-routing',
            className: 'RegExpRoute',
            funcName: 'constructor',
            paramName: 'pattern'
          });
        }
        const match = ({
          url
        }) => {
          const result = regExp.exec(url.href);
          // Return immediately if there's no match.
          if (!result) {
            return;
          }
          // Require that the match start at the first character in the URL string
          // if it's a cross-origin request.
          // See https://github.com/GoogleChrome/workbox/issues/281 for the context
          // behind this behavior.
          if (url.origin !== location.origin && result.index !== 0) {
            {
              logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);
            }
            return;
          }
          // If the route matches, but there aren't any capture groups defined, then
          // this will return [], which is truthy and therefore sufficient to
          // indicate a match.
          // If there are capture groups, then it will return their values.
          return result.slice(1);
        };
        super(match, handler, method);
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const getFriendlyURL = url => {
      const urlObj = new URL(String(url), location.href);
      // See https://github.com/GoogleChrome/workbox/issues/2323
      // We want to include everything, except for the origin if it's same-origin.
      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The Router can be used to process a `FetchEvent` using one or more
     * {@link workbox-routing.Route}, responding with a `Response` if
     * a matching route exists.
     *
     * If no route matches a given a request, the Router will use a "default"
     * handler if one is defined.
     *
     * Should the matching Route throw an error, the Router will use a "catch"
     * handler if one is defined to gracefully deal with issues and respond with a
     * Request.
     *
     * If a request matches multiple routes, the **earliest** registered route will
     * be used to respond to the request.
     *
     * @memberof workbox-routing
     */
    class Router {
      /**
       * Initializes a new Router.
       */
      constructor() {
        this._routes = new Map();
        this._defaultHandlerMap = new Map();
      }
      /**
       * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP
       * method name ('GET', etc.) to an array of all the corresponding `Route`
       * instances that are registered.
       */
      get routes() {
        return this._routes;
      }
      /**
       * Adds a fetch event listener to respond to events when a route matches
       * the event's request.
       */
      addFetchListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('fetch', event => {
          const {
            request
          } = event;
          const responsePromise = this.handleRequest({
            request,
            event
          });
          if (responsePromise) {
            event.respondWith(responsePromise);
          }
        });
      }
      /**
       * Adds a message event listener for URLs to cache from the window.
       * This is useful to cache resources loaded on the page prior to when the
       * service worker started controlling it.
       *
       * The format of the message data sent from the window should be as follows.
       * Where the `urlsToCache` array may consist of URL strings or an array of
       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
       *
       * ```
       * {
       *   type: 'CACHE_URLS',
       *   payload: {
       *     urlsToCache: [
       *       './script1.js',
       *       './script2.js',
       *       ['./script3.js', {mode: 'no-cors'}],
       *     ],
       *   },
       * }
       * ```
       */
      addCacheListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('message', event => {
          // event.data is type 'any'
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (event.data && event.data.type === 'CACHE_URLS') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const {
              payload
            } = event.data;
            {
              logger.debug(`Caching URLs from the window`, payload.urlsToCache);
            }
            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {
              if (typeof entry === 'string') {
                entry = [entry];
              }
              const request = new Request(...entry);
              return this.handleRequest({
                request,
                event
              });
              // TODO(philipwalton): TypeScript errors without this typecast for
              // some reason (probably a bug). The real type here should work but
              // doesn't: `Array<Promise<Response> | undefined>`.
            })); // TypeScript
            event.waitUntil(requestPromises);
            // If a MessageChannel was used, reply to the message on success.
            if (event.ports && event.ports[0]) {
              void requestPromises.then(() => event.ports[0].postMessage(true));
            }
          }
        });
      }
      /**
       * Apply the routing rules to a FetchEvent object to get a Response from an
       * appropriate Route's handler.
       *
       * @param {Object} options
       * @param {Request} options.request The request to handle.
       * @param {ExtendableEvent} options.event The event that triggered the
       *     request.
       * @return {Promise<Response>|undefined} A promise is returned if a
       *     registered route can handle the request. If there is no matching
       *     route and there's no `defaultHandler`, `undefined` is returned.
       */
      handleRequest({
        request,
        event
      }) {
        {
          finalAssertExports.isInstance(request, Request, {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'handleRequest',
            paramName: 'options.request'
          });
        }
        const url = new URL(request.url, location.href);
        if (!url.protocol.startsWith('http')) {
          {
            logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
          }
          return;
        }
        const sameOrigin = url.origin === location.origin;
        const {
          params,
          route
        } = this.findMatchingRoute({
          event,
          request,
          sameOrigin,
          url
        });
        let handler = route && route.handler;
        const debugMessages = [];
        {
          if (handler) {
            debugMessages.push([`Found a route to handle this request:`, route]);
            if (params) {
              debugMessages.push([`Passing the following params to the route's handler:`, params]);
            }
          }
        }
        // If we don't have a handler because there was no matching route, then
        // fall back to defaultHandler if that's defined.
        const method = request.method;
        if (!handler && this._defaultHandlerMap.has(method)) {
          {
            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);
          }
          handler = this._defaultHandlerMap.get(method);
        }
        if (!handler) {
          {
            // No handler so Workbox will do nothing. If logs is set of debug
            // i.e. verbose, we should print out this information.
            logger.debug(`No route found for: ${getFriendlyURL(url)}`);
          }
          return;
        }
        {
          // We have a handler, meaning Workbox is going to handle the route.
          // print the routing details to the console.
          logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
          debugMessages.forEach(msg => {
            if (Array.isArray(msg)) {
              logger.log(...msg);
            } else {
              logger.log(msg);
            }
          });
          logger.groupEnd();
        }
        // Wrap in try and catch in case the handle method throws a synchronous
        // error. It should still callback to the catch handler.
        let responsePromise;
        try {
          responsePromise = handler.handle({
            url,
            request,
            event,
            params
          });
        } catch (err) {
          responsePromise = Promise.reject(err);
        }
        // Get route's catch handler, if it exists
        const catchHandler = route && route.catchHandler;
        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {
          responsePromise = responsePromise.catch(async err => {
            // If there's a route catch handler, process that first
            if (catchHandler) {
              {
                // Still include URL here as it will be async from the console group
                // and may not make sense without the URL
                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);
                logger.error(`Error thrown by:`, route);
                logger.error(err);
                logger.groupEnd();
              }
              try {
                return await catchHandler.handle({
                  url,
                  request,
                  event,
                  params
                });
              } catch (catchErr) {
                if (catchErr instanceof Error) {
                  err = catchErr;
                }
              }
            }
            if (this._catchHandler) {
              {
                // Still include URL here as it will be async from the console group
                // and may not make sense without the URL
                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);
                logger.error(`Error thrown by:`, route);
                logger.error(err);
                logger.groupEnd();
              }
              return this._catchHandler.handle({
                url,
                request,
                event
              });
            }
            throw err;
          });
        }
        return responsePromise;
      }
      /**
       * Checks a request and URL (and optionally an event) against the list of
       * registered routes, and if there's a match, returns the corresponding
       * route along with any params generated by the match.
       *
       * @param {Object} options
       * @param {URL} options.url
       * @param {boolean} options.sameOrigin The result of comparing `url.origin`
       *     against the current origin.
       * @param {Request} options.request The request to match.
       * @param {Event} options.event The corresponding event.
       * @return {Object} An object with `route` and `params` properties.
       *     They are populated if a matching route was found or `undefined`
       *     otherwise.
       */
      findMatchingRoute({
        url,
        sameOrigin,
        request,
        event
      }) {
        const routes = this._routes.get(request.method) || [];
        for (const route of routes) {
          let params;
          // route.match returns type any, not possible to change right now.
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const matchResult = route.match({
            url,
            sameOrigin,
            request,
            event
          });
          if (matchResult) {
            {
              // Warn developers that using an async matchCallback is almost always
              // not the right thing to do.
              if (matchResult instanceof Promise) {
                logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);
              }
            }
            // See https://github.com/GoogleChrome/workbox/issues/2079
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            params = matchResult;
            if (Array.isArray(params) && params.length === 0) {
              // Instead of passing an empty array in as params, use undefined.
              params = undefined;
            } else if (matchResult.constructor === Object &&
            // eslint-disable-line
            Object.keys(matchResult).length === 0) {
              // Instead of passing an empty object in as params, use undefined.
              params = undefined;
            } else if (typeof matchResult === 'boolean') {
              // For the boolean value true (rather than just something truth-y),
              // don't set params.
              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
              params = undefined;
            }
            // Return early if have a match.
            return {
              route,
              params
            };
          }
        }
        // If no match was found above, return and empty object.
        return {};
      }
      /**
       * Define a default `handler` that's called when no routes explicitly
       * match the incoming request.
       *
       * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
       *
       * Without a default handler, unmatched requests will go against the
       * network as if there were no service worker present.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {string} [method='GET'] The HTTP method to associate with this
       * default handler. Each method has its own default.
       */
      setDefaultHandler(handler, method = defaultMethod) {
        this._defaultHandlerMap.set(method, normalizeHandler(handler));
      }
      /**
       * If a Route throws an error while handling a request, this `handler`
       * will be called and given a chance to provide a response.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       */
      setCatchHandler(handler) {
        this._catchHandler = normalizeHandler(handler);
      }
      /**
       * Registers a route with the router.
       *
       * @param {workbox-routing.Route} route The route to register.
       */
      registerRoute(route) {
        {
          finalAssertExports.isType(route, 'object', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.hasMethod(route, 'match', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.isType(route.handler, 'object', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.hasMethod(route.handler, 'handle', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route.handler'
          });
          finalAssertExports.isType(route.method, 'string', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route.method'
          });
        }
        if (!this._routes.has(route.method)) {
          this._routes.set(route.method, []);
        }
        // Give precedence to all of the earlier routes by adding this additional
        // route to the end of the array.
        this._routes.get(route.method).push(route);
      }
      /**
       * Unregisters a route with the router.
       *
       * @param {workbox-routing.Route} route The route to unregister.
       */
      unregisterRoute(route) {
        if (!this._routes.has(route.method)) {
          throw new WorkboxError('unregister-route-but-not-found-with-method', {
            method: route.method
          });
        }
        const routeIndex = this._routes.get(route.method).indexOf(route);
        if (routeIndex > -1) {
          this._routes.get(route.method).splice(routeIndex, 1);
        } else {
          throw new WorkboxError('unregister-route-route-not-registered');
        }
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    let defaultRouter;
    /**
     * Creates a new, singleton Router instance if one does not exist. If one
     * does already exist, that instance is returned.
     *
     * @private
     * @return {Router}
     */
    const getOrCreateDefaultRouter = () => {
      if (!defaultRouter) {
        defaultRouter = new Router();
        // The helpers that use the default Router assume these listeners exist.
        defaultRouter.addFetchListener();
        defaultRouter.addCacheListener();
      }
      return defaultRouter;
    };

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Easily register a RegExp, string, or function with a caching
     * strategy to a singleton Router instance.
     *
     * This method will generate a Route for you if needed and
     * call {@link workbox-routing.Router#registerRoute}.
     *
     * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture
     * If the capture param is a `Route`, all other arguments will be ignored.
     * @param {workbox-routing~handlerCallback} [handler] A callback
     * function that returns a Promise resulting in a Response. This parameter
     * is required if `capture` is not a `Route` object.
     * @param {string} [method='GET'] The HTTP method to match the Route
     * against.
     * @return {workbox-routing.Route} The generated `Route`.
     *
     * @memberof workbox-routing
     */
    function registerRoute(capture, handler, method) {
      let route;
      if (typeof capture === 'string') {
        const captureUrl = new URL(capture, location.href);
        {
          if (!(capture.startsWith('/') || capture.startsWith('http'))) {
            throw new WorkboxError('invalid-string', {
              moduleName: 'workbox-routing',
              funcName: 'registerRoute',
              paramName: 'capture'
            });
          }
          // We want to check if Express-style wildcards are in the pathname only.
          // TODO: Remove this log message in v4.
          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;
          // See https://github.com/pillarjs/path-to-regexp#parameters
          const wildcards = '[*:?+]';
          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {
            logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);
          }
        }
        const matchCallback = ({
          url
        }) => {
          {
            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {
              logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);
            }
          }
          return url.href === captureUrl.href;
        };
        // If `capture` is a string then `handler` and `method` must be present.
        route = new Route(matchCallback, handler, method);
      } else if (capture instanceof RegExp) {
        // If `capture` is a `RegExp` then `handler` and `method` must be present.
        route = new RegExpRoute(capture, handler, method);
      } else if (typeof capture === 'function') {
        // If `capture` is a function then `handler` and `method` must be present.
        route = new Route(capture, handler, method);
      } else if (capture instanceof Route) {
        route = capture;
      } else {
        throw new WorkboxError('unsupported-route-type', {
          moduleName: 'workbox-routing',
          funcName: 'registerRoute',
          paramName: 'capture'
        });
      }
      const defaultRouter = getOrCreateDefaultRouter();
      defaultRouter.registerRoute(route);
      return route;
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const _cacheNameDetails = {
      googleAnalytics: 'googleAnalytics',
      precache: 'precache-v2',
      prefix: 'workbox',
      runtime: 'runtime',
      suffix: typeof registration !== 'undefined' ? registration.scope : ''
    };
    const _createCacheName = cacheName => {
      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');
    };
    const eachCacheNameDetail = fn => {
      for (const key of Object.keys(_cacheNameDetails)) {
        fn(key);
      }
    };
    const cacheNames = {
      updateDetails: details => {
        eachCacheNameDetail(key => {
          if (typeof details[key] === 'string') {
            _cacheNameDetails[key] = details[key];
          }
        });
      },
      getGoogleAnalyticsName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
      },
      getPrecacheName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.precache);
      },
      getPrefix: () => {
        return _cacheNameDetails.prefix;
      },
      getRuntimeName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
      },
      getSuffix: () => {
        return _cacheNameDetails.suffix;
      }
    };

    /*
      Copyright 2020 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A utility method that makes it easier to use `event.waitUntil` with
     * async functions and return the result.
     *
     * @param {ExtendableEvent} event
     * @param {Function} asyncFn
     * @return {Function}
     * @private
     */
    function waitUntil(event, asyncFn) {
      const returnPromise = asyncFn();
      event.waitUntil(returnPromise);
      return returnPromise;
    }

    // @ts-ignore
    try {
      self['workbox:precaching:7.3.0'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    // Name of the search parameter used to store revision info.
    const REVISION_SEARCH_PARAM = '__WB_REVISION__';
    /**
     * Converts a manifest entry into a versioned URL suitable for precaching.
     *
     * @param {Object|string} entry
     * @return {string} A URL with versioning info.
     *
     * @private
     * @memberof workbox-precaching
     */
    function createCacheKey(entry) {
      if (!entry) {
        throw new WorkboxError('add-to-cache-list-unexpected-type', {
          entry
        });
      }
      // If a precache manifest entry is a string, it's assumed to be a versioned
      // URL, like '/app.abcd1234.js'. Return as-is.
      if (typeof entry === 'string') {
        const urlObject = new URL(entry, location.href);
        return {
          cacheKey: urlObject.href,
          url: urlObject.href
        };
      }
      const {
        revision,
        url
      } = entry;
      if (!url) {
        throw new WorkboxError('add-to-cache-list-unexpected-type', {
          entry
        });
      }
      // If there's just a URL and no revision, then it's also assumed to be a
      // versioned URL.
      if (!revision) {
        const urlObject = new URL(url, location.href);
        return {
          cacheKey: urlObject.href,
          url: urlObject.href
        };
      }
      // Otherwise, construct a properly versioned URL using the custom Workbox
      // search parameter along with the revision info.
      const cacheKeyURL = new URL(url, location.href);
      const originalURL = new URL(url, location.href);
      cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
      return {
        cacheKey: cacheKeyURL.href,
        url: originalURL.href
      };
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A plugin, designed to be used with PrecacheController, to determine the
     * of assets that were updated (or not updated) during the install event.
     *
     * @private
     */
    class PrecacheInstallReportPlugin {
      constructor() {
        this.updatedURLs = [];
        this.notUpdatedURLs = [];
        this.handlerWillStart = async ({
          request,
          state
        }) => {
          // TODO: `state` should never be undefined...
          if (state) {
            state.originalRequest = request;
          }
        };
        this.cachedResponseWillBeUsed = async ({
          event,
          state,
          cachedResponse
        }) => {
          if (event.type === 'install') {
            if (state && state.originalRequest && state.originalRequest instanceof Request) {
              // TODO: `state` should never be undefined...
              const url = state.originalRequest.url;
              if (cachedResponse) {
                this.notUpdatedURLs.push(url);
              } else {
                this.updatedURLs.push(url);
              }
            }
          }
          return cachedResponse;
        };
      }
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A plugin, designed to be used with PrecacheController, to translate URLs into
     * the corresponding cache key, based on the current revision info.
     *
     * @private
     */
    class PrecacheCacheKeyPlugin {
      constructor({
        precacheController
      }) {
        this.cacheKeyWillBeUsed = async ({
          request,
          params
        }) => {
          // Params is type any, can't change right now.
          /* eslint-disable */
          const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);
          /* eslint-enable */
          return cacheKey ? new Request(cacheKey, {
            headers: request.headers
          }) : request;
        };
        this._precacheController = precacheController;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * @param {string} groupTitle
     * @param {Array<string>} deletedURLs
     *
     * @private
     */
    const logGroup = (groupTitle, deletedURLs) => {
      logger.groupCollapsed(groupTitle);
      for (const url of deletedURLs) {
        logger.log(url);
      }
      logger.groupEnd();
    };
    /**
     * @param {Array<string>} deletedURLs
     *
     * @private
     * @memberof workbox-precaching
     */
    function printCleanupDetails(deletedURLs) {
      const deletionCount = deletedURLs.length;
      if (deletionCount > 0) {
        logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);
        logGroup('Deleted Cache Requests', deletedURLs);
        logger.groupEnd();
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * @param {string} groupTitle
     * @param {Array<string>} urls
     *
     * @private
     */
    function _nestedGroup(groupTitle, urls) {
      if (urls.length === 0) {
        return;
      }
      logger.groupCollapsed(groupTitle);
      for (const url of urls) {
        logger.log(url);
      }
      logger.groupEnd();
    }
    /**
     * @param {Array<string>} urlsToPrecache
     * @param {Array<string>} urlsAlreadyPrecached
     *
     * @private
     * @memberof workbox-precaching
     */
    function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {
      const precachedCount = urlsToPrecache.length;
      const alreadyPrecachedCount = urlsAlreadyPrecached.length;
      if (precachedCount || alreadyPrecachedCount) {
        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;
        if (alreadyPrecachedCount > 0) {
          message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;
        }
        logger.groupCollapsed(message);
        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);
        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);
        logger.groupEnd();
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    let supportStatus;
    /**
     * A utility function that determines whether the current browser supports
     * constructing a new `Response` from a `response.body` stream.
     *
     * @return {boolean} `true`, if the current browser can successfully
     *     construct a `Response` from a `response.body` stream, `false` otherwise.
     *
     * @private
     */
    function canConstructResponseFromBodyStream() {
      if (supportStatus === undefined) {
        const testResponse = new Response('');
        if ('body' in testResponse) {
          try {
            new Response(testResponse.body);
            supportStatus = true;
          } catch (error) {
            supportStatus = false;
          }
        }
        supportStatus = false;
      }
      return supportStatus;
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Allows developers to copy a response and modify its `headers`, `status`,
     * or `statusText` values (the values settable via a
     * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}
     * object in the constructor).
     * To modify these values, pass a function as the second argument. That
     * function will be invoked with a single object with the response properties
     * `{headers, status, statusText}`. The return value of this function will
     * be used as the `ResponseInit` for the new `Response`. To change the values
     * either modify the passed parameter(s) and return it, or return a totally
     * new object.
     *
     * This method is intentionally limited to same-origin responses, regardless of
     * whether CORS was used or not.
     *
     * @param {Response} response
     * @param {Function} modifier
     * @memberof workbox-core
     */
    async function copyResponse(response, modifier) {
      let origin = null;
      // If response.url isn't set, assume it's cross-origin and keep origin null.
      if (response.url) {
        const responseURL = new URL(response.url);
        origin = responseURL.origin;
      }
      if (origin !== self.location.origin) {
        throw new WorkboxError('cross-origin-copy-response', {
          origin
        });
      }
      const clonedResponse = response.clone();
      // Create a fresh `ResponseInit` object by cloning the headers.
      const responseInit = {
        headers: new Headers(clonedResponse.headers),
        status: clonedResponse.status,
        statusText: clonedResponse.statusText
      };
      // Apply any user modifications.
      const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;
      // Create the new response from the body stream and `ResponseInit`
      // modifications. Note: not all browsers support the Response.body stream,
      // so fall back to reading the entire body into memory as a blob.
      const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();
      return new Response(body, modifiedResponseInit);
    }

    /*
      Copyright 2020 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    function stripParams(fullURL, ignoreParams) {
      const strippedURL = new URL(fullURL);
      for (const param of ignoreParams) {
        strippedURL.searchParams.delete(param);
      }
      return strippedURL.href;
    }
    /**
     * Matches an item in the cache, ignoring specific URL params. This is similar
     * to the `ignoreSearch` option, but it allows you to ignore just specific
     * params (while continuing to match on the others).
     *
     * @private
     * @param {Cache} cache
     * @param {Request} request
     * @param {Object} matchOptions
     * @param {Array<string>} ignoreParams
     * @return {Promise<Response|undefined>}
     */
    async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
      const strippedRequestURL = stripParams(request.url, ignoreParams);
      // If the request doesn't include any ignored params, match as normal.
      if (request.url === strippedRequestURL) {
        return cache.match(request, matchOptions);
      }
      // Otherwise, match by comparing keys
      const keysOptions = Object.assign(Object.assign({}, matchOptions), {
        ignoreSearch: true
      });
      const cacheKeys = await cache.keys(request, keysOptions);
      for (const cacheKey of cacheKeys) {
        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
        if (strippedRequestURL === strippedCacheKeyURL) {
          return cache.match(cacheKey, matchOptions);
        }
      }
      return;
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The Deferred class composes Promises in a way that allows for them to be
     * resolved or rejected from outside the constructor. In most cases promises
     * should be used directly, but Deferreds can be necessary when the logic to
     * resolve a promise must be separate.
     *
     * @private
     */
    class Deferred {
      /**
       * Creates a promise and exposes its resolve and reject functions as methods.
       */
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    // Callbacks to be executed whenever there's a quota error.
    // Can't change Function type right now.
    // eslint-disable-next-line @typescript-eslint/ban-types
    const quotaErrorCallbacks = new Set();

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Runs all of the callback functions, one at a time sequentially, in the order
     * in which they were registered.
     *
     * @memberof workbox-core
     * @private
     */
    async function executeQuotaErrorCallbacks() {
      {
        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);
      }
      for (const callback of quotaErrorCallbacks) {
        await callback();
        {
          logger.log(callback, 'is complete.');
        }
      }
      {
        logger.log('Finished running callbacks.');
      }
    }

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Returns a promise that resolves and the passed number of milliseconds.
     * This utility is an async/await-friendly version of `setTimeout`.
     *
     * @param {number} ms
     * @return {Promise}
     * @private
     */
    function timeout(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // @ts-ignore
    try {
      self['workbox:strategies:7.3.0'] && _();
    } catch (e) {}

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    function toRequest(input) {
      return typeof input === 'string' ? new Request(input) : input;
    }
    /**
     * A class created every time a Strategy instance calls
     * {@link workbox-strategies.Strategy~handle} or
     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and
     * cache actions around plugin callbacks and keeps track of when the strategy
     * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
     *
     * @memberof workbox-strategies
     */
    class StrategyHandler {
      /**
       * Creates a new instance associated with the passed strategy and event
       * that's handling the request.
       *
       * The constructor also initializes the state that will be passed to each of
       * the plugins handling this request.
       *
       * @param {workbox-strategies.Strategy} strategy
       * @param {Object} options
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params] The return value from the
       *     {@link workbox-routing~matchCallback} (if applicable).
       */
      constructor(strategy, options) {
        this._cacheKeys = {};
        /**
         * The request the strategy is performing (passed to the strategy's
         * `handle()` or `handleAll()` method).
         * @name request
         * @instance
         * @type {Request}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * The event associated with this request.
         * @name event
         * @instance
         * @type {ExtendableEvent}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * A `URL` instance of `request.url` (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `url` param will be present if the strategy was invoked
         * from a workbox `Route` object.
         * @name url
         * @instance
         * @type {URL|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * A `param` value (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `param` param will be present if the strategy was invoked
         * from a workbox `Route` object and the
         * {@link workbox-routing~matchCallback} returned
         * a truthy value (it will be that value).
         * @name params
         * @instance
         * @type {*|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */
        {
          finalAssertExports.isInstance(options.event, ExtendableEvent, {
            moduleName: 'workbox-strategies',
            className: 'StrategyHandler',
            funcName: 'constructor',
            paramName: 'options.event'
          });
        }
        Object.assign(this, options);
        this.event = options.event;
        this._strategy = strategy;
        this._handlerDeferred = new Deferred();
        this._extendLifetimePromises = [];
        // Copy the plugins list (since it's mutable on the strategy),
        // so any mutations don't affect this handler instance.
        this._plugins = [...strategy.plugins];
        this._pluginStateMap = new Map();
        for (const plugin of this._plugins) {
          this._pluginStateMap.set(plugin, {});
        }
        this.event.waitUntil(this._handlerDeferred.promise);
      }
      /**
       * Fetches a given request (and invokes any applicable plugin callback
       * methods) using the `fetchOptions` (for non-navigation requests) and
       * `plugins` defined on the `Strategy` object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - `requestWillFetch()`
       * - `fetchDidSucceed()`
       * - `fetchDidFail()`
       *
       * @param {Request|string} input The URL or request to fetch.
       * @return {Promise<Response>}
       */
      async fetch(input) {
        const {
          event
        } = this;
        let request = toRequest(input);
        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {
          const possiblePreloadResponse = await event.preloadResponse;
          if (possiblePreloadResponse) {
            {
              logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);
            }
            return possiblePreloadResponse;
          }
        }
        // If there is a fetchDidFail plugin, we need to save a clone of the
        // original request before it's either modified by a requestWillFetch
        // plugin or before the original request's body is consumed via fetch().
        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;
        try {
          for (const cb of this.iterateCallbacks('requestWillFetch')) {
            request = await cb({
              request: request.clone(),
              event
            });
          }
        } catch (err) {
          if (err instanceof Error) {
            throw new WorkboxError('plugin-error-request-will-fetch', {
              thrownErrorMessage: err.message
            });
          }
        }
        // The request can be altered by plugins with `requestWillFetch` making
        // the original request (most likely from a `fetch` event) different
        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
        const pluginFilteredRequest = request.clone();
        try {
          let fetchResponse;
          // See https://github.com/GoogleChrome/workbox/issues/1796
          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);
          if ("development" !== 'production') {
            logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);
          }
          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
            fetchResponse = await callback({
              event,
              request: pluginFilteredRequest,
              response: fetchResponse
            });
          }
          return fetchResponse;
        } catch (error) {
          {
            logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);
          }
          // `originalRequest` will only exist if a `fetchDidFail` callback
          // is being used (see above).
          if (originalRequest) {
            await this.runCallbacks('fetchDidFail', {
              error: error,
              event,
              originalRequest: originalRequest.clone(),
              request: pluginFilteredRequest.clone()
            });
          }
          throw error;
        }
      }
      /**
       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
       * the response generated by `this.fetch()`.
       *
       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
       * so you do not have to manually call `waitUntil()` on the event.
       *
       * @param {Request|string} input The request or URL to fetch and cache.
       * @return {Promise<Response>}
       */
      async fetchAndCachePut(input) {
        const response = await this.fetch(input);
        const responseClone = response.clone();
        void this.waitUntil(this.cachePut(input, responseClone));
        return response;
      }
      /**
       * Matches a request from the cache (and invokes any applicable plugin
       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
       * defined on the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillBeUsed()
       * - cachedResponseWillBeUsed()
       *
       * @param {Request|string} key The Request or URL to use as the cache key.
       * @return {Promise<Response|undefined>} A matching response, if found.
       */
      async cacheMatch(key) {
        const request = toRequest(key);
        let cachedResponse;
        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const effectiveRequest = await this.getCacheKey(request, 'read');
        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {
          cacheName
        });
        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
        {
          if (cachedResponse) {
            logger.debug(`Found a cached response in '${cacheName}'.`);
          } else {
            logger.debug(`No cached response found in '${cacheName}'.`);
          }
        }
        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
          cachedResponse = (await callback({
            cacheName,
            matchOptions,
            cachedResponse,
            request: effectiveRequest,
            event: this.event
          })) || undefined;
        }
        return cachedResponse;
      }
      /**
       * Puts a request/response pair in the cache (and invokes any applicable
       * plugin callback methods) using the `cacheName` and `plugins` defined on
       * the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillBeUsed()
       * - cacheWillUpdate()
       * - cacheDidUpdate()
       *
       * @param {Request|string} key The request or URL to use as the cache key.
       * @param {Response} response The response to cache.
       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
       * not be cached, and `true` otherwise.
       */
      async cachePut(key, response) {
        const request = toRequest(key);
        // Run in the next task to avoid blocking other cache reads.
        // https://github.com/w3c/ServiceWorker/issues/1397
        await timeout(0);
        const effectiveRequest = await this.getCacheKey(request, 'write');
        {
          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
            throw new WorkboxError('attempt-to-cache-non-get-request', {
              url: getFriendlyURL(effectiveRequest.url),
              method: effectiveRequest.method
            });
          }
          // See https://github.com/GoogleChrome/workbox/issues/2818
          const vary = response.headers.get('Vary');
          if (vary) {
            logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);
          }
        }
        if (!response) {
          {
            logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);
          }
          throw new WorkboxError('cache-put-with-no-response', {
            url: getFriendlyURL(effectiveRequest.url)
          });
        }
        const responseToCache = await this._ensureResponseSafeToCache(response);
        if (!responseToCache) {
          {
            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);
          }
          return false;
        }
        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const cache = await self.caches.open(cacheName);
        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
        // feature. Consider into ways to only add this behavior if using
        // precaching.
        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;
        {
          logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);
        }
        try {
          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);
        } catch (error) {
          if (error instanceof Error) {
            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
            if (error.name === 'QuotaExceededError') {
              await executeQuotaErrorCallbacks();
            }
            throw error;
          }
        }
        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
          await callback({
            cacheName,
            oldResponse,
            newResponse: responseToCache.clone(),
            request: effectiveRequest,
            event: this.event
          });
        }
        return true;
      }
      /**
       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
       * executes any of those callbacks found in sequence. The final `Request`
       * object returned by the last plugin is treated as the cache key for cache
       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
       * been registered, the passed request is returned unmodified
       *
       * @param {Request} request
       * @param {string} mode
       * @return {Promise<Request>}
       */
      async getCacheKey(request, mode) {
        const key = `${request.url} | ${mode}`;
        if (!this._cacheKeys[key]) {
          let effectiveRequest = request;
          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
            effectiveRequest = toRequest(await callback({
              mode,
              request: effectiveRequest,
              event: this.event,
              // params has a type any can't change right now.
              params: this.params // eslint-disable-line
            }));
          }
          this._cacheKeys[key] = effectiveRequest;
        }
        return this._cacheKeys[key];
      }
      /**
       * Returns true if the strategy has at least one plugin with the given
       * callback.
       *
       * @param {string} name The name of the callback to check for.
       * @return {boolean}
       */
      hasCallback(name) {
        for (const plugin of this._strategy.plugins) {
          if (name in plugin) {
            return true;
          }
        }
        return false;
      }
      /**
       * Runs all plugin callbacks matching the given name, in order, passing the
       * given param object (merged ith the current plugin state) as the only
       * argument.
       *
       * Note: since this method runs all plugins, it's not suitable for cases
       * where the return value of a callback needs to be applied prior to calling
       * the next callback. See
       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
       * below for how to handle that case.
       *
       * @param {string} name The name of the callback to run within each plugin.
       * @param {Object} param The object to pass as the first (and only) param
       *     when executing each callback. This object will be merged with the
       *     current plugin state prior to callback execution.
       */
      async runCallbacks(name, param) {
        for (const callback of this.iterateCallbacks(name)) {
          // TODO(philipwalton): not sure why `any` is needed. It seems like
          // this should work with `as WorkboxPluginCallbackParam[C]`.
          await callback(param);
        }
      }
      /**
       * Accepts a callback and returns an iterable of matching plugin callbacks,
       * where each callback is wrapped with the current handler state (i.e. when
       * you call each callback, whatever object parameter you pass it will
       * be merged with the plugin's current state).
       *
       * @param {string} name The name fo the callback to run
       * @return {Array<Function>}
       */
      *iterateCallbacks(name) {
        for (const plugin of this._strategy.plugins) {
          if (typeof plugin[name] === 'function') {
            const state = this._pluginStateMap.get(plugin);
            const statefulCallback = param => {
              const statefulParam = Object.assign(Object.assign({}, param), {
                state
              });
              // TODO(philipwalton): not sure why `any` is needed. It seems like
              // this should work with `as WorkboxPluginCallbackParam[C]`.
              return plugin[name](statefulParam);
            };
            yield statefulCallback;
          }
        }
      }
      /**
       * Adds a promise to the
       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
       * of the event associated with the request being handled (usually a
       * `FetchEvent`).
       *
       * Note: you can await
       * {@link workbox-strategies.StrategyHandler~doneWaiting}
       * to know when all added promises have settled.
       *
       * @param {Promise} promise A promise to add to the extend lifetime promises
       *     of the event that triggered the request.
       */
      waitUntil(promise) {
        this._extendLifetimePromises.push(promise);
        return promise;
      }
      /**
       * Returns a promise that resolves once all promises passed to
       * {@link workbox-strategies.StrategyHandler~waitUntil}
       * have settled.
       *
       * Note: any work done after `doneWaiting()` settles should be manually
       * passed to an event's `waitUntil()` method (not this handler's
       * `waitUntil()` method), otherwise the service worker thread may be killed
       * prior to your work completing.
       */
      async doneWaiting() {
        while (this._extendLifetimePromises.length) {
          const promises = this._extendLifetimePromises.splice(0);
          const result = await Promise.allSettled(promises);
          const firstRejection = result.find(i => i.status === 'rejected');
          if (firstRejection) {
            throw firstRejection.reason;
          }
        }
      }
      /**
       * Stops running the strategy and immediately resolves any pending
       * `waitUntil()` promises.
       */
      destroy() {
        this._handlerDeferred.resolve(null);
      }
      /**
       * This method will call cacheWillUpdate on the available plugins (or use
       * status === 200) to determine if the Response is safe and valid to cache.
       *
       * @param {Request} options.request
       * @param {Response} options.response
       * @return {Promise<Response|undefined>}
       *
       * @private
       */
      async _ensureResponseSafeToCache(response) {
        let responseToCache = response;
        let pluginsUsed = false;
        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
          responseToCache = (await callback({
            request: this.request,
            response: responseToCache,
            event: this.event
          })) || undefined;
          pluginsUsed = true;
          if (!responseToCache) {
            break;
          }
        }
        if (!pluginsUsed) {
          if (responseToCache && responseToCache.status !== 200) {
            responseToCache = undefined;
          }
          {
            if (responseToCache) {
              if (responseToCache.status !== 200) {
                if (responseToCache.status === 0) {
                  logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);
                } else {
                  logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);
                }
              }
            }
          }
        }
        return responseToCache;
      }
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An abstract base class that all other strategy classes must extend from:
     *
     * @memberof workbox-strategies
     */
    class Strategy {
      /**
       * Creates a new instance of the strategy and sets all documented option
       * properties as public instance properties.
       *
       * Note: if a custom strategy class extends the base Strategy class and does
       * not need more than these properties, it does not need to define its own
       * constructor.
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to the cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] The
       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
       * for any `cache.match()` or `cache.put()` calls made by this strategy.
       */
      constructor(options = {}) {
        /**
         * Cache name to store and retrieve
         * requests. Defaults to the cache names provided by
         * {@link workbox-core.cacheNames}.
         *
         * @type {string}
         */
        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
        /**
         * The list
         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
         * used by this strategy.
         *
         * @type {Array<Object>}
         */
        this.plugins = options.plugins || [];
        /**
         * Values passed along to the
         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
         * of all fetch() requests made by this strategy.
         *
         * @type {Object}
         */
        this.fetchOptions = options.fetchOptions;
        /**
         * The
         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
         * for any `cache.match()` or `cache.put()` calls made by this strategy.
         *
         * @type {Object}
         */
        this.matchOptions = options.matchOptions;
      }
      /**
       * Perform a request strategy and returns a `Promise` that will resolve with
       * a `Response`, invoking all relevant plugin callbacks.
       *
       * When a strategy instance is registered with a Workbox
       * {@link workbox-routing.Route}, this method is automatically
       * called when the route matches.
       *
       * Alternatively, this method can be used in a standalone `FetchEvent`
       * listener by passing it to `event.respondWith()`.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       */
      handle(options) {
        const [responseDone] = this.handleAll(options);
        return responseDone;
      }
      /**
       * Similar to {@link workbox-strategies.Strategy~handle}, but
       * instead of just returning a `Promise` that resolves to a `Response` it
       * it will return an tuple of `[response, done]` promises, where the former
       * (`response`) is equivalent to what `handle()` returns, and the latter is a
       * Promise that will resolve once any promises that were added to
       * `event.waitUntil()` as part of performing the strategy have completed.
       *
       * You can await the `done` promise to ensure any extra work performed by
       * the strategy (usually caching responses) completes successfully.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       * @return {Array<Promise>} A tuple of [response, done]
       *     promises that can be used to determine when the response resolves as
       *     well as when the handler has completed all its work.
       */
      handleAll(options) {
        // Allow for flexible options to be passed.
        if (options instanceof FetchEvent) {
          options = {
            event: options,
            request: options.request
          };
        }
        const event = options.event;
        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;
        const params = 'params' in options ? options.params : undefined;
        const handler = new StrategyHandler(this, {
          event,
          request,
          params
        });
        const responseDone = this._getResponse(handler, request, event);
        const handlerDone = this._awaitComplete(responseDone, handler, request, event);
        // Return an array of promises, suitable for use with Promise.all().
        return [responseDone, handlerDone];
      }
      async _getResponse(handler, request, event) {
        await handler.runCallbacks('handlerWillStart', {
          event,
          request
        });
        let response = undefined;
        try {
          response = await this._handle(request, handler);
          // The "official" Strategy subclasses all throw this error automatically,
          // but in case a third-party Strategy doesn't, ensure that we have a
          // consistent failure when there's no response or an error response.
          if (!response || response.type === 'error') {
            throw new WorkboxError('no-response', {
              url: request.url
            });
          }
        } catch (error) {
          if (error instanceof Error) {
            for (const callback of handler.iterateCallbacks('handlerDidError')) {
              response = await callback({
                error,
                event,
                request
              });
              if (response) {
                break;
              }
            }
          }
          if (!response) {
            throw error;
          } else {
            logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);
          }
        }
        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
          response = await callback({
            event,
            request,
            response
          });
        }
        return response;
      }
      async _awaitComplete(responseDone, handler, request, event) {
        let response;
        let error;
        try {
          response = await responseDone;
        } catch (error) {
          // Ignore errors, as response errors should be caught via the `response`
          // promise above. The `done` promise will only throw for errors in
          // promises passed to `handler.waitUntil()`.
        }
        try {
          await handler.runCallbacks('handlerDidRespond', {
            event,
            request,
            response
          });
          await handler.doneWaiting();
        } catch (waitUntilError) {
          if (waitUntilError instanceof Error) {
            error = waitUntilError;
          }
        }
        await handler.runCallbacks('handlerDidComplete', {
          event,
          request,
          response,
          error: error
        });
        handler.destroy();
        if (error) {
          throw error;
        }
      }
    }
    /**
     * Classes extending the `Strategy` based class should implement this method,
     * and leverage the {@link workbox-strategies.StrategyHandler}
     * arg to perform all fetching and cache logic, which will ensure all relevant
     * cache, cache options, fetch options and plugins are used (per the current
     * strategy instance).
     *
     * @name _handle
     * @instance
     * @abstract
     * @function
     * @param {Request} request
     * @param {workbox-strategies.StrategyHandler} handler
     * @return {Promise<Response>}
     *
     * @memberof workbox-strategies.Strategy
     */

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A {@link workbox-strategies.Strategy} implementation
     * specifically designed to work with
     * {@link workbox-precaching.PrecacheController}
     * to both cache and fetch precached assets.
     *
     * Note: an instance of this class is created automatically when creating a
     * `PrecacheController`; it's generally not necessary to create this yourself.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-precaching
     */
    class PrecacheStrategy extends Strategy {
      /**
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to the cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}
       * of all fetch() requests made by this strategy.
       * @param {Object} [options.matchOptions] The
       * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}
       * for any `cache.match()` or `cache.put()` calls made by this strategy.
       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
       * get the response from the network if there's a precache miss.
       */
      constructor(options = {}) {
        options.cacheName = cacheNames.getPrecacheName(options.cacheName);
        super(options);
        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;
        // Redirected responses cannot be used to satisfy a navigation request, so
        // any redirected response must be "copied" rather than cloned, so the new
        // response doesn't contain the `redirected` flag. See:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        const response = await handler.cacheMatch(request);
        if (response) {
          return response;
        }
        // If this is an `install` event for an entry that isn't already cached,
        // then populate the cache.
        if (handler.event && handler.event.type === 'install') {
          return await this._handleInstall(request, handler);
        }
        // Getting here means something went wrong. An entry that should have been
        // precached wasn't found in the cache.
        return await this._handleFetch(request, handler);
      }
      async _handleFetch(request, handler) {
        let response;
        const params = handler.params || {};
        // Fall back to the network if we're configured to do so.
        if (this._fallbackToNetwork) {
          {
            logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);
          }
          const integrityInManifest = params.integrity;
          const integrityInRequest = request.integrity;
          const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;
          // Do not add integrity if the original request is no-cors
          // See https://github.com/GoogleChrome/workbox/issues/3096
          response = await handler.fetch(new Request(request, {
            integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined
          }));
          // It's only "safe" to repair the cache if we're using SRI to guarantee
          // that the response matches the precache manifest's expectations,
          // and there's either a) no integrity property in the incoming request
          // or b) there is an integrity, and it matches the precache manifest.
          // See https://github.com/GoogleChrome/workbox/issues/2858
          // Also if the original request users no-cors we don't use integrity.
          // See https://github.com/GoogleChrome/workbox/issues/3096
          if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {
            this._useDefaultCacheabilityPluginIfNeeded();
            const wasCached = await handler.cachePut(request, response.clone());
            {
              if (wasCached) {
                logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to "repair" the precache.`);
              }
            }
          }
        } else {
          // This shouldn't normally happen, but there are edge cases:
          // https://github.com/GoogleChrome/workbox/issues/1441
          throw new WorkboxError('missing-precache-entry', {
            cacheName: this.cacheName,
            url: request.url
          });
        }
        {
          const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));
          // Workbox is going to handle the route.
          // print the routing details to the console.
          logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));
          logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);
          logger.groupCollapsed(`View request details here.`);
          logger.log(request);
          logger.groupEnd();
          logger.groupCollapsed(`View response details here.`);
          logger.log(response);
          logger.groupEnd();
          logger.groupEnd();
        }
        return response;
      }
      async _handleInstall(request, handler) {
        this._useDefaultCacheabilityPluginIfNeeded();
        const response = await handler.fetch(request);
        // Make sure we defer cachePut() until after we know the response
        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737
        const wasCached = await handler.cachePut(request, response.clone());
        if (!wasCached) {
          // Throwing here will lead to the `install` handler failing, which
          // we want to do if *any* of the responses aren't safe to cache.
          throw new WorkboxError('bad-precaching-response', {
            url: request.url,
            status: response.status
          });
        }
        return response;
      }
      /**
       * This method is complex, as there a number of things to account for:
       *
       * The `plugins` array can be set at construction, and/or it might be added to
       * to at any time before the strategy is used.
       *
       * At the time the strategy is used (i.e. during an `install` event), there
       * needs to be at least one plugin that implements `cacheWillUpdate` in the
       * array, other than `copyRedirectedCacheableResponsesPlugin`.
       *
       * - If this method is called and there are no suitable `cacheWillUpdate`
       * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.
       *
       * - If this method is called and there is exactly one `cacheWillUpdate`, then
       * we don't have to do anything (this might be a previously added
       * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).
       *
       * - If this method is called and there is more than one `cacheWillUpdate`,
       * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,
       * we need to remove it. (This situation is unlikely, but it could happen if
       * the strategy is used multiple times, the first without a `cacheWillUpdate`,
       * and then later on after manually adding a custom `cacheWillUpdate`.)
       *
       * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.
       *
       * @private
       */
      _useDefaultCacheabilityPluginIfNeeded() {
        let defaultPluginIndex = null;
        let cacheWillUpdatePluginCount = 0;
        for (const [index, plugin] of this.plugins.entries()) {
          // Ignore the copy redirected plugin when determining what to do.
          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {
            continue;
          }
          // Save the default plugin's index, in case it needs to be removed.
          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {
            defaultPluginIndex = index;
          }
          if (plugin.cacheWillUpdate) {
            cacheWillUpdatePluginCount++;
          }
        }
        if (cacheWillUpdatePluginCount === 0) {
          this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);
        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {
          // Only remove the default plugin; multiple custom plugins are allowed.
          this.plugins.splice(defaultPluginIndex, 1);
        }
        // Nothing needs to be done if cacheWillUpdatePluginCount is 1
      }
    }
    PrecacheStrategy.defaultPrecacheCacheabilityPlugin = {
      async cacheWillUpdate({
        response
      }) {
        if (!response || response.status >= 400) {
          return null;
        }
        return response;
      }
    };
    PrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {
      async cacheWillUpdate({
        response
      }) {
        return response.redirected ? await copyResponse(response) : response;
      }
    };

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Performs efficient precaching of assets.
     *
     * @memberof workbox-precaching
     */
    class PrecacheController {
      /**
       * Create a new PrecacheController.
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] The cache to use for precaching.
       * @param {string} [options.plugins] Plugins to use when precaching as well
       * as responding to fetch events for precached assets.
       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
       * get the response from the network if there's a precache miss.
       */
      constructor({
        cacheName,
        plugins = [],
        fallbackToNetwork = true
      } = {}) {
        this._urlsToCacheKeys = new Map();
        this._urlsToCacheModes = new Map();
        this._cacheKeysToIntegrities = new Map();
        this._strategy = new PrecacheStrategy({
          cacheName: cacheNames.getPrecacheName(cacheName),
          plugins: [...plugins, new PrecacheCacheKeyPlugin({
            precacheController: this
          })],
          fallbackToNetwork
        });
        // Bind the install and activate methods to the instance.
        this.install = this.install.bind(this);
        this.activate = this.activate.bind(this);
      }
      /**
       * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and
       * used to cache assets and respond to fetch events.
       */
      get strategy() {
        return this._strategy;
      }
      /**
       * Adds items to the precache list, removing any duplicates and
       * stores the files in the
       * {@link workbox-core.cacheNames|"precache cache"} when the service
       * worker installs.
       *
       * This method can be called multiple times.
       *
       * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
       */
      precache(entries) {
        this.addToCacheList(entries);
        if (!this._installAndActiveListenersAdded) {
          self.addEventListener('install', this.install);
          self.addEventListener('activate', this.activate);
          this._installAndActiveListenersAdded = true;
        }
      }
      /**
       * This method will add items to the precache list, removing duplicates
       * and ensuring the information is valid.
       *
       * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
       *     Array of entries to precache.
       */
      addToCacheList(entries) {
        {
          finalAssertExports.isArray(entries, {
            moduleName: 'workbox-precaching',
            className: 'PrecacheController',
            funcName: 'addToCacheList',
            paramName: 'entries'
          });
        }
        const urlsToWarnAbout = [];
        for (const entry of entries) {
          // See https://github.com/GoogleChrome/workbox/issues/2259
          if (typeof entry === 'string') {
            urlsToWarnAbout.push(entry);
          } else if (entry && entry.revision === undefined) {
            urlsToWarnAbout.push(entry.url);
          }
          const {
            cacheKey,
            url
          } = createCacheKey(entry);
          const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';
          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {
            throw new WorkboxError('add-to-cache-list-conflicting-entries', {
              firstEntry: this._urlsToCacheKeys.get(url),
              secondEntry: cacheKey
            });
          }
          if (typeof entry !== 'string' && entry.integrity) {
            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {
                url
              });
            }
            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
          }
          this._urlsToCacheKeys.set(url, cacheKey);
          this._urlsToCacheModes.set(url, cacheMode);
          if (urlsToWarnAbout.length > 0) {
            const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;
            {
              logger.warn(warningMessage);
            }
          }
        }
      }
      /**
       * Precaches new and updated assets. Call this method from the service worker
       * install event.
       *
       * Note: this method calls `event.waitUntil()` for you, so you do not need
       * to call it yourself in your event handlers.
       *
       * @param {ExtendableEvent} event
       * @return {Promise<workbox-precaching.InstallResult>}
       */
      install(event) {
        // waitUntil returns Promise<any>
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return waitUntil(event, async () => {
          const installReportPlugin = new PrecacheInstallReportPlugin();
          this.strategy.plugins.push(installReportPlugin);
          // Cache entries one at a time.
          // See https://github.com/GoogleChrome/workbox/issues/2528
          for (const [url, cacheKey] of this._urlsToCacheKeys) {
            const integrity = this._cacheKeysToIntegrities.get(cacheKey);
            const cacheMode = this._urlsToCacheModes.get(url);
            const request = new Request(url, {
              integrity,
              cache: cacheMode,
              credentials: 'same-origin'
            });
            await Promise.all(this.strategy.handleAll({
              params: {
                cacheKey
              },
              request,
              event
            }));
          }
          const {
            updatedURLs,
            notUpdatedURLs
          } = installReportPlugin;
          {
            printInstallDetails(updatedURLs, notUpdatedURLs);
          }
          return {
            updatedURLs,
            notUpdatedURLs
          };
        });
      }
      /**
       * Deletes assets that are no longer present in the current precache manifest.
       * Call this method from the service worker activate event.
       *
       * Note: this method calls `event.waitUntil()` for you, so you do not need
       * to call it yourself in your event handlers.
       *
       * @param {ExtendableEvent} event
       * @return {Promise<workbox-precaching.CleanupResult>}
       */
      activate(event) {
        // waitUntil returns Promise<any>
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return waitUntil(event, async () => {
          const cache = await self.caches.open(this.strategy.cacheName);
          const currentlyCachedRequests = await cache.keys();
          const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
          const deletedURLs = [];
          for (const request of currentlyCachedRequests) {
            if (!expectedCacheKeys.has(request.url)) {
              await cache.delete(request);
              deletedURLs.push(request.url);
            }
          }
          {
            printCleanupDetails(deletedURLs);
          }
          return {
            deletedURLs
          };
        });
      }
      /**
       * Returns a mapping of a precached URL to the corresponding cache key, taking
       * into account the revision information for the URL.
       *
       * @return {Map<string, string>} A URL to cache key mapping.
       */
      getURLsToCacheKeys() {
        return this._urlsToCacheKeys;
      }
      /**
       * Returns a list of all the URLs that have been precached by the current
       * service worker.
       *
       * @return {Array<string>} The precached URLs.
       */
      getCachedURLs() {
        return [...this._urlsToCacheKeys.keys()];
      }
      /**
       * Returns the cache key used for storing a given URL. If that URL is
       * unversioned, like `/index.html', then the cache key will be the original
       * URL with a search parameter appended to it.
       *
       * @param {string} url A URL whose cache key you want to look up.
       * @return {string} The versioned URL that corresponds to a cache key
       * for the original URL, or undefined if that URL isn't precached.
       */
      getCacheKeyForURL(url) {
        const urlObject = new URL(url, location.href);
        return this._urlsToCacheKeys.get(urlObject.href);
      }
      /**
       * @param {string} url A cache key whose SRI you want to look up.
       * @return {string} The subresource integrity associated with the cache key,
       * or undefined if it's not set.
       */
      getIntegrityForCacheKey(cacheKey) {
        return this._cacheKeysToIntegrities.get(cacheKey);
      }
      /**
       * This acts as a drop-in replacement for
       * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
       * with the following differences:
       *
       * - It knows what the name of the precache is, and only checks in that cache.
       * - It allows you to pass in an "original" URL without versioning parameters,
       * and it will automatically look up the correct cache key for the currently
       * active revision of that URL.
       *
       * E.g., `matchPrecache('index.html')` will find the correct precached
       * response for the currently active service worker, even if the actual cache
       * key is `'/index.html?__WB_REVISION__=1234abcd'`.
       *
       * @param {string|Request} request The key (without revisioning parameters)
       * to look up in the precache.
       * @return {Promise<Response|undefined>}
       */
      async matchPrecache(request) {
        const url = request instanceof Request ? request.url : request;
        const cacheKey = this.getCacheKeyForURL(url);
        if (cacheKey) {
          const cache = await self.caches.open(this.strategy.cacheName);
          return cache.match(cacheKey);
        }
        return undefined;
      }
      /**
       * Returns a function that looks up `url` in the precache (taking into
       * account revision information), and returns the corresponding `Response`.
       *
       * @param {string} url The precached URL which will be used to lookup the
       * `Response`.
       * @return {workbox-routing~handlerCallback}
       */
      createHandlerBoundToURL(url) {
        const cacheKey = this.getCacheKeyForURL(url);
        if (!cacheKey) {
          throw new WorkboxError('non-precached-url', {
            url
          });
        }
        return options => {
          options.request = new Request(url);
          options.params = Object.assign({
            cacheKey
          }, options.params);
          return this.strategy.handle(options);
        };
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    let precacheController;
    /**
     * @return {PrecacheController}
     * @private
     */
    const getOrCreatePrecacheController = () => {
      if (!precacheController) {
        precacheController = new PrecacheController();
      }
      return precacheController;
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Removes any URL search parameters that should be ignored.
     *
     * @param {URL} urlObject The original URL.
     * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against
     * each search parameter name. Matches mean that the search parameter should be
     * ignored.
     * @return {URL} The URL with any ignored search parameters removed.
     *
     * @private
     * @memberof workbox-precaching
     */
    function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
      // Convert the iterable into an array at the start of the loop to make sure
      // deletion doesn't mess up iteration.
      for (const paramName of [...urlObject.searchParams.keys()]) {
        if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {
          urlObject.searchParams.delete(paramName);
        }
      }
      return urlObject;
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Generator function that yields possible variations on the original URL to
     * check, one at a time.
     *
     * @param {string} url
     * @param {Object} options
     *
     * @private
     * @memberof workbox-precaching
     */
    function* generateURLVariations(url, {
      ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],
      directoryIndex = 'index.html',
      cleanURLs = true,
      urlManipulation
    } = {}) {
      const urlObject = new URL(url, location.href);
      urlObject.hash = '';
      yield urlObject.href;
      const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
      yield urlWithoutIgnoredParams.href;
      if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
        const directoryURL = new URL(urlWithoutIgnoredParams.href);
        directoryURL.pathname += directoryIndex;
        yield directoryURL.href;
      }
      if (cleanURLs) {
        const cleanURL = new URL(urlWithoutIgnoredParams.href);
        cleanURL.pathname += '.html';
        yield cleanURL.href;
      }
      if (urlManipulation) {
        const additionalURLs = urlManipulation({
          url: urlObject
        });
        for (const urlToAttempt of additionalURLs) {
          yield urlToAttempt.href;
        }
      }
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A subclass of {@link workbox-routing.Route} that takes a
     * {@link workbox-precaching.PrecacheController}
     * instance and uses it to match incoming requests and handle fetching
     * responses from the precache.
     *
     * @memberof workbox-precaching
     * @extends workbox-routing.Route
     */
    class PrecacheRoute extends Route {
      /**
       * @param {PrecacheController} precacheController A `PrecacheController`
       * instance used to both match requests and respond to fetch events.
       * @param {Object} [options] Options to control how requests are matched
       * against the list of precached URLs.
       * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
       * check cache entries for a URLs ending with '/' to see if there is a hit when
       * appending the `directoryIndex` value.
       * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
       * array of regex's to remove search params when looking for a cache match.
       * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
       * check the cache for the URL with a `.html` added to the end of the end.
       * @param {workbox-precaching~urlManipulation} [options.urlManipulation]
       * This is a function that should take a URL and return an array of
       * alternative URLs that should be checked for precache matches.
       */
      constructor(precacheController, options) {
        const match = ({
          request
        }) => {
          const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
          for (const possibleURL of generateURLVariations(request.url, options)) {
            const cacheKey = urlsToCacheKeys.get(possibleURL);
            if (cacheKey) {
              const integrity = precacheController.getIntegrityForCacheKey(cacheKey);
              return {
                cacheKey,
                integrity
              };
            }
          }
          {
            logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));
          }
          return;
        };
        super(match, precacheController.strategy);
      }
    }

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Add a `fetch` listener to the service worker that will
     * respond to
     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}
     * with precached assets.
     *
     * Requests for assets that aren't precached, the `FetchEvent` will not be
     * responded to, allowing the event to fall through to other `fetch` event
     * listeners.
     *
     * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}
     * options.
     *
     * @memberof workbox-precaching
     */
    function addRoute(options) {
      const precacheController = getOrCreatePrecacheController();
      const precacheRoute = new PrecacheRoute(precacheController, options);
      registerRoute(precacheRoute);
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Adds items to the precache list, removing any duplicates and
     * stores the files in the
     * {@link workbox-core.cacheNames|"precache cache"} when the service
     * worker installs.
     *
     * This method can be called multiple times.
     *
     * Please note: This method **will not** serve any of the cached files for you.
     * It only precaches files. To respond to a network request you call
     * {@link workbox-precaching.addRoute}.
     *
     * If you have a single array of files to precache, you can just call
     * {@link workbox-precaching.precacheAndRoute}.
     *
     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
     *
     * @memberof workbox-precaching
     */
    function precache(entries) {
      const precacheController = getOrCreatePrecacheController();
      precacheController.precache(entries);
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * This method will add entries to the precache list and add a route to
     * respond to fetch events.
     *
     * This is a convenience method that will call
     * {@link workbox-precaching.precache} and
     * {@link workbox-precaching.addRoute} in a single call.
     *
     * @param {Array<Object|string>} entries Array of entries to precache.
     * @param {Object} [options] See the
     * {@link workbox-precaching.PrecacheRoute} options.
     *
     * @memberof workbox-precaching
     */
    function precacheAndRoute(entries, options) {
      precache(entries);
      addRoute(options);
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const SUBSTRING_TO_FIND = '-precache-';
    /**
     * Cleans up incompatible precaches that were created by older versions of
     * Workbox, by a service worker registered under the current scope.
     *
     * This is meant to be called as part of the `activate` event.
     *
     * This should be safe to use as long as you don't include `substringToFind`
     * (defaulting to `-precache-`) in your non-precache cache names.
     *
     * @param {string} currentPrecacheName The cache name currently in use for
     * precaching. This cache won't be deleted.
     * @param {string} [substringToFind='-precache-'] Cache names which include this
     * substring will be deleted (excluding `currentPrecacheName`).
     * @return {Array<string>} A list of all the cache names that were deleted.
     *
     * @private
     * @memberof workbox-precaching
     */
    const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {
      const cacheNames = await self.caches.keys();
      const cacheNamesToDelete = cacheNames.filter(cacheName => {
        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;
      });
      await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));
      return cacheNamesToDelete;
    };

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Adds an `activate` event listener which will clean up incompatible
     * precaches that were created by older versions of Workbox.
     *
     * @memberof workbox-precaching
     */
    function cleanupOutdatedCaches() {
      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
      self.addEventListener('activate', event => {
        const cacheName = cacheNames.getPrecacheName();
        event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {
          {
            if (cachesDeleted.length > 0) {
              logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);
            }
          }
        }));
      });
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * NavigationRoute makes it easy to create a
     * {@link workbox-routing.Route} that matches for browser
     * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.
     *
     * It will only match incoming Requests whose
     * {@link https://fetch.spec.whatwg.org/#concept-request-mode|mode}
     * is set to `navigate`.
     *
     * You can optionally only apply this route to a subset of navigation requests
     * by using one or both of the `denylist` and `allowlist` parameters.
     *
     * @memberof workbox-routing
     * @extends workbox-routing.Route
     */
    class NavigationRoute extends Route {
      /**
       * If both `denylist` and `allowlist` are provided, the `denylist` will
       * take precedence and the request will not match this route.
       *
       * The regular expressions in `allowlist` and `denylist`
       * are matched against the concatenated
       * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}
       * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}
       * portions of the requested URL.
       *
       * *Note*: These RegExps may be evaluated against every destination URL during
       * a navigation. Avoid using
       * [complex RegExps](https://github.com/GoogleChrome/workbox/issues/3077),
       * or else your users may see delays when navigating your site.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {Object} options
       * @param {Array<RegExp>} [options.denylist] If any of these patterns match,
       * the route will not handle the request (even if a allowlist RegExp matches).
       * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns
       * match the URL's pathname and search parameter, the route will handle the
       * request (assuming the denylist doesn't match).
       */
      constructor(handler, {
        allowlist = [/./],
        denylist = []
      } = {}) {
        {
          finalAssertExports.isArrayOfClass(allowlist, RegExp, {
            moduleName: 'workbox-routing',
            className: 'NavigationRoute',
            funcName: 'constructor',
            paramName: 'options.allowlist'
          });
          finalAssertExports.isArrayOfClass(denylist, RegExp, {
            moduleName: 'workbox-routing',
            className: 'NavigationRoute',
            funcName: 'constructor',
            paramName: 'options.denylist'
          });
        }
        super(options => this._match(options), handler);
        this._allowlist = allowlist;
        this._denylist = denylist;
      }
      /**
       * Routes match handler.
       *
       * @param {Object} options
       * @param {URL} options.url
       * @param {Request} options.request
       * @return {boolean}
       *
       * @private
       */
      _match({
        url,
        request
      }) {
        if (request && request.mode !== 'navigate') {
          return false;
        }
        const pathnameAndSearch = url.pathname + url.search;
        for (const regExp of this._denylist) {
          if (regExp.test(pathnameAndSearch)) {
            {
              logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL matches this denylist pattern: ` + `${regExp.toString()}`);
            }
            return false;
          }
        }
        if (this._allowlist.some(regExp => regExp.test(pathnameAndSearch))) {
          {
            logger.debug(`The navigation route ${pathnameAndSearch} ` + `is being used.`);
          }
          return true;
        }
        {
          logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL being navigated to doesn't ` + `match the allowlist.`);
        }
        return false;
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Helper function that calls
     * {@link PrecacheController#createHandlerBoundToURL} on the default
     * {@link PrecacheController} instance.
     *
     * If you are creating your own {@link PrecacheController}, then call the
     * {@link PrecacheController#createHandlerBoundToURL} on that instance,
     * instead of using this function.
     *
     * @param {string} url The precached URL which will be used to lookup the
     * `Response`.
     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the
     * response from the network if there's a precache miss.
     * @return {workbox-routing~handlerCallback}
     *
     * @memberof workbox-precaching
     */
    function createHandlerBoundToURL(url) {
      const precacheController = getOrCreatePrecacheController();
      return precacheController.createHandlerBoundToURL(url);
    }

    exports.NavigationRoute = NavigationRoute;
    exports.cleanupOutdatedCaches = cleanupOutdatedCaches;
    exports.clientsClaim = clientsClaim;
    exports.createHandlerBoundToURL = createHandlerBoundToURL;
    exports.precacheAndRoute = precacheAndRoute;
    exports.registerRoute = registerRoute;

}));


==================================================
FILE: src\api.js
==================================================
export const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://www.kor35.it';

/**
 * Helper generico per le chiamate API autenticate.
 * Gestisce l'header Authorization e il caso di token non valido.
 * @param {string} endpoint - L'endpoint API (es. /personaggi/api/personaggi/)
 * @param {object} options - Opzioni standard di fetch (method, body, etc.)
 * @param {function} onLogout - La funzione di logout da App.jsx
 */
export const fetchAuthenticated = async (endpoint, options = {}, onLogout) => {
  const token = localStorage.getItem('kor35_token');
  
  if (!token) {
    console.error('Nessun token trovato, logout in corso.');
    if (onLogout) onLogout();
    // NOTA: Restituire una Promise reietta è corretto qui
    return Promise.reject(new Error('Nessun token di autenticazione.'));
  }

  const headers = {
    // 'Content-Type': 'application/json', // Rimosso: vedi nota sotto
    'Authorization': `Token ${token}`,
    ...options.headers,
  };

  // Aggiungi Content-Type solo se il corpo non è FormData
  // (per gestire futuri upload di file)
  if (options.body && !(options.body instanceof FormData)) {
    headers['Content-Type'] = 'application/json';
  } else if (!options.body) {
    // Aggiungi solo se non c'è corpo (come nelle GET)
    headers['Content-Type'] = 'application/json';
  }

  try {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, { ...options, headers });

    if (response.status === 401 || response.status === 403) {
      console.error('Token non valido o scaduto, logout in corso.');
      if (onLogout) onLogout();
      throw new Error('Autenticazione fallita.');
    }
    
    if (!response.ok) {
        // --- CORREZIONE: Gestione Errori "Body Stream" ---
        // Leggiamo la risposta come testo *una sola volta*.
        const errorText = await response.text();
        let errorMsg = errorText; // Default all'intero testo
        
        try {
            // Proviamo a parsare il testo come JSON
            const errorData = JSON.parse(errorText);
            // Se ci riusciamo, cerchiamo un messaggio di errore più pulito
            errorMsg = errorData.detail || errorData.error || JSON.stringify(errorData);
        } catch (e) {
            // Non era JSON, va bene. 'errorMsg' rimane l'HTML/testo
            // (es. la pagina 404 di Django)
        }
        
        // Ora lanciamo l'errore in modo pulito
        console.error(`Errore API ${response.status} (${response.statusText}) per ${endpoint}:`, errorMsg);
        throw new Error(`Errore API (${response.status}): ${errorMsg}`);
        // --- FINE CORREZIONE ---
    }

    if (response.status === 204) { // No Content
        return null;
    }

    return await response.json();
  
  } catch (error) {
    // Rimuoviamo il console.error qui perché lo gestiamo già sopra
    // in modo più pulito nel blocco !response.ok
    // console.error(`Errore durante il fetch a ${endpoint}:`, error);
    throw error;
  }
};


export const fetchPublic = async (endpoint, options = {}) => {
  const headers = {
    'Content-Type': 'application/json',
    ...options.headers,
  };

  try {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, { ...options, headers });
    
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Errore API Public (${response.status}): ${errorText}`);
    }
    return await response.json();
  } catch (error) {
    console.error(`Errore fetch public ${endpoint}:`, error);
    throw error;
  }
};

// --- Funzioni API specifiche ---

/**
 * Recupera la configurazione degli slot corporei (costanti).
 * Utile se vuoi popolarli dinamicamente, altrimenti usiamo costanti nel frontend.
 */
export const getBodySlots = () => {
  // Possiamo hardcodarlo nel frontend per semplicità o fare una chiamata
  return [
      { code: 'HD1', name: 'Testa 1 (Cervello/Occhi)' },
      { code: 'HD2', name: 'Testa 2 (Volto/Orecchie)' },
      { code: 'TR1', name: 'Tronco 1 (Cuore/Polmoni)' },
      { code: 'TR2', name: 'Tronco 2 (Spina Dorsale/Pelle)' },
      { code: 'RA', name: 'Braccio Destro' },
      { code: 'LA', name: 'Braccio Sinistro' },
      { code: 'RL', name: 'Gamba Destra' },
      { code: 'LL', name: 'Gamba Sinistra' },
  ];
};

/**
 * Recupera la lista dei personaggi associati all'utente.
 */
export const getPersonaggiList = (onLogout, viewAll = false) => {
  // Costruisci la query string se viewAll è true
  const queryParam = viewAll ? '?view_all=true' : '';
  
  return fetchAuthenticated(`/personaggi/api/personaggi/${queryParam}`, { method: 'GET' }, onLogout);
};

/**
 * Recupera i dettagli di un personaggio specifico.
 */
export const getPersonaggioDetail = (id, onLogout) => {
  return fetchAuthenticated(`/personaggi/api/personaggi/${id}/`, { method: 'GET' }, onLogout);
};

export const getQrCodeData = (qrId, onLogout) => {
  return fetchAuthenticated(`/personaggi/api/qrcode/${qrId}/`, { method: 'GET' }, onLogout);
};

/**
 * Richiede un oggetto da un inventario (azione "Prendi").
 */
export const richiediTransazione = (oggettoId, mittenteInventarioId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/transazioni/richiedi/', 
    {
      method: 'POST',
      body: JSON.stringify({
        oggetto_id: oggettoId,
        mittente_id: mittenteInventarioId,
      })
    },
    onLogout
  );
};

/**
 * Tenta di rubare un oggetto da un personaggio (azione "Ruba").
 */
export const rubaOggetto = (oggettoId, targetPersonaggioId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/transazioni/ruba/', 
    {
      method: 'POST',
      body: JSON.stringify({
        oggetto_id: oggettoId,
        target_personaggio_id: targetPersonaggioId,
      })
    },
    onLogout
  );
};

/**
 * Acquisisce un oggetto/attivata da un QR code.
 */
export const acquisisciItem = (qrCodeId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/transazioni/acquisisci/', 
    {
      method: 'POST',
      body: JSON.stringify({
        qrcode_id: qrCodeId,
      })
    },
    onLogout
  );
};

/**
 * Recupera la lista master di tutte le abilità.
 * @deprecated Non più usata, sostituita da getAcquirableSkills e dati da getPersonaggioDetail
 */
export const getAbilitaMasterList = (onLogout) => {
  return fetchAuthenticated('/personaggi/api/abilita/master_list/', { method: 'GET' }, onLogout);
};

/**
 * Tenta di acquisire un'abilità per il personaggio loggato.
 */
export const acquireAbilita = (abilitaId, characterId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/personaggio/me/acquisisci_abilita/', 
    {
      method: 'POST',
      body: JSON.stringify({
        abilita_id: abilitaId,
        personaggio_id: characterId, // <-- NUOVO: Passa l'ID al backend
      })
    },
    onLogout
  );
};

/**
 * Recupera la lista di tutti i punteggi (Caratteristiche, Statistiche, ecc).
 */
export const getPunteggiList = (onLogout) => {
  return fetchAuthenticated('/personaggi/api/punteggi/all/', { method: 'GET' }, onLogout);
};


// --- MODIFICA CHIAVE ---
// Questa è la versione corretta della funzione che usa il tuo
// helper 'fetchAuthenticated' e l'URL corretto.
// Sostituisce la versione errata che ti avevo dato.

/**
 * Recupera la lista *filtrata* di abilità acquistabili per il personaggio.
 * GET /personaggi/api/personaggio/me/abilita_acquistabili/
 */
export const getAcquirableSkills = (onLogout, selectedCharacterId) => {
  // Aggiunge l'ID del personaggio come query parameter. Il backend dovrà leggere 'char_id'.
  const queryParam = selectedCharacterId ? `?char_id=${selectedCharacterId}` : '';
  
  return fetchAuthenticated(
    `/personaggi/api/personaggio/me/abilita_acquistabili/${queryParam}`, // <--- AGGIUNTO queryParam
    { method: 'GET' }, 
    onLogout
  );
};

/**
 * GET /personaggi/api/messaggi/ - Ottiene la lista dei messaggi per il PG loggato.
 */
export const getMessages = (personaggioId, onLogout) => {
  if (!personaggioId) {
    return Promise.resolve([]); // Ritorna un array vuoto se l'ID non è fornito
  }
  const url = `/personaggi/api/messaggi/?personaggio_id=${personaggioId}`;

  return fetchAuthenticated(url, { method: 'GET' }, onLogout);
};

/**
 * POST /personaggi/api/messaggi/broadcast/send/ - Invia un messaggio Broadcast.
 */
export const postBroadcastMessage = (messageData, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/messaggi/broadcast/send/',
    {
      method: 'POST',
      body: JSON.stringify(messageData)
    },
    onLogout
  );
};

/**
 * GET /personaggi/api/messaggi/admin/sent/ - Ottiene i messaggi inviati dall'admin.
 */
export const getAdminSentMessages = (onLogout) => {
  return fetchAuthenticated('/personaggi/api/messaggi/admin/sent/', { method: 'GET' }, onLogout);
};

export const saveWebPushSubscription = async (subscription, onLogout) => {
    const token = localStorage.getItem('kor35_token'); // O il nome chiave che usi tu
    
    if (!token) return;

    const response = await fetch('https://www.kor35.it/personaggi/api/webpush/subscribe/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Token ${token}` // FONDAMENTALE: Invia l'identità dell'utente
        },
        body: JSON.stringify(subscription)
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Errore server (${response.status}): ${errorText}`);
    }

    return await response.json();
};

// --- NUOVE FUNZIONI PER INFUSIONI E TESSITURE ---

/**
 * Recupera la lista delle infusioni acquistabili.
 */
export const getAcquirableInfusioni = (characterId) => {
  return fetchAuthenticated(
    `/personaggi/api/personaggio/me/infusioni_acquistabili/?char_id=${characterId}`, 
    { method: 'GET' }
  );
};

/**
 * Acquisisce un'infusione.
 */
export const acquireInfusione = (infusioneId, personaggioId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/personaggio/me/acquisisci_infusione/', 
    {
      method: 'POST',
      body: JSON.stringify({ 
        infusione_id: infusioneId, 
        personaggio_id: personaggioId 
      }),
    }, 
    onLogout
  );
};

/**
 * Recupera la lista delle tessiture acquistabili.
 */
export const getAcquirableTessiture = (characterId) => {
  return fetchAuthenticated(
    `/personaggi/api/personaggio/me/tessiture_acquistabili/?char_id=${characterId}`, 
    { method: 'GET' }
  );
};

/**
 * Acquisisce una tessitura.
 */
export const acquireTessitura = (tessituraId, personaggioId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/personaggio/me/acquisisci_tessitura/', 
    {
      method: 'POST',
      body: JSON.stringify({ 
        tessitura_id: tessituraId, 
        personaggio_id: personaggioId 
      }),
    }, 
    onLogout
  );
};

export const getModelliAura = (auraId) => {
  return fetchAuthenticated(`/personaggi/api/punteggio/${auraId}/modelli/`, { method: 'GET' });
};

export const selezionaModelloAura = (personaggioId, modelloId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/personaggio/me/seleziona_modello_aura/', 
    {
      method: 'POST',
      body: JSON.stringify({ personaggio_id: personaggioId, modello_id: modelloId })
    }, 
    onLogout
  );
};

export const getProposte = async (charId) => {
    // fetchAuthenticated restituisce già i dati, non la response raw.
    // L'errore viene gestito internamente a fetchAuthenticated.
    return await fetchAuthenticated(`/personaggi/api/proposte/?char_id=${charId}`, {
        method: 'GET'
    });
};

export const createProposta = async (data) => {
    return await fetchAuthenticated(`/personaggi/api/proposte/`, {
        method: 'POST',
        body: JSON.stringify(data)
    });
};

export const updateProposta = async (id, data) => {
    return await fetchAuthenticated(`/personaggi/api/proposte/${id}/`, {
        method: 'PATCH',
        body: JSON.stringify(data)
    });
};

export const deleteProposta = async (id) => {
    // Qui fetchAuthenticated potrebbe tornare null (204 No Content), va bene così.
    await fetchAuthenticated(`/personaggi/api/proposte/${id}/`, {
        method: 'DELETE'
    });
    return true;
};

export const sendProposta = async (id) => {
    return await fetchAuthenticated(`/personaggi/api/proposte/${id}/invia_proposta/`, {
        method: 'POST'
    });
};

// --- UTILITIES PUNTEGGI ---

export const getAllPunteggi = async () => {
    // Assicurati che l'URL finisca con /all/ come definito in urls.py
    return await fetchAuthenticated(`/personaggi/api/punteggi/all/`, {
        method: 'GET'
    });
};

export const getMattoniAura = async (auraId) => {
    // Puntiamo all'endpoint corretto che restituisce i mattoni di quella specifica aura
    return await fetchAuthenticated(`/personaggi/api/punteggio/${auraId}/mattoni/`, {
        method: 'GET'
    });
};

export const getAdminPendingProposalsCount = (onLogout) => {
  return fetchAuthenticated('/personaggi/api/admin/pending_proposals_count/', { method: 'GET' }, onLogout);
};

export const markMessageAsRead = (messageId, characterId, onLogout) => {
  return fetchAuthenticated(
    `/personaggi/api/messaggi/${messageId}/leggi/`,
    {
      method: 'POST',
      body: JSON.stringify({ personaggio_id: characterId })
    },
    onLogout
  );
};

/**
 * Cancella un messaggio (soft delete per l'utente).
 * POST /personaggi/api/messaggi/<id>/cancella/
 */
export const deleteMessage = (messageId, characterId, onLogout) => {
  return fetchAuthenticated(
    `/personaggi/api/messaggi/${messageId}/cancella/`,
    {
      method: 'POST',
      body: JSON.stringify({ personaggio_id: characterId })
    },
    onLogout
  );
};

/**
 * Recupera i log paginati.
 * @param {number} page - Numero di pagina (default 1)
 */
export const getPersonaggioLogs = (page = 1) => {
  return fetchAuthenticated(`/personaggi/api/personaggio/me/logs/?page=${page}`, { method: 'GET' });
};

/**
 * Recupera le transazioni paginate.
 * @param {number} page - Numero di pagina
 * @param {string} tipo - 'entrata' o 'uscita'
 * @param {string} charId - ID del personaggio (opzionale)
 */
export const getPersonaggioTransazioni = (page = 1, tipo = 'entrata', charId = null) => {
  let url = `/personaggi/api/personaggio/me/transazioni/?page=${page}&tipo=${tipo}`;
  if (charId) {
    url += `&char_id=${charId}`;
  }
  return fetchAuthenticated(url, { method: 'GET' });
}
/**
 * Cerca personaggi per nome (Autocomplete)
 * Opzionalmente filtra per compatibilità con un'infusione (Innesto).
 */
export const searchPersonaggi = (query, currentCharacterId, infusioneId = null) => {
  let url = `/personaggi/api/personaggi/search/?q=${encodeURIComponent(query)}&current_char_id=${currentCharacterId}`;
  if (infusioneId) {
      url += `&infusione_id=${infusioneId}`;
  }
  return fetchAuthenticated(url, { method: 'GET' });
};

/**
 * Invia un messaggio privato
 */
export const sendPrivateMessage = (messageData, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/messaggi/send/',
    {
      method: 'POST',
      body: JSON.stringify(messageData)
    },
    onLogout
  );
};

// Crea un oggetto fisico a partire da un'infusione
export const craftOggetto = (infusioneId) => {
  return fetchAuthenticated('/api/oggetti/craft/', {
    method: 'POST',
    body: JSON.stringify({ infusione_id: infusioneId })
  });
};

// // Monta un potenziamento (Mod/Materia) su un oggetto ospite
// export const montaPotenziamento = (ospiteId, potenziamentoId) => {
//   return fetchAuthenticated(`/api/oggetti/${ospiteId}/monta/`, {
//     method: 'POST',
//     body: JSON.stringify({ potenziamento_id: potenziamentoId })
//   });
// };

// Smonta un potenziamento
export const smontaPotenziamento = (ospiteId, potenziamentoId) => {
  return fetchAuthenticated(`/api/oggetti/${ospiteId}/smonta/`, {
    method: 'POST',
    body: JSON.stringify({ potenziamento_id: potenziamentoId })
  });
};

// Usa una carica (Mod, Innesti, Oggetti)
export const usaCarica = (oggettoId) => {
  return fetchAuthenticated(`/api/oggetti/${oggettoId}/usa_carica/`, {
    method: 'POST'
  });
};

// Ricarica oggetto (pagando crediti)
export const ricaricaOggetto = (oggettoId) => {
  return fetchAuthenticated(`/api/oggetti/${oggettoId}/ricarica/`, {
    method: 'POST'
  });
};

// --- API INVENTARIO & OGGETTI ---

/**
 * Equipaggia o disequipaggia un oggetto fisico.
 * POST /personaggi/api/oggetti/equipaggia/
 */
export const equipaggiaOggetto = (itemId, characterId, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/oggetti/equipaggia/', 
    {
      method: 'POST',
      // Invia anche char_id nel JSON
      body: JSON.stringify({ 
          item_id: itemId,
          char_id: characterId 
      })
    },
    onLogout
  );
};

export const assemblaOggetto = (hostId, modId, characterId, useAcademy = false, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/oggetti/assembla/', 
    {
      method: 'POST',
      body: JSON.stringify({ 
        host_id: hostId, 
        mod_id: modId,
        char_id: characterId,
        use_academy: useAcademy // Parametro nuovo
      })
    },
    onLogout
  );
};

export const smontaOggetto = (hostId, modId, characterId, useAcademy = false, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/oggetti/smonta/', 
    {
      method: 'POST',
      body: JSON.stringify({ 
        host_id: hostId, 
        mod_id: modId,
        char_id: characterId,
        use_academy: useAcademy
      })
    },
    onLogout
  );
};

// Se hai bisogno del crafting nel frontend in futuro:
export const craftOggettoFromInfusione = (infusioneId, targetId, qrCode, onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/oggetti/craft/',
    {
      method: 'POST',
      body: JSON.stringify({
        infusione_id: infusioneId,
        target_id: targetId,
        qr_code: qrCode
      })
    },
    onLogout
  );
};

export const startForging = (infusioneId, charId, slotTarget = null) => {
  return fetchAuthenticated(
    '/personaggi/api/crafting/avvia_forgiatura/',
    {
      method: 'POST',
      body: JSON.stringify({ 
        infusione_id: infusioneId, 
        char_id: charId,
        slot_target: slotTarget
      })
    }
  );
};

export const completeForging = (forgiaturaId, charId) => {
  return fetchAuthenticated(
    '/personaggi/api/crafting/completa_forgiatura/',
    {
      method: 'POST',
      body: JSON.stringify({ 
        forgiatura_id: forgiaturaId, 
        char_id: charId 
      })
    }
  );
};

export const getForgingQueue = (charId) => {
  return fetchAuthenticated(
    `/personaggi/api/crafting/coda_forgiatura/?char_id=${charId}`,
    { method: 'GET' }
  );
};

// --- API NEGOZIO (SHOP) ---

export const getShopItems = () => {
  return fetchAuthenticated(
    '/personaggi/api/negozio/listino/',
    { method: 'GET' }
  );
};

export const buyShopItem = (oggettoId, charId) => {
  return fetchAuthenticated(
    '/personaggi/api/negozio/acquista/',
    {
      method: 'POST',
      body: JSON.stringify({ 
        oggetto_id: oggettoId, 
        char_id: charId 
      })
    }
  );
};

/**
 * Valida la compatibilità e le competenze per un assemblaggio.
 */
export const validateAssembly = (charId, hostId, modId) => {
  return fetchAuthenticated(
    '/personaggi/api/assembly/validate/', 
    {
      method: 'POST',
      body: JSON.stringify({
        char_id: charId,
        host_id: hostId,
        mod_id: modId
      })
    }
  );
};

/**
 * Crea una richiesta di lavoro (Installazione o Rimozione).
 * @param {string} operationType - 'INST' (Default) o 'RIMO'
 */
export const createAssemblyRequest = (charId, hostId, modId, artisanName, offer, operationType = 'INST') => {
  return fetchAuthenticated(
    '/personaggi/api/richieste-assemblaggio/crea/', 
    {
      method: 'POST',
      body: JSON.stringify({
        committente_id: charId,
        host_id: hostId,
        comp_id: modId,
        artigiano_nome: artisanName,
        offerta: offer,
        tipo_operazione: operationType // <--- Passa il tipo al backend
      })
    }
  );
};

/**
 * Accetta una richiesta di assemblaggio (Lato Artigiano).
 */
export const acceptAssemblyRequest = (requestId) => {
  return fetchAuthenticated(
    `/personaggi/api/richieste-assemblaggio/${requestId}/accetta/`, 
    { method: 'POST' }
  );
};

/**
 * Rifiuta una richiesta di assemblaggio (Lato Artigiano).
 */
export const rejectAssemblyRequest = (requestId) => {
  return fetchAuthenticated(
    `/personaggi/api/richieste-assemblaggio/${requestId}/rifiuta/`, 
    { method: 'POST' }
  );
};

/**
 * Recupera le richieste di assemblaggio (inviate o ricevute).
 */
export const getAssemblyRequests = () => {
  return fetchAuthenticated(
    '/personaggi/api/richieste-assemblaggio/', 
    { method: 'GET' }
  );
};

// Aggiungi questa funzione per recuperare gli artigiani capaci
// Questa va bene per entrambi (Assemblaggio e Forgiatura)
export const getCapableArtisans = (charId, hostId, modId, infusioneId) => {
  return fetchAuthenticated('/personaggi/api/assembly/artisans/', {
      method: 'POST',
      body: JSON.stringify({ 
        char_id: charId, 
        host_id: hostId, 
        mod_id: modId, 
        infusione_id: infusioneId 
      })
  });
};

export const forgiaOggetto = (infusioneId, charId, useAcademy = false) => {
  return fetchAuthenticated('/personaggi/api/oggetti/forgia/', {
      method: 'POST',
      body: JSON.stringify({ 
        infusione_id: infusioneId, 
        char_id: charId, 
        use_academy: useAcademy 
      })
  });
};

export const createForgingRequest = (charId, infusioneId, artisanName, offer) => {
  return fetchAuthenticated('/personaggi/api/richieste-assemblaggio/crea/', {
      method: 'POST',
      body: JSON.stringify({
        committente_id: charId,
        infusione_id: infusioneId,
        artigiano_nome: artisanName,
        offerta: offer,
        tipo_operazione: 'FORG'
      })
  });
};

export const validateForging = (charId, infusioneId) => {
  return fetchAuthenticated('/personaggi/api/forging/validate/', {
      method: 'POST',
      body: JSON.stringify({ 
        char_id: charId, 
        infusione_id: infusioneId 
      })
  });
};

export const getClassiOggetto = () => {
  return fetchAuthenticated('/personaggi/api/classi_oggetto/', { method: 'GET' });
};

/**
 * Esegue l'installazione di un innesto da una forgiatura completata.
 * (Operazione "Fai da te" o "Accettazione diretta")
 */
export const installaInnesto = (forgiaturaId, slot, characterId, targetId = null) => {
  return fetchAuthenticated(
    '/personaggi/api/crafting/completa_forgiatura/', 
    {
      method: 'POST',
      body: JSON.stringify({ 
        forgiatura_id: forgiaturaId, 
        char_id: characterId, // Chi esegue l'azione (Forgiatore)
        slot_scelto: slot,
        target_id: targetId   // NUOVO: Chi riceve l'innesto (Destinatario)
      })
    }
  );
}

/**
 * Crea una richiesta di operazione chirurgica a un altro giocatore.
 */
export const richiediOperazioneChirurgica = (forgiaturaId, slot, medicoNome, offerta, characterId) => {
  return fetchAuthenticated(
    '/personaggi/api/richieste-assemblaggio/crea/', 
    {
      method: 'POST',
      body: JSON.stringify({
        committente_id: characterId,
        forgiatura_id: forgiaturaId,
        slot_destinazione: slot,
        artigiano_nome: medicoNome,
        offerta: offerta,
        tipo_operazione: 'GRAF' // Codice per Graft/Innesto
      })
    }
  );
};

export const richiediAssemblaggio = (data) => {
  return fetchAuthenticated(
    '/personaggi/api/richieste-assemblaggio/crea/', 
    {
      method: 'POST',
      body: JSON.stringify(data)
    }
  );
};

/**
 * Rifiuta una richiesta (Wrapper per coerenza di naming).
 */
export const rifiutaRichiestaAssemblaggio = (requestId) => {
  return fetchAuthenticated(
    `/personaggi/api/richieste-assemblaggio/${requestId}/rifiuta/`, 
    { method: 'POST' }
  );
};

/**
 * Aggiorna parzialmente i dati del personaggio (es. impostazioni UI).
 */
export const updatePersonaggioSettings = (charId, settingsData, onLogout) => {
  return fetchAuthenticated(
    `/personaggi/api/personaggi/${charId}/`, 
    {
      method: 'PATCH',
      body: JSON.stringify({ impostazioni_ui: settingsData })
    }, 
    onLogout
  );
};

// --- FUNZIONI CERIMONIALI ---

export const getAcquirableCerimoniali = (charId, onLogout) => {
    return fetchAuthenticated(
        `/personaggi/api/personaggio/me/cerimoniali_acquistabili/?char_id=${charId}`, 
        { method: 'GET' }, 
        onLogout
    );
}

// Modifica HP di un mostro in tempo reale
export const updateMostroHp = (mostroId, delta, onLogout) => {
  return fetchAuthenticated(
    `/plot/api/mostri-istanza/${mostroId}/modifica_hp/`,
    {
      method: 'POST',
      body: JSON.stringify({ delta })
    },
    onLogout
  );
};

// Associa un QR code scansionato a un oggetto "Vista" della quest
export const associaQrAVista = (vistaId, qrId, onLogout) => {
  return fetchAuthenticated(
    `/plot/api/viste-setup/${vistaId}/associa_qr/`,
    {
      method: 'POST',
      body: JSON.stringify({ qr_id: qrId })
    },
    onLogout
  );
};

// --- EVENTI ---
export const getEventi = (onLogout) => fetchAuthenticated('/plot/api/eventi/', { method: 'GET' }, onLogout);
export const createEvento = (data, onLogout) => fetchAuthenticated('/plot/api/eventi/', { method: 'POST', body: JSON.stringify(data) }, onLogout);
export const updateEvento = (id, data, onLogout) => fetchAuthenticated(`/plot/api/eventi/${id}/`, { method: 'PATCH', body: JSON.stringify(data) }, onLogout);
export const deleteEvento = (id, onLogout) => fetchAuthenticated(`/plot/api/eventi/${id}/`, { method: 'DELETE' }, onLogout);

// --- GIORNI ---
export const createGiorno = (data, onLogout) => fetchAuthenticated('/plot/api/giorni/', { method: 'POST', body: JSON.stringify(data) }, onLogout);
export const updateGiorno = (id, data, onLogout) => fetchAuthenticated(`/plot/api/giorni/${id}/`, { method: 'PATCH', body: JSON.stringify(data) }, onLogout);
export const deleteGiorno = (id, onLogout) => fetchAuthenticated(`/plot/api/giorni/${id}/`, { method: 'DELETE' }, onLogout);

// --- QUESTS ---
export const createQuest = (data, onLogout) => fetchAuthenticated('/plot/api/quests/', { method: 'POST', body: JSON.stringify(data) }, onLogout);
export const updateQuest = (id, data, onLogout) => fetchAuthenticated(`/plot/api/quests/${id}/`, { method: 'PATCH', body: JSON.stringify(data) }, onLogout);
export const deleteQuest = (id, onLogout) => fetchAuthenticated(`/plot/api/quests/${id}/`, { method: 'DELETE' }, onLogout);

// Recupera tutte le liste per i dropdown dell'editor
export const getRisorseEditor = (onLogout) => fetchAuthenticated('/plot/api/eventi/risorse_editor/', { method: 'GET' }, onLogout);

// Operazioni su PnG, Mostri e Viste
// export const addPngToQuest = (data, onLogout) => fetchAuthenticated('/plot/api/png-assegnati/', { method: 'POST', body: JSON.stringify(data) }, onLogout);
// export const addMostroToQuest = (data, onLogout) => fetchAuthenticated('/plot/api/mostri-istanza/', { method: 'POST', body: JSON.stringify(data) }, onLogout);
// export const addVistaToQuest = (data, onLogout) => fetchAuthenticated('/plot/api/viste-setup/', { method: 'POST', body: JSON.stringify(data) }, onLogout);

export const removePngFromQuest = (id, onLogout) => fetchAuthenticated(`/plot/api/png-assegnati/${id}/`, { method: 'DELETE' }, onLogout);
export const removeMostroFromQuest = (id, onLogout) => fetchAuthenticated(`/plot/api/mostri-istanza/${id}/`, { method: 'DELETE' }, onLogout);
export const removeVistaFromQuest = (id, onLogout) => fetchAuthenticated(`/plot/api/viste-setup/${id}/`, { method: 'DELETE' }, onLogout);

export const addPngToQuest = (questId, personaggioId, stafferId, onLogout) => {
    const payload = {
        quest: parseInt(questId),
        personaggio: parseInt(personaggioId),
        staffer: stafferId ? parseInt(stafferId) : null
    };
    return fetchAuthenticated('/plot/api/png-assegnati/', { method: 'POST', body: JSON.stringify(payload) }, onLogout);
};

// Correzione Mostri
export const addMostroToQuest = (questId, templateId, stafferId, onLogout) => {
    const payload = {
        quest: parseInt(questId),
        template: parseInt(templateId),
        staffer: stafferId ? parseInt(stafferId) : null
    };
    return fetchAuthenticated('/plot/api/mostri-istanza/', { method: 'POST', body: JSON.stringify(payload) }, onLogout);
};

// Correzione Viste: accetta l'oggetto vistaPayload
export const addVistaToQuest = (questId, data, onLogout) => {
    const payload = {
        quest: parseInt(questId),
        tipo: data.tipo,
        manifesto: data.manifesto ? parseInt(data.manifesto) : null,
        inventario: data.inventario ? parseInt(data.inventario) : null
    };
    return fetchAuthenticated('/plot/api/viste-setup/', { method: 'POST', body: JSON.stringify(payload) }, onLogout);
};

/** --- STRUMENTI MASTER --- **/

// Recupera la lista di tutte le statistiche definite nel sistema
export const getStatisticheList = (onLogout) => {
  return fetchAuthenticated('/personaggi/api/statistiche/', { method: 'GET' }, onLogout);
};

// --- INFUSIONI ---
export const staffGetInfusioni = (onLogout, params = {}) => {
  // Costruiamo la query string (es: ?page=1&search=pippo)
  const queryString = new URLSearchParams(params).toString();
  return fetchAuthenticated(`/personaggi/api/staff/infusioni/?${queryString}`, { method: 'GET' }, onLogout);
};

export const staffCreateInfusione = (data, onLogout) => 
  fetchAuthenticated('/personaggi/api/staff/infusioni/', { method: 'POST', body: JSON.stringify(data) }, onLogout);

export const staffUpdateInfusione = (id, data, onLogout) => 
  fetchAuthenticated(`/personaggi/api/staff/infusioni/${id}/`, { method: 'PATCH', body: JSON.stringify(data) }, onLogout);

export const staffDeleteInfusione = (id, onLogout) => 
  fetchAuthenticated(`/personaggi/api/staff/infusioni/${id}/`, { method: 'DELETE' }, onLogout);

// --- TESSITURE ---
export const staffGetTessiture = (onLogout, params = {}) => {
  // Costruiamo la query string (es: ?page=1&search=pippo)
  const queryString = new URLSearchParams(params).toString();
  return fetchAuthenticated(`/personaggi/api/staff/tessiture/?${queryString}`, { method: 'GET' }, onLogout);
};

export const staffCreateTessitura = (data, onLogout) => 
  fetchAuthenticated('/personaggi/api/staff/tessiture/', { method: 'POST', body: JSON.stringify(data) }, onLogout);

export const staffUpdateTessitura = (id, data, onLogout) => 
  fetchAuthenticated(`/personaggi/api/staff/tessiture/${id}/`, { method: 'PATCH', body: JSON.stringify(data) }, onLogout);

export const staffDeleteTessitura = (id, onLogout) => 
  fetchAuthenticated(`/personaggi/api/staff/tessiture/${id}/`, { method: 'DELETE' }, onLogout);

// --- CERIMONIALI ---
export const staffGetCerimoniali = (onLogout, params = {}) => {
  // Costruiamo la query string (es: ?page=1&search=pippo)
  const queryString = new URLSearchParams(params).toString();
  return fetchAuthenticated(`/personaggi/api/staff/cerimoniali/?${queryString}`, { method: 'GET' }, onLogout);
};

export const staffCreateCerimoniale = (data, onLogout) => 
  fetchAuthenticated('/personaggi/api/staff/cerimoniali/', { method: 'POST', body: JSON.stringify(data) }, onLogout);

export const staffUpdateCerimoniale = (id, data, onLogout) => 
  fetchAuthenticated(`/personaggi/api/staff/cerimoniali/${id}/`, { method: 'PATCH', body: JSON.stringify(data) }, onLogout);

export const staffDeleteCerimoniale = (id, onLogout) => 
  fetchAuthenticated(`/personaggi/api/staff/cerimoniali/${id}/`, { method: 'DELETE' }, onLogout);

// Gestione Oggetti (Istanze)
export const staffGetOggetti = (onLogout) => 
    fetchAuthenticated('/personaggi/api/staff/oggetti/', { method: 'GET' }, onLogout);

export const staffCreateOggetto = (data, onLogout) => 
    fetchAuthenticated('/personaggi/api/staff/oggetti/', { method: 'POST', body: JSON.stringify(data) }, onLogout);

export const staffUpdateOggetto = (id, data, onLogout) => 
    fetchAuthenticated(`/personaggi/api/staff/oggetti/${id}/`, { method: 'PUT', body: JSON.stringify(data) }, onLogout);

export const staffDeleteOggetto = (id, onLogout) => 
    fetchAuthenticated(`/personaggi/api/staff/oggetti/${id}/`, { method: 'DELETE' }, onLogout);

// Gestione Oggetti Base (Listino/Template)
export const staffGetOggettiBase = (onLogout) => 
    fetchAuthenticated('/personaggi/api/staff/oggetti-base/', { method: 'GET' }, onLogout);

export const staffCreateOggettoBase = (data, onLogout) => 
    fetchAuthenticated('/personaggi/api/staff/oggetti-base/', { method: 'POST', body: JSON.stringify(data) }, onLogout);

export const staffUpdateOggettoBase = (id, data, onLogout) => 
    fetchAuthenticated(`/personaggi/api/staff/oggetti-base/${id}/`, { method: 'PUT', body: JSON.stringify(data) }, onLogout);

export const staffDeleteOggettoBase = (id, onLogout) => 
    fetchAuthenticated(`/personaggi/api/staff/oggetti-base/${id}/`, { method: 'DELETE' }, onLogout);

// Utility
export const staffGetClassiOggetto = (onLogout) => 
    fetchAuthenticated('/personaggi/api/staff/classi-oggetto/', { method: 'GET' }, onLogout);

// Sezione Personaggi

/**
 * Recupera le tipologie di personaggio disponibili.
 * Tenta di scaricarle dal server. Se fallisce o l'endpoint non esiste,
 * usa i valori di fallback per non rompere l'interfaccia.
 */
export const getTipologiePersonaggio = async (onLogout) => {
    try {
        // Tenta la chiamata all'API reale
        // Assicurati che nel backend esista: router.register(r'tipologie', TipologiaPersonaggioViewSet)
        const data = await fetchAuthenticated('/personaggi/api/tipologiepersonaggio/', { method: 'GET' }, onLogout);
        return data;
    } catch (error) {
        console.warn("API Tipologie non raggiungibile, uso fallback locale:", error);
        
        // Fallback locale nel caso il backend non sia ancora pronto
        return [
            { id: 1, label: 'Standard (Giocatore)' },
            { id: 2, label: 'PnG (Personaggio Non Giocante)' }
        ];
    }
};

// --- CRUD PERSONAGGI (Nuovo Endpoint) ---

export const getPersonaggiEditList = (onLogout, viewAll = false) => {
    // Nota: gestione-personaggi restituisce già la lista filtrata o completa in base all'utente/staff
    // Se vuoi forzare viewAll lato server potresti dover gestire i permessi, 
    // ma il get_queryset sopra lo fa già in automatico basandosi su is_staff.
    return fetchAuthenticated('/personaggi/api/gestione-personaggi/', { method: 'GET' }, onLogout);
};

export const createPersonaggio = (data, onLogout) => {
    return fetchAuthenticated('/personaggi/api/gestione-personaggi/', {
        method: 'POST',
        body: JSON.stringify(data)
    }, onLogout);
};

export const updatePersonaggio = (id, data, onLogout) => {
    return fetchAuthenticated(`/personaggi/api/gestione-personaggi/${id}/`, {
        method: 'PATCH',
        body: JSON.stringify(data)
    }, onLogout);
};

// --- STAFF RESOURCES ---
export const staffAddResources = (charId, tipo, amount, reason, onLogout) => {
    return fetchAuthenticated(`/personaggi/api/gestione-personaggi/${charId}/add_resources/`, {
        method: 'POST',
        body: JSON.stringify({ tipo, amount, reason })
    }, onLogout);
};

/**
 * Recupera le proposte tecniche in stato VALUTAZIONE per lo staff.
 */
export const staffGetProposteInValutazione = (onLogout) => {
  return fetchAuthenticated(
    '/personaggi/api/staff/proposte/valutazione/', 
    { method: 'GET' }, 
    onLogout
  );
};

/**
 * Rifiuta una proposta tecnica, riportandola in BOZZA e inviando un messaggio.
 */
export const staffRifiutaProposta = (propostaId, noteStaff, onLogout) => {
  return fetchAuthenticated(
    `/personaggi/api/staff/proposte/${propostaId}/rifiuta/`,
    {
      method: 'POST',
      body: JSON.stringify({ note_staff: noteStaff })
    },
    onLogout
  );
};

/**
 * Approva una proposta: crea la tecnica finale, scala i crediti e aggiorna lo stato.
 * 'finalData' contiene i dati definitivi compilati tramite l'editor (Infusione/Tessitura/Cerimoniale).
 */
export const staffApprovaProposta = (propostaId, finalData, onLogout) => {
  return fetchAuthenticated(
    `/personaggi/api/staff/proposta/${propostaId}/approva/`,
    {
      method: 'POST',
      body: JSON.stringify(finalData)
    },
    onLogout
  );
};

// --- GESTIONE MOSTRI (TEMPLATE) ---

export const staffGetMostriTemplates = (onLogout) => {
    return fetchAuthenticated('/plot/api/staff/mostri-templates/', { method: 'GET' }, onLogout);
};

export const staffCreateMostroTemplate = (data, onLogout) => {
    return fetchAuthenticated('/plot/api/staff/mostri-templates/', { 
        method: 'POST', 
        body: JSON.stringify(data) 
    }, onLogout);
};

export const staffUpdateMostroTemplate = (id, data, onLogout) => {
    return fetchAuthenticated(`/plot/api/staff/mostri-templates/${id}/`, { 
        method: 'PUT', // Usa PUT per sostituire l'intero oggetto inclusi gli attacchi
        body: JSON.stringify(data) 
    }, onLogout);
};

export const staffDeleteMostroTemplate = (id, onLogout) => {
    return fetchAuthenticated(`/plot/api/staff/mostri-templates/${id}/`, { method: 'DELETE' }, onLogout);
};

// --- GESTIONE ABILITÀ ---

export const staffGetAbilitaList = (onLogout) => {
    return fetchAuthenticated('/personaggi/api/staff/abilita/', { method: 'GET' }, onLogout);
};

export const staffCreateAbilita = (data, onLogout) => {
    return fetchAuthenticated('/personaggi/api/staff/abilita/', {
        method: 'POST',
        body: JSON.stringify(data)
    }, onLogout);
};

export const staffUpdateAbilita = (id, data, onLogout) => {
    return fetchAuthenticated(`/personaggi/api/staff/abilita/${id}/`, {
        method: 'PATCH',
        body: JSON.stringify(data)
    }, onLogout);
};

export const staffDeleteAbilita = (id, onLogout) => {
    return fetchAuthenticated(`/personaggi/api/staff/abilita/${id}/`, { method: 'DELETE' }, onLogout);
};

// Utile per l'editor: serve la lista di tutte le abilità per i prerequisiti
export const getAbilitaOptions = (onLogout) => {
    return fetchAuthenticated('/personaggi/api/abilita/', { method: 'GET' }, onLogout);
};

export const getTiersList = (onLogout) => {
    return fetchAuthenticated('/personaggi/api/tier/', { method: 'GET' }, onLogout);
};

export const staffCreateOffGame = async (data, onLogout) => {
    return await fetchAuthenticated('/plot/api/staff/staff-offgame/', 'POST', data, onLogout);
};

export const staffDeleteOffGame = async (id, onLogout) => {
    return await fetchAuthenticated(`/plot/api/staff/staff-offgame/${id}/`, 'DELETE', null, onLogout);
};

// src/api.js - Aggiungi queste esportazioni
export const addFaseToQuest = (payload, onLogout) => fetchAuthenticated('/plot/api/fasi/', { method: 'POST', body: JSON.stringify(payload) }, onLogout);
export const removeFaseFromQuest = (id, onLogout) => fetchAuthenticated(`/plot/api/fasi/${id}/`, { method: 'DELETE' }, onLogout);
export const addTaskToFase = (payload, onLogout) => fetchAuthenticated('/plot/api/tasks/', { method: 'POST', body: JSON.stringify(payload) }, onLogout);
export const removeTaskFromFase = (id, onLogout) => fetchAuthenticated(`/plot/api/tasks/${id}/`, { method: 'DELETE' }, onLogout);
export const updateFase = (id, data, onLogout) => fetchAuthenticated(`/plot/api/fasi/${id}/`, { method: 'PATCH', body: JSON.stringify(data) }, onLogout);



export const getWikiMenu = () => {
  // Nota: Assicurati che l'URL coincida con quello definito in urls.py
  return fetchPublic('/plot/api/public/wiki-menu/');
};

export const getWikiPage = (slug) => {
  return fetchPublic(`/plot/api/public/wiki-page/${slug}/`);
};

export const getWikiTable = (id) => {
  return fetchPublic(`/plot/api/public/wiki-tabelle/${id}/`);
};

export const getWikiAura = (id) => {
  return fetchPublic(`/plot/api/public/wiki-aure/${id}/`);
};

// --- AGGIUNTA PER WIDGET TIER ---
export const getWikiTier = (id) => {
  return fetchPublic(`/plot/api/public/wiki-tiers/${id}/`);
};

// Helper per avere la lista di tutti i Tier (per l'editor del Master)
export const getWikiTierList = () => {
  return fetchPublic('/plot/api/public/wiki-tiers/');
};

// Crea una nuova pagina (Staff) - Supporta FormData per immagini
export const createWikiPage = (formData, onLogout) => {
  return fetchAuthenticated('/plot/api/staff/pagine-regolamento/', {
    method: 'POST',
    body: formData // fetchAuthenticated gestisce automaticamente il Content-Type per FormData
  }, onLogout);
};

// Aggiorna una pagina esistente (Staff)
export const updateWikiPage = (id, formData, onLogout) => {
  return fetchAuthenticated(`/plot/api/staff/pagine-regolamento/${id}/`, {
    method: 'PUT',
    body: formData
  }, onLogout);
};

// --- GESTIONE TABELLE (TIER) ---

export const getTiers = (onLogout) => {
    return fetchAuthenticated('/personaggi/api/staff/tiers/', { method: 'GET' }, onLogout);
};

export const createTier = (data, onLogout) => {
    return fetchAuthenticated('/personaggi/api/staff/tiers/', {
        method: 'POST',
        body: JSON.stringify(data)
    }, onLogout);
};

export const updateTier = (id, data, onLogout) => {
    return fetchAuthenticated(`/personaggi/api/staff/tiers/${id}/`, {
        method: 'PATCH',
        body: JSON.stringify(data)
    }, onLogout);
};

export const deleteTier = (id, onLogout) => {
    return fetchAuthenticated(`/personaggi/api/staff/tiers/${id}/`, {
        method: 'DELETE'
    }, onLogout);
};

export const getAllAbilitaSimple = (onLogout) => {
    return fetchAuthenticated('/personaggi/api/staff/tiers/all_abilita/', { method: 'GET' }, onLogout);
};

export const updateTierAbilita = (tierId, abilitaList, onLogout) => {
    // abilitaList deve essere array di { abilita_id, ordine }
    return fetchAuthenticated(`/personaggi/api/staff/tiers/${tierId}/update_abilita_list/`, {
        method: 'POST',
        body: JSON.stringify({ abilita_list: abilitaList })
    }, onLogout);
};

==================================================
FILE: src\App.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
// Importiamo sia il Provider "vero" che il Context "nudo"
import { CharacterProvider, CharacterContext } from './components/CharacterContext';
import LoginPage from './components/LoginPage';

// Layouts
import AppLayout from './layouts/AppLayout';
import PublicLayout from './layouts/PublicLayout';

// Pages
import WikiPage from './pages/WikiPage';

export default function App() {
  const [token, setToken] = useState(localStorage.getItem('kor35_token'));
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const storedToken = localStorage.getItem('kor35_token');
    if (storedToken) {
      setToken(storedToken);
    }
    setIsLoading(false);
  }, []);

  const handleLoginSuccess = (newToken) => {
    localStorage.setItem('kor35_token', newToken);
    setToken(newToken);
  };

  const handleLogout = () => {
    localStorage.removeItem('kor35_token');
    localStorage.removeItem('kor35_is_staff');
    localStorage.removeItem('kor35_is_master');
    localStorage.removeItem('kor35_last_char_id');
    setToken(null);
    window.location.href = '/login'; 
  };

  if (isLoading) {
    return <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white">Caricamento...</div>;
  }

  // --- CORREZIONE CHIAVE ---
  // Se c'è il token, usiamo il Provider VERO (che carica dati dal server).
  // Se NON c'è, usiamo un Provider FINTO (che dà valori nulli sicuri).
  const SafeProvider = ({ children }) => {
    if (token) {
      return (
        <CharacterProvider onLogout={handleLogout}>
          {children}
        </CharacterProvider>
      );
    } else {
      // Context per Ospiti: tutto spento/falso
      const guestValue = {
        isStaff: false,
        isMaster: false,
        character: null,
        notifiche: [],
        punteggiList: [], // Evita crash se qualche componente cerca liste
        personaggiList: [],
        isLoading: false
      };
      
      return (
        <CharacterContext.Provider value={guestValue}>
          {children}
        </CharacterContext.Provider>
      );
    }
  };

  return (
    <BrowserRouter>
      <SafeProvider>
        <Routes>
          {/* --- ROTTE PUBBLICHE --- */}
          <Route path="/" element={<PublicLayout token={token} />}>
            <Route index element={<WikiPage slug="home" />} />
            <Route path="regolamento/:slug" element={<WikiPage />} />
            <Route 
              path="login" 
              element={
                token ? <Navigate to="/app" replace /> : <LoginPage onLogin={handleLoginSuccess} />
              } 
            />
          </Route>

          {/* --- ROTTE APP (PROTETTE) --- */}
          <Route 
            path="/app/*" 
            element={
              token ? (
                <AppLayout token={token} onLogout={handleLogout} />
              ) : (
                <Navigate to="/login" replace />
              )
            } 
          />
        </Routes>
      </SafeProvider>
    </BrowserRouter>
  );
}

==================================================
FILE: src\index.css
==================================================
/* Importa i layer base di Tailwind */
@import "tailwindcss";

/* Stili globali aggiuntivi */
html, body, #root {
  height: 100%;
  overflow: hidden;
  margin: 0;
  padding: 0;
  background-color: #111827; /* bg-gray-900 */
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  color: white;
}

/* Assicura che l'app React prenda tutto lo spazio */
.kor-35-app, .kor-35-app > div {
  height: 100%;
}

.ql-editor-view p { margin-bottom: 0.5rem; }
.ql-editor-view ul { list-style-type: disc; margin-left: 1.5rem; }
.ql-editor-view ol { list-style-type: decimal; margin-left: 1.5rem; }
.ql-editor-view h1 { font-size: 1.5rem; font-weight: bold; }
.ql-editor-view h2 { font-size: 1.25rem; font-weight: bold; }

==================================================
FILE: src\main.jsx
==================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

// Crea il client. Configura cache e refetch automatici.
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // I dati sono "freschi" per 5 minuti
      refetchOnWindowFocus: false, // Evita refetch continuo se cambi tab browser
      retry: 1,
    },
  },
})

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>,
)

==================================================
FILE: src\sw.js
==================================================
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';

// --- FORZA AGGIORNAMENTO ---
// Dice al Service Worker di attivarsi subito senza aspettare la chiusura dell'app
self.skipWaiting();
// Dice al Service Worker di prendere il controllo immediato di tutte le pagine aperte
clientsClaim();

// 1. Gestione Cache PWA standard
cleanupOutdatedCaches();
precacheAndRoute(self.__WB_MANIFEST);

// 2. Gestione Evento PUSH (Notifica dal server)
self.addEventListener('push', function(event) {
  const eventData = event.data ? event.data.json() : {};
  
  const title = eventData.head || 'KOR-35';
  const options = {
    body: eventData.body || 'Nuovo messaggio ricevuto.',
    icon: '/pwa-192x192.png',
    badge: '/pwa-192x192.png',
    vibrate: [100, 50, 100],
    data: { 
        url: eventData.url || '/' 
    }
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// 3. Gestione Click sulla Notifica (Apre l'app)
self.addEventListener('notificationclick', function(event) {
  event.notification.close();
  // Apre la finestra relativa alla URL
  event.waitUntil(
    clients.openWindow(event.notification.data.url)
  );
});

==================================================
FILE: src\components\AbilitaDetailModal.jsx
==================================================
import React from 'react';
import { X } from 'lucide-react';
import { useCharacter } from './CharacterContext';
import PunteggioDisplay from './PunteggioDisplay.jsx';

const AbilitaDetailModal = ({ skill, onClose }) => {
  if (!skill) return null;

  const { punteggiList } = useCharacter();
  
  const caratteristicaPunteggio = skill.caratteristica ? punteggiList.find(
    p => p.id === skill.caratteristica.id
  ) : null;

  const costoPC = skill.costo_pc_calc !== undefined ? skill.costo_pc_calc : skill.costo_pc;
  const costoCrediti = skill.costo_crediti_calc !== undefined ? skill.costo_crediti_calc : skill.costo_crediti;
  const isScontato = skill.costo_crediti_calc !== undefined && 
                     skill.costo_crediti_calc < skill.costo_crediti;
  
  const showCosti = (costoPC !== undefined && costoPC > 0) || (costoCrediti !== undefined && costoCrediti > 0);
  
  // --- Logica per "Modifiche ai punteggi" ---
  const tipiConsentiti = ['CA', 'ST', 'AU']; // Caratteristica, Statistica, Aura
  
  const punteggiModificati = (skill.punteggi_assegnati || [])
    .map(link => {
        const punteggio = punteggiList.find(p => p.id === link.punteggio.id);
        if (punteggio && tipiConsentiti.includes(punteggio.tipo)) {
          return { ...link, punteggio }; 
        }
        return null;
    })
    // CORREZIONE 1: Filtra i valori nulli E quelli con modificatore 0
    .filter(item => item !== null && item.valore !== 0); 

  const statisticheModificate = (skill.statistiche_modificate || [])
    .map(link => {
        const punteggio = punteggiList.find(p => p.id === link.statistica.id);
        if (punteggio) {
          return { ...link, punteggio };
        }
        return null;
    })
    // CORREZIONE 1: Filtra i valori nulli E quelli con modificatore 0
    .filter(item => item !== null && item.valore !== 0);
    
  const showModifiche = punteggiModificati.length > 0 || statisticheModificate.length > 0;
  // --- Fine Logica ---

  return (
    <div 
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75"
      onClick={onClose}
    >
      <div 
        className="relative w-full max-w-lg p-6 mx-4 bg-gray-800 rounded-lg shadow-xl"
        onClick={(e) => e.stopPropagation()} 
      >
        <button 
          onClick={onClose}
          className="absolute top-4 right-4 text-gray-400 hover:text-white"
        >
          <X size={24} />
        </button>
        
        {caratteristicaPunteggio && (
          <div className="absolute top-4 right-16">
            <PunteggioDisplay
              punteggio={caratteristicaPunteggio}
              displayText="none"
              iconType="inv_circle"
            />
          </div>
        )}

        <h2 className="text-2xl font-bold text-indigo-400 mb-4 pr-16">
          {skill.nome}
        </h2>
        
        {skill.descrizione ? (
          <div
            className="text-gray-300 mb-4 prose prose-invert" 
            dangerouslySetInnerHTML={{ __html: skill.descrizione }}
          />
        ) : (
          <p className="text-gray-300 mb-4">
            <em>Nessuna descrizione.</em>
          </p>
        )}

        {showCosti && (
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-gray-200">Costi</h3>
            {costoPC > 0 && (
              <p className="text-gray-400">
                {costoPC} Punti Caratteristica
              </p>
            )}
            {costoCrediti > 0 && (
              <p className="text-gray-400">
                {isScontato ? (
                  <>
                    <del className="text-red-400">{skill.costo_crediti}</del>
                    <span className="text-green-400 ml-1">{costoCrediti}</span>
                  </>
                ) : (
                  <span>{costoCrediti}</span>
                )} Crediti
              </p>
            )}
          </div>
        )}

        {/* --- NUOVO BLOCCO: MODIFICHE AI PUNTEGGI --- */}
        {showModifiche && (
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-gray-200">Modifiche ai punteggi</h3>
            <div className="flex flex-wrap gap-2 mt-2">
              
              {statisticheModificate.map(link => (
                <PunteggioDisplay
                  key={`stat-${link.punteggio.id}`}
                  punteggio={link.punteggio}
                  // CORREZIONE 2: Aggiunto uno spazio iniziale
                  value={link.tipo_modificatore === 'ADD' ? 
                         (link.valore > 0 ? ` +${link.valore}` : ` ${link.valore}`) : 
                         ` x${link.valore}`}
                  displayText="name"
                  iconType="inv_circle"
                />
              ))}
              
              {punteggiModificati.map(link => (
                <PunteggioDisplay
                  key={`punt-${link.punteggio.id}`}
                  punteggio={link.punteggio}
                  // CORREZIONE 2: Aggiunto uno spazio iniziale
                  value={link.valore > 0 ? ` +${link.valore}` : ` ${link.valore}`}
                  displayText="name"
                  iconType="inv_circle"
                />
              ))}
              
            </div>
          </div>
        )}
        {/* --- FINE NUOVO BLOCCO --- */}


        {skill.requisiti && skill.requisiti.length > 0 && (
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-gray-200">Requisiti</h3>
            <ul className="list-disc list-inside text-gray-400">
              {skill.requisiti.map(req => (
                <li key={req.requisito.nome}>
                  {req.requisito.nome}: {req.valore}
                </li>
              ))}
            </ul>
          </div>
        )}
        
        {skill.prerequisiti && skill.prerequisiti.length > 0 && (
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-gray-200">Prerequisiti</h3>
            <ul className="list-disc list-inside text-gray-400">
              {skill.prerequisiti.map(pre => (
                <li key={pre.prerequisito.id}>
                  {pre.prerequisito.nome}
                </li>
              ))}
            </ul>
          </div>
        )}

      </div>
    </div>
  );
};

export default AbilitaDetailModal;

==================================================
FILE: src\components\AbilitaTab.jsx
==================================================
import React, { useState, Fragment } from 'react';
import { Tab } from '@headlessui/react';
import { useCharacter } from './CharacterContext';
import { Loader2, ShoppingCart, Info, CheckCircle2, PlusCircle } from 'lucide-react'; 
import AbilitaDetailModal from './AbilitaDetailModal.jsx';
import { acquireAbilita } from '../api.js';
import GenericGroupedList from './GenericGroupedList';
import PunteggioDisplay from './PunteggioDisplay';     
import IconaPunteggio from './IconaPunteggio';         

function classNames(...classes) {
  return classes.filter(Boolean).join(' ');
}

const AbilitaTab = ({ onLogout }) => {
  const {
    selectedCharacterData: char,
    selectedCharacterId, 
    acquirableSkills,     
    isLoadingAcquirable,  
    isLoadingDetail,
    refreshCharacterData,
    punteggiList 
  } = useCharacter();
  
  const [modalSkill, setModalSkill] = useState(null);
  const [isAcquiring, setIsAcquiring] = useState(null);

  const handleOpenModal = (skill) => setModalSkill(skill);

  const handleAcquire = async (skill, e) => {
    e.stopPropagation(); 
    if (isAcquiring || !selectedCharacterId) return;
    
    const pcCostString = skill.costo_pc_calc > 0 ? `${skill.costo_pc_calc} PC` : '';
    const creditCostString = skill.costo_crediti_calc > 0 ? `${skill.costo_crediti_calc} Crediti` : '';
    const joiner = pcCostString && creditCostString ? ' e ' : '';
    
    const confirmMessage = `Sei sicuro di voler acquisire "${skill.nome}" per ${pcCostString}${joiner}${creditCostString}?`;
    
    if (!window.confirm(confirmMessage)) {
      return;
    }
    
    setIsAcquiring(skill.id);
    try {
      await acquireAbilita(skill.id, selectedCharacterId, onLogout);
      await refreshCharacterData(); 
    } catch (error) {
      console.error("Errore acquisto:", error);
      alert(`Errore durante l'acquisto: ${error.message}`);
    } finally {
      setIsAcquiring(null);
    }
  };

  const possessedSkills = char?.abilita_possedute || [];

  // --- FILTRO MODIFICA: Rimuovo i tratti speciali dalla lista acquistabili ---
  // Questi verranno gestiti tramite il modale in PunteggioDisplay
  const filteredAcquirableSkills = acquirableSkills 
    ? acquirableSkills.filter(skill => !skill.is_tratto_aura) 
    : [];
  // --------------------------------------------------------------------------

  if (isLoadingAcquirable || isLoadingDetail || !char) {
    return (
      <div className="flex justify-center items-center h-64">
        <Loader2 className="animate-spin text-indigo-500" size={48} />
      </div>
    );
  }

  // --- RENDERERS ---

  const renderGroupHeader = (group) => {
    const fakePunteggio = {
        nome: group.name,
        colore: group.color,
        icona_url: group.icon
    };

    return (
        <PunteggioDisplay 
            punteggio={fakePunteggio}
            value={group.items.length}
            displayText="name"
            iconType="inv_circle"
            size="s"
            className="rounded-b-none"
        />
    );
  };

  const renderPossessedItem = (skill) => {
    const iconUrl = skill.caratteristica?.icona_url;
    const iconColor = skill.caratteristica?.colore;

    return (
      <li className="flex justify-between items-center py-2 px-2 hover:bg-gray-700/50 transition-colors rounded-sm border-b border-gray-700/50 last:border-0">
        <div 
            className="flex items-center gap-3 cursor-pointer grow" 
            onClick={() => handleOpenModal(skill)}
        >
            <div className="shrink-0 mt-0.5">
                <IconaPunteggio 
                    url={iconUrl}
                    color={iconColor}
                    mode="cerchio_inv"
                    size="xs"
                />
            </div>
            <span className="font-bold text-gray-200 text-base">{skill.nome}</span>
        </div>
        <button
            onClick={() => handleOpenModal(skill)}
            className="p-2 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full transition-colors ml-2"
            title="Dettagli"
        >
            <Info size={18} />
        </button>
      </li>
    );
  };

  const renderAcquirableItem = (skill) => {
    const canAffordPC = char.punti_caratteristica >= skill.costo_pc_calc;
    const canAffordCrediti = char.crediti >= skill.costo_crediti_calc;
    const canAfford = canAffordPC && canAffordCrediti;
    const isDiscounted = skill.costo_crediti > skill.costo_crediti_calc;
    
    const iconUrl = skill.caratteristica?.icona_url;
    const iconColor = skill.caratteristica?.colore;

    return (
      <li className="flex flex-col sm:flex-row sm:items-center justify-between py-3 px-2 hover:bg-gray-700/50 transition-colors rounded-sm border-b border-gray-700/50 last:border-0 gap-2">
        
        {/* Parte Sinistra */}
        <div 
            className="flex items-center gap-3 cursor-pointer grow"
            onClick={() => handleOpenModal(skill)}
        >
            <div className="shrink-0 mt-0.5">
                <IconaPunteggio 
                    url={iconUrl}
                    color={iconColor}
                    mode="cerchio_inv"
                    size="xs"
                />
            </div>
            <div className="flex flex-col">
                <span className="font-bold text-gray-200 text-base">{skill.nome}</span>
                <div className="text-xs text-gray-400 flex gap-2 mt-0.5 sm:hidden">
                    {skill.costo_pc_calc > 0 && (
                        <span className={canAffordPC ? "text-blue-300" : "text-red-400"}>
                            {skill.costo_pc_calc} PC
                        </span>
                    )}
                    {skill.costo_crediti_calc > 0 && (
                        <span className={canAffordCrediti ? "text-yellow-300" : "text-red-400"}>
                            {skill.costo_crediti_calc} CR
                        </span>
                    )}
                </div>
            </div>
        </div>

        {/* Parte Destra */}
        <div className="flex items-center justify-end gap-3 w-full sm:w-auto">
            <div className="hidden sm:flex flex-col items-end text-xs font-mono mr-1">
                 {skill.costo_pc_calc > 0 && (
                     <span className={canAffordPC ? "text-blue-300" : "text-red-400 font-bold"}>
                        {skill.costo_pc_calc} PC
                     </span>
                 )}

                 {skill.costo_crediti_calc > 0 && (
                     isDiscounted ? (
                        <div className="flex flex-col items-end leading-none mt-1">
                            <span className="text-[10px] text-red-500 line-through decoration-red-500 opacity-80">
                                {skill.costo_crediti}
                            </span>
                            <span className="text-green-400 font-bold">
                                {skill.costo_crediti_calc} CR
                            </span>
                        </div>
                     ) : (
                        <span className={canAffordCrediti ? "text-yellow-300" : "text-red-400 font-bold"}>
                            {skill.costo_crediti_calc} CR
                        </span>
                     )
                 )}
            </div>

            <button
              onClick={(e) => handleAcquire(skill, e)}
              disabled={!canAfford || isAcquiring === skill.id}
              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-bold transition-all shadow-md ml-auto sm:ml-0 ${
                !canAfford 
                  ? 'bg-gray-700 text-gray-500 cursor-not-allowed opacity-50' 
                  : 'bg-indigo-600 hover:bg-indigo-500 text-white hover:shadow-indigo-500/20'
              }`}
            >
              {isAcquiring === skill.id ? (
                <Loader2 className="animate-spin" size={16} />
              ) : (
                <>
                    <ShoppingCart size={16} />
                    <span className="hidden sm:inline">Acquista</span>
                </>
              )}
            </button>
            
            <button
                onClick={(e) => { e.stopPropagation(); handleOpenModal(skill); }}
                className="p-2 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full transition-colors"
            >
                <Info size={18} />
            </button>
        </div>
      </li>
    );
  };

  // --- DEFINIZIONE DELLE DUE LISTE ---
  
  const PossessedListComponent = (
    <GenericGroupedList 
      items={possessedSkills} 
      groupByKey="caratteristica"
      orderKey="ordine"
      titleKey="nome"
      colorKey="colore"
      iconKey="icona_url"
      renderItem={renderPossessedItem}
      renderHeader={renderGroupHeader}
      compact={false}
      itemSortFn={(a, b) => a.nome.localeCompare(b.nome)}
    />
  );

  const AcquirableListComponent = (
    <GenericGroupedList 
      // USO LA LISTA FILTRATA QUI
      items={filteredAcquirableSkills} 
      groupByKey="caratteristica"
      orderKey="ordine"
      titleKey="nome"
      colorKey="colore"
      iconKey="icona_url"
      renderItem={renderAcquirableItem}
      renderHeader={renderGroupHeader}
      compact={false}
      itemSortFn={(a, b) => a.nome.localeCompare(b.nome)}
    />
  );

  return (
    <>
      <div className="w-full p-4 max-w-6xl mx-auto pb-24">
        
        {/* Riepilogo Valute (Comune) */}
        <div className="mb-6 flex justify-between items-center bg-gray-800 p-3 rounded-lg border border-gray-700 shadow-sm max-w-3xl mx-auto">
            <div className="text-sm text-gray-400">Disponibilità:</div>
            <div className="flex gap-4">
                <div className="flex items-center gap-1 text-blue-400 font-bold">
                    <span>{char.punti_caratteristica}</span> <span className="text-xs font-normal text-gray-400">PC</span>
                </div>
                <div className="flex items-center gap-1 text-yellow-400 font-bold">
                    <span>{char.crediti}</span> <span className="text-xs font-normal text-gray-400">CR</span>
                </div>
            </div>
        </div>

        {/* --- LAYOUT MOBILE: TABS --- */}
        <div className="md:hidden">
            <Tab.Group>
            <Tab.List className="flex space-x-1 rounded-xl bg-gray-800/80 p-1 mb-4 shadow-inner">
                <Tab as={Fragment}>
                {({ selected }) => (
                    <button className={classNames(
                        'w-full rounded-lg py-2.5 text-sm font-medium leading-5 transition-all',
                        'focus:outline-none focus:ring-2 ring-offset-2 ring-offset-indigo-400 ring-white ring-opacity-60',
                        selected 
                            ? 'bg-indigo-600 text-white shadow-lg scale-[1.02]' 
                            : 'text-gray-400 hover:bg-gray-700/50 hover:text-white'
                    )}>
                    Possedute <span className="ml-1 opacity-70 text-xs">({possessedSkills.length})</span>
                    </button>
                )}
                </Tab>
                <Tab as={Fragment}>
                {({ selected }) => (
                    <button className={classNames(
                        'w-full rounded-lg py-2.5 text-sm font-medium leading-5 transition-all',
                        'focus:outline-none focus:ring-2 ring-offset-2 ring-offset-indigo-400 ring-white ring-opacity-60',
                        selected 
                            ? 'bg-indigo-600 text-white shadow-lg scale-[1.02]' 
                            : 'text-gray-400 hover:bg-gray-700/50 hover:text-white'
                    )}>
                    Nuove <span className="ml-1 opacity-70 text-xs">({filteredAcquirableSkills.length})</span>
                    </button>
                )}
                </Tab>
            </Tab.List>
            
            <Tab.Panels>
                <Tab.Panel className="focus:outline-none animate-fadeIn">
                    {PossessedListComponent}
                </Tab.Panel>
                <Tab.Panel className="focus:outline-none animate-fadeIn">
                    {AcquirableListComponent}
                </Tab.Panel>
            </Tab.Panels>
            </Tab.Group>
        </div>

        {/* --- LAYOUT DESKTOP: DUE COLONNE --- */}
        <div className="hidden md:grid grid-cols-2 gap-6">
            
            <div>
                <div className="flex items-center gap-2 mb-4 pb-2 border-b border-gray-700">
                    <CheckCircle2 className="w-6 h-6 text-green-500" />
                    <h2 className="text-xl font-bold text-white">
                        Abilità Possedute 
                        <span className="ml-2 text-sm font-normal text-gray-400">({possessedSkills.length})</span>
                    </h2>
                </div>
                {PossessedListComponent}
            </div>

            <div>
                <div className="flex items-center gap-2 mb-4 pb-2 border-b border-gray-700">
                    <PlusCircle className="w-6 h-6 text-indigo-500" />
                    <h2 className="text-xl font-bold text-white">
                        Nuove Abilità
                        <span className="ml-2 text-sm font-normal text-gray-400">({filteredAcquirableSkills.length})</span>
                    </h2>
                </div>
                {AcquirableListComponent}
            </div>

        </div>

      </div>
      
      {modalSkill && (
        <AbilitaDetailModal
          skill={modalSkill}
          onClose={() => setModalSkill(null)}
          onLogout={onLogout}
          onPurchaseSuccess={() => {
             setModalSkill(null);
             refreshCharacterData();
          }}
        />
      )}
    </>
  );
};

export default AbilitaTab;

==================================================
FILE: src\components\ActiveItemWidget.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { Activity, Battery, Clock, RefreshCw } from 'lucide-react';
import { useCharacter } from './CharacterContext';
import { useOptimisticUseItem, useOptimisticRecharge } from '../hooks/useGameData';

const ActiveItemWidget = ({ item, onUpdate }) => {
    const useItemMutation = useOptimisticUseItem();
    const rechargeMutation = useOptimisticRecharge();
    const { selectedCharacterData } = useCharacter(); 

    const [timeLeft, setTimeLeft] = useState(0);

    // Gestione Timer Intelligente
    useEffect(() => {
        if (!item.data_fine_attivazione) {
            setTimeLeft(0);
            return;
        }

        const calculateTimeLeft = () => {
            const now = new Date().getTime();
            const end = new Date(item.data_fine_attivazione).getTime();
            const diff = Math.floor((end - now) / 1000);
            return diff > 0 ? diff : 0;
        };

        setTimeLeft(calculateTimeLeft());

        const interval = setInterval(() => {
            const remaining = calculateTimeLeft();
            setTimeLeft(remaining);
            if (remaining <= 0) clearInterval(interval);
        }, 1000);

        return () => clearInterval(interval);
    }, [item.data_fine_attivazione]);

    const formatTimer = (totalSeconds) => {
        if (!totalSeconds) return "Scaduto";
        const h = Math.floor(totalSeconds / 3600);
        const m = Math.floor((totalSeconds % 3600) / 60);
        const s = totalSeconds % 60;
        
        if (h > 0) return `${h}h ${m}m ${s}s`;
        return `${m}:${s.toString().padStart(2, '0')}`;
    };

    const handleUseCharge = () => {
        useItemMutation.mutate({ 
            oggetto_id: item.id, 
            charId: selectedCharacterData.id,
            durata_totale: item.durata_totale || 0,
            is_aura_zero_off: item.spegne_a_zero_cariche || false
        }, {
            // CORREZIONE QUI: Chiamiamo onUpdate se l'operazione ha successo
            onSuccess: () => {
                if (onUpdate) onUpdate();
            }
        });
    };

    const handleRecharge = () => {
        if (window.confirm(`Ricaricare ${item.nome}?\nCosto: ${item.costo_ricarica} CR\nMetodo: ${item.testo_ricarica}`)) {
            rechargeMutation.mutate({ 
                oggetto_id: item.id, 
                charId: selectedCharacterData.id 
            }, {
                // CORREZIONE QUI: Chiamiamo onUpdate anche per la ricarica
                onSuccess: () => {
                    if (onUpdate) onUpdate();
                }
            });
        }
    };

    // Logica di stato visuale
    const isWorking = timeLeft > 0;
    const hasCharges = item.cariche_attuali > 0;
    const maxCharges = item.cariche_massime || 0;
    const isDepleted = !hasCharges && !isWorking;

    return (
        <div className={`p-3 rounded-lg border shadow-sm w-full sm:w-[calc(50%-0.5rem)] flex flex-col gap-2 transition-all duration-300 ${isWorking ? 'bg-emerald-900/20 border-emerald-500/50 shadow-[0_0_15px_rgba(16,185,129,0.15)]' : 'bg-gray-800 border-gray-700'}`}>
            
            {/* Header */}
            <div className="flex justify-between items-start">
                <span className={`font-bold text-sm leading-tight ${isWorking ? 'text-emerald-400' : 'text-gray-300'}`}>
                    {item.nome}
                </span>
                {isWorking && <span className="animate-pulse text-emerald-500 shrink-0 ml-2"><Activity size={16}/></span>}
            </div>

            {/* Barra Cariche */}
            {maxCharges > 0 && (
                <div className={`rounded p-1.5 flex justify-between items-center transition-colors ${isDepleted ? 'bg-red-900/20 border border-red-900/30' : 'bg-black/30'}`}>
                    <div className="flex items-center gap-1.5 text-xs font-mono">
                         <Battery size={14} className={hasCharges ? "text-yellow-400" : "text-red-500"} />
                         <span className={hasCharges ? "text-white" : "text-red-400 font-bold"}>
                            {item.cariche_attuali} <span className="text-gray-500">/</span> {maxCharges}
                         </span>
                    </div>
                    
                    <button 
                        onClick={handleUseCharge}
                        disabled={!hasCharges || isWorking}
                        className={`text-[10px] font-bold px-2 py-0.5 rounded border uppercase tracking-wider transition-all active:scale-95 ${
                            isWorking
                            ? 'bg-emerald-600/20 text-emerald-400 border-emerald-600/50 cursor-default'
                            : hasCharges
                                ? 'bg-emerald-600 hover:bg-emerald-500 text-white border-emerald-500 shadow-sm hover:shadow-md'
                                : 'bg-gray-700 text-gray-500 border-gray-600 cursor-not-allowed'
                        }`}
                    >
                        {isWorking ? 'ON' : 'USA'}
                    </button>
                </div>
            )}

            {/* Footer: Timer e Ricarica */}
            <div className="flex justify-between items-end mt-1 h-6">
                <div className="flex flex-col justify-end">
                    {(item.durata_totale > 0 || isWorking) && (
                        <div className={`text-xs font-mono flex items-center gap-1 transition-colors ${isWorking ? 'text-blue-300 font-bold' : 'text-gray-500'}`}>
                            <Clock size={12} />
                            {isWorking 
                                ? <span>{formatTimer(timeLeft)}</span> 
                                : <span className="text-[10px]">Durata: {formatTimer(item.durata_totale)}</span>
                            }
                        </div>
                    )}
                </div>

                {item.costo_ricarica > 0 && item.cariche_attuali < maxCharges && (
                    <button 
                        onClick={handleRecharge}
                        className="flex items-center gap-1 bg-yellow-900/10 hover:bg-yellow-900/30 text-yellow-500 hover:text-yellow-200 px-2 py-0.5 rounded border border-transparent hover:border-yellow-700/50 transition-all text-[10px]"
                        title={item.testo_ricarica}
                    >
                        <RefreshCw size={10} /> {item.costo_ricarica} CR
                    </button>
                )}
            </div>
        </div>
    );
};

export default ActiveItemWidget;

==================================================
FILE: src\components\AdminMessageTab.jsx
==================================================
import React, { useState, useEffect, Fragment } from 'react'; 
import { Tab } from '@headlessui/react';
import { useCharacter } from './CharacterContext';
import { postBroadcastMessage, getAdminSentMessages } from '../api'; 

function classNames(...classes) {
  return classes.filter(Boolean).join(' ');
}

const AdminMessageTab = ({ onLogout }) => {
    const { selectedCharacterData } = useCharacter();
    
    const [title, setTitle] = useState('');
    const [text, setText] = useState('');
    const [saveHistory, setSaveHistory] = useState(true);
    const [isSending, setIsSending] = useState(false);
    
    const [history, setHistory] = useState([]); 
    const [isLoadingHistory, setIsLoadingHistory] = useState(false);

    useEffect(() => {
        if (selectedCharacterData?.is_staff) {
            fetchHistory();
        }
    }, [selectedCharacterData]);

    const fetchHistory = async () => {
        setIsLoadingHistory(true);
        try {
            const data = await getAdminSentMessages(onLogout);
            setHistory(data || []);
        } catch (err) {
            console.error("Errore caricamento cronologia admin:", err);
        } finally {
            setIsLoadingHistory(false);
        }
    };

    if (!selectedCharacterData?.is_staff) {
        return <div className="p-4 text-red-400">Accesso negato.</div>;
    }

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!title || !text) {
             alert('Titolo e contenuto sono obbligatori.');
             return;
        }
        
        setIsSending(true);
        try {
            const payload = {
                titolo: title, 
                testo: text,   
                salva_in_cronologia: saveHistory 
            };

            await postBroadcastMessage(payload, onLogout);
            alert('Messaggio Broadcast inviato con successo!');
            
            fetchHistory();
            
            setTitle('');
            setText('');
        } catch (err) {
            alert(`Errore nell'invio: ${err.message}`);
        } finally {
            setIsSending(false);
        }
    };

    return (
        <div className="p-2">
            <h2 className="text-xl font-bold mb-4 text-red-400">Gestione Messaggi Globali</h2>
            
            <Tab.Group>
                <Tab.List className="flex space-x-1 rounded-xl bg-gray-900 p-1 mb-4">
                    <Tab as={Fragment}>
                        {({ selected }) => (
                            <button className={classNames('w-full rounded-lg py-2 text-sm font-medium', selected ? 'bg-gray-700 text-white' : 'text-gray-400 hover:text-white')}>
                                Scrivi Messaggio
                            </button>
                        )}
                    </Tab>
                    <Tab as={Fragment}>
                        {({ selected }) => (
                            <button 
                                onClick={fetchHistory} 
                                className={classNames('w-full rounded-lg py-2 text-sm font-medium', selected ? 'bg-gray-700 text-white' : 'text-gray-400 hover:text-white')}
                            >
                                Cronologia Inviati
                            </button>
                        )}
                    </Tab>
                </Tab.List>

                <Tab.Panels>
                    {/* SUBTAB 1: FORM INVIO */}
                    <Tab.Panel>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm font-medium text-gray-400">Titolo</label>
                                <input
                                    type="text"
                                    value={title}
                                    onChange={(e) => setTitle(e.target.value)}
                                    placeholder="Titolo Breve"
                                    className="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded text-white focus:border-indigo-500 focus:ring-indigo-500"
                                    required
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-400">Contenuto</label>
                                <textarea
                                    value={text}
                                    onChange={(e) => setText(e.target.value)}
                                    placeholder="Contenuto del messaggio..."
                                    rows="5"
                                    className="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded text-white focus:border-indigo-500 focus:ring-indigo-500"
                                    required
                                />
                            </div>
                            <div className="flex items-center">
                                <input
                                    type="checkbox"
                                    checked={saveHistory}
                                    onChange={(e) => setSaveHistory(e.target.checked)}
                                    id="saveHistory"
                                    className="w-4 h-4 text-indigo-600 bg-gray-700 border-gray-600 rounded"
                                />
                                <label htmlFor="saveHistory" className="ml-2 text-sm text-gray-300">Salva nella cronologia (visibile in questa lista)</label>
                            </div>
                            <button
                                type="submit"
                                disabled={isSending}
                                className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 disabled:opacity-50"
                            >
                                {isSending ? 'Invio in corso...' : 'INVIA BROADCAST'}
                            </button>
                        </form>
                    </Tab.Panel>

                    {/* SUBTAB 2: CRONOLOGIA REALE */}
                    <Tab.Panel>
                        <div className="space-y-2 max-h-96 overflow-y-auto">
                            {isLoadingHistory && <p className="text-center text-gray-400">Caricamento...</p>}
                            
                            {!isLoadingHistory && history.length > 0 ? (
                                history.map(msg => (
                                    <div key={msg.id} className="p-3 bg-gray-700 rounded border-l-4 border-gray-500">
                                        <div className="flex justify-between items-start">
                                            <p className="font-bold text-white">{msg.titolo}</p>
                                            <span className="text-xs px-2 py-1 rounded bg-gray-800 text-gray-300 ml-2 shrink-0">
                                                {msg.tipo_messaggio === 'BROAD' ? 'Broadcast' : msg.tipo_messaggio}
                                            </span>
                                        </div>
                                        
                                        {/* --- CORREZIONE: Rendering HTML --- */}
                                        <div 
                                            className="text-sm text-gray-300 mt-2 prose prose-invert max-w-none"
                                            dangerouslySetInnerHTML={{ __html: msg.testo }}
                                        />
                                        {/* ---------------------------------- */}

                                        <p className="text-xs text-gray-500 mt-2 text-right border-t border-gray-600 pt-1">
                                            Inviato il: {new Date(msg.data_invio).toLocaleString()}
                                        </p>
                                    </div>
                                ))
                            ) : (
                                !isLoadingHistory && (
                                    <p className="text-center text-gray-500 py-8">
                                        Nessun messaggio trovato nella cronologia inviati.
                                    </p>
                                )
                            )}
                        </div>
                    </Tab.Panel>
                </Tab.Panels>
            </Tab.Group>
        </div>
    );
};

export default AdminMessageTab;

==================================================
FILE: src\components\AuraTraitsModal.jsx
==================================================
import React, { useState } from 'react';
import { X, Check, Lock, ChevronRight, Loader2 } from 'lucide-react';
import { acquireAbilita } from '../api'; 

export default function AuraTraitsModal({ aura, personaggio, onClose, onUpdateCharacter, currentValue }) {
  const [selectedStep, setSelectedStep] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // --- LOGICA RECUPERO VALORE SEMPLIFICATA ---
  // Se currentValue è passato (da PunteggioDisplay), usalo.
  // Altrimenti, fallback su 0.
  const currentAuraVal = currentValue !== undefined ? parseInt(currentValue, 10) : 0;
  // --------------------------------------------

  const getPossessedTrait = (level) => {
    if (!personaggio?.abilita_possedute || !aura.tratti_disponibili) return null;
    
    const availableIdsAtLevel = aura.tratti_disponibili
        .filter(t => t.livello_riferimento === level)
        .map(t => t.id);
    
    return personaggio.abilita_possedute.find(ab => availableIdsAtLevel.includes(ab.id));
  };

  const handleStepClick = (config) => {
    if (currentAuraVal < config.livello) return; // Blocco se livello insufficiente
    setSelectedStep(config);
  };

  const handleSelectTrait = async (trait) => {
    setLoading(true);
    setError(null);
    try {
      await acquireAbilita(trait.id, personaggio.id, null); 
      if (onUpdateCharacter) await onUpdateCharacter(); 
      setSelectedStep(null); 
    } catch (err) {
      console.error(err);
      setError(err.message || "Errore durante la selezione.");
    } finally {
      setLoading(false);
    }
  };

  // --- RENDER OPZIONI ---
  if (selectedStep) {
    const options = aura.tratti_disponibili.filter(t => t.livello_riferimento === selectedStep.livello);
    const possessed = getPossessedTrait(selectedStep.livello);

    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
        <div className="bg-slate-900 border border-slate-700 rounded-xl w-full max-w-2xl max-h-[90vh] flex flex-col shadow-2xl">
            <div className="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50 rounded-t-xl">
                <div>
                    <h3 className="text-xl font-bold text-amber-400">Seleziona {selectedStep.nome_step}</h3>
                    <p className="text-sm text-slate-400">Livello Aura richiesto: {selectedStep.livello}</p>
                </div>
                <button onClick={() => setSelectedStep(null)} className="p-2 hover:bg-slate-700 rounded-full text-slate-400 hover:text-white">
                    <X size={24} />
                </button>
            </div>

            <div className="p-4 overflow-y-auto space-y-3 flex-1">
                {error && <div className="p-3 bg-red-900/50 border border-red-500/50 text-red-200 rounded mb-4">{error}</div>}
                
                {options.length === 0 ? (
                    <div className="text-center text-slate-500 py-8">Nessuna opzione disponibile.</div>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                        {options.map(trait => {
                            const isSelected = possessed?.id === trait.id;
                            return (
                                <div key={trait.id} 
                                     className={`relative p-4 rounded-lg border transition-all cursor-pointer group
                                        ${isSelected 
                                            ? 'bg-amber-900/20 border-amber-500 ring-1 ring-amber-500' 
                                            : 'bg-slate-800 border-slate-700 hover:border-slate-500 hover:bg-slate-750'
                                        }`}
                                     onClick={() => !isSelected && handleSelectTrait(trait)}
                                >
                                    <div className="flex justify-between items-start mb-2">
                                        <h4 className={`font-bold ${isSelected ? 'text-amber-400' : 'text-slate-200'}`}>{trait.nome}</h4>
                                        {isSelected && <Check size={18} className="text-amber-500" />}
                                    </div>
                                    <div 
                                        className="text-xs text-slate-400 line-clamp-3 mb-2 prose prose-invert prose-p:my-1 prose-strong:text-slate-200"
                                        dangerouslySetInnerHTML={{ __html: trait.descrizione || "Nessuna descrizione." }}
                                    />
                                    
                                    {trait.statistica_modificata && (
                                        <span className="inline-flex items-center px-2 py-1 bg-slate-900 rounded text-[10px] text-cyan-400 border border-slate-700">
                                            {trait.statistica_modificata}
                                        </span>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                )}
            </div>
            {loading && <div className="p-2 text-center text-amber-400 text-sm">Elaborazione in corso...</div>}
        </div>
      </div>
    );
  }

  // --- RENDER TIMELINE ---
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
      <div className="bg-slate-900 border border-slate-700 rounded-xl w-full max-w-lg shadow-2xl relative overflow-hidden flex flex-col max-h-[85vh]">
        
        <div className="p-5 border-b border-slate-700 flex justify-between items-center bg-linear-to-r from-slate-900 to-slate-800 shrink-0">
            <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded bg-slate-800 border border-slate-600 flex items-center justify-center text-xl font-bold text-slate-300">
                   {aura.nome.charAt(0)}
                </div>
                <div>
                    <h2 className="text-xl font-bold text-white tracking-wide">Evoluzione {aura.nome}</h2>
                    <p className="text-xs text-slate-400 uppercase tracking-wider">
                        Livello Attuale: <span className="text-amber-400 font-bold ml-1">{currentAuraVal}</span>
                    </p>
                </div>
            </div>
            <button onClick={onClose} className="p-2 hover:bg-slate-700 rounded-full text-slate-400 hover:text-white">
                <X size={24} />
            </button>
        </div>

        <div className="p-6 space-y-6 overflow-y-auto">
            {aura.configurazione_livelli && aura.configurazione_livelli.map((step, index) => {
                const possessedTrait = getPossessedTrait(step.livello);
                
                const isLocked = currentAuraVal < step.livello;
                const isCompleted = !!possessedTrait;

                return (
                    <div key={step.id || index} className="relative pl-8 last:pb-0">
                        {index !== aura.configurazione_livelli.length - 1 && (
                            <div className={`absolute left-[11px] top-8 bottom-6 w-0.5 ${isCompleted ? 'bg-amber-500/50' : 'bg-slate-700'}`} />
                        )}

                        <div className={`absolute left-0 top-1 w-6 h-6 rounded-full flex items-center justify-center border-2 z-10 
                            ${isCompleted ? 'bg-amber-900 border-amber-500 text-amber-500' : 
                              isLocked ? 'bg-slate-800 border-slate-600 text-slate-600' : 
                              'bg-cyan-900 border-cyan-500 text-cyan-400 animate-pulse'}`}>
                            {isLocked ? <Lock size={12} /> : isCompleted ? <Check size={12} /> : <div className="w-2 h-2 bg-cyan-400 rounded-full" />}
                        </div>

                        <div 
                            className={`p-4 rounded-lg border transition-all ${
                                isLocked ? 'bg-slate-900/50 border-slate-800 opacity-60' : 
                                isCompleted ? 'bg-slate-800 border-amber-500/30' : 
                                'bg-slate-800 border-cyan-500/50 cursor-pointer hover:bg-slate-750 hover:shadow-lg'
                            }`}
                            onClick={() => !isLocked && handleStepClick(step)}
                        >
                            <div className="flex justify-between items-start">
                                <div>
                                    <span className="text-[10px] font-mono text-slate-500 mb-1 block uppercase">Livello {step.livello}</span>
                                    <h3 className={`font-bold text-lg leading-tight ${isCompleted ? 'text-amber-400' : 'text-slate-200'}`}>
                                        {step.nome_step}
                                    </h3>
                                </div>
                                {!isLocked && !isCompleted && <ChevronRight size={20} className="text-cyan-500" />}
                            </div>
                            
                            <div className="mt-2 text-sm">
                                {isLocked ? (
                                    <p className="text-slate-600 italic text-xs">Sblocca al livello {step.livello}</p>
                                ) : isCompleted ? (
                                    <div className="flex items-center gap-2 bg-amber-950/30 px-3 py-2 rounded border border-amber-500/20 mt-1">
                                        <span className="text-amber-200 font-medium text-sm">{possessedTrait.nome}</span>
                                    </div>
                                ) : (
                                    <p className="text-slate-400 text-xs">{step.descrizione_fluff || "Clicca per selezionare un tratto."}</p>
                                )}
                            </div>
                        </div>
                    </div>
                );
            })}
        </div>
      </div>
    </div>
  );
}

==================================================
FILE: src\components\CerimonialiTab.jsx
==================================================
import React, { useState, Fragment, useMemo } from 'react';
import { Tab } from '@headlessui/react';
import { useCharacter } from './CharacterContext';
import { Loader2, ShoppingCart, Info, CheckCircle2, PlusCircle, FileEdit, Users } from 'lucide-react';

// --- COMPONENTS ---
import GenericGroupedList from './GenericGroupedList';
import PunteggioDisplay from './PunteggioDisplay';     
import IconaPunteggio from './IconaPunteggio';
import ProposalManager from './ProposalManager';
import ProposalEditorModal from './ProposalEditorModal';

// --- API & HOOKS ---
import { fetchAuthenticated } from '../api.js';

function classNames(...classes) {
  return classes.filter(Boolean).join(' ');
}

const CerimonialiTab = ({ onLogout }) => {
  const {
    selectedCharacterData: char,
    selectedCharacterId, 
    acquirableCerimoniali, 
    refreshCharacterData,
    isLoadingAcquirable,
    isLoadingDetail
  } = useCharacter();
  
  const [modalItem, setModalItem] = useState(null);
  const [isAcquiring, setIsAcquiring] = useState(null);
  const [showProposals, setShowProposals] = useState(false);

  // Recupero Valore Coralità (CCO)
  const ccoValue = useMemo(() => {
    const stat = char?.statistiche_primarie?.find(s => s.sigla === 'CCO');
    return stat ? stat.valore_corrente : (char?.statistiche_temporanee?.['CCO'] || 0);
  }, [char]);

  // Logica di Filtraggio Cerimoniali Acquistabili
  const filteredAcquirable = useMemo(() => {
    if (!acquirableCerimoniali || !char) return [];
    return acquirableCerimoniali.filter(cer => {
      const auraScore = char.punteggi_base?.[cer.aura_richiesta_nome] || 0;
      const limit = Math.min(ccoValue, auraScore);
      return cer.livello <= limit;
    });
  }, [acquirableCerimoniali, char, ccoValue]);

  const handleAcquire = async (item, e) => {
    e.stopPropagation();
    if (isAcquiring || !selectedCharacterId) return;
    if (!window.confirm(`Apprendere il Cerimoniale "${item.nome}" per ${item.costo_crediti} Crediti?`)) return;
    
    setIsAcquiring(item.id);
    try {
      await fetchAuthenticated('/personaggi/api/personaggio/me/acquisisci_cerimoniale/', {
        method: 'POST',
        body: JSON.stringify({ personaggio_id: selectedCharacterId, cerimoniale_id: item.id })
      }, onLogout);
      await refreshCharacterData(); 
    } catch (error) {
      alert(`Errore: ${error.message}`);
    } finally {
      setIsAcquiring(null);
    }
  };

  if (isLoadingAcquirable || isLoadingDetail || !char) {
    return (
      <div className="flex justify-center items-center h-64">
        <Loader2 className="animate-spin text-purple-500" size={48} />
      </div>
    );
  }

  const renderGroupHeader = (group) => (
    <PunteggioDisplay 
        punteggio={{ nome: group.name, colore: group.color, icona_url: group.icon }}
        value={group.items.length}
        displayText="name"
        iconType="inv_circle"
        size="s"
        className="rounded-b-none border-purple-500/30"
    />
  );

  const renderItem = (item, isOwned) => (
    <li className="flex justify-between items-center py-3 px-2 hover:bg-gray-700/30 transition-colors rounded-sm border-b border-gray-700/50 last:border-0 gap-2">
      <div className="flex items-center gap-3 cursor-pointer grow" onClick={() => setModalItem(item)}>
          <div className="shrink-0 relative">
              <IconaPunteggio url={item.aura_richiesta?.icona_url} color={item.aura_richiesta?.colore} mode="cerchio_inv" size="xs" />
              <span className="absolute -top-2 -right-2 bg-purple-900 text-purple-100 text-[9px] font-bold px-1 py-0.5 rounded-full border border-purple-500">
                  L{item.livello}
              </span>
          </div>
          <div className="flex flex-col">
            <span className="font-bold text-gray-200">{item.nome}</span>
            {!isOwned && <span className="text-[10px] text-yellow-500 font-mono">{item.costo_crediti} CR</span>}
          </div>
      </div>
      <div className="flex items-center gap-2">
        {!isOwned && (
          <button
            onClick={(e) => handleAcquire(item, e)}
            disabled={char.crediti < item.costo_crediti || isAcquiring === item.id}
            className="p-2 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 text-white rounded-lg transition-all"
          >
            {isAcquiring === item.id ? <Loader2 size={16} className="animate-spin"/> : <ShoppingCart size={16} />}
          </button>
        )}
        <button onClick={() => setModalItem(item)} className="p-2 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full">
          <Info size={18} />
        </button>
      </div>
    </li>
  );

  return (
    <div className="w-full p-4 max-w-6xl mx-auto pb-24">
      <div className="mb-6 flex justify-between items-center bg-gray-800 p-4 rounded-xl border border-purple-500/20 shadow-lg max-w-3xl mx-auto">
          <div className="flex items-center gap-3">
            <Users className="text-purple-400" size={24}/>
            <div>
              <div className="text-[10px] text-gray-400 uppercase font-bold tracking-widest">Coralità (CCO)</div>
              <div className="text-xl font-black text-purple-300 leading-none">{ccoValue}</div>
            </div>
          </div>
          <div className="text-right">
              <div className="text-[10px] text-gray-400 uppercase font-bold tracking-widest">Crediti</div>
              <div className="text-xl font-black text-yellow-500 leading-none">{char.crediti} CR</div>
          </div>
      </div>

      <div className="flex justify-end mb-6 max-w-3xl mx-auto">
          <button onClick={() => setShowProposals(true)} className="flex items-center gap-2 bg-gray-800 hover:bg-gray-700 text-purple-300 px-4 py-2 rounded-lg border border-purple-500/30 transition-all text-sm font-bold">
              <FileEdit size={16} /> Gestisci Proposte Cerimoniale
          </button>
      </div>

      <div className="hidden md:grid grid-cols-2 gap-6">
          <div>
              <h2 className="text-lg font-bold text-white mb-4 flex items-center gap-2 px-2"><CheckCircle2 className="text-green-500" size={20}/> Posseduti</h2>
              <GenericGroupedList items={char.cerimoniali_posseduti} groupByKey="aura_richiesta" renderItem={(i) => renderItem(i, true)} renderHeader={renderGroupHeader} itemSortFn={(a,b) => a.livello - b.livello} />
          </div>
          <div>
              <h2 className="text-lg font-bold text-white mb-4 flex items-center gap-2 px-2"><PlusCircle className="text-purple-500" size={20}/> Nuovi Cerimoniali</h2>
              <GenericGroupedList items={filteredAcquirable} groupByKey="aura_richiesta" renderItem={(i) => renderItem(i, false)} renderHeader={renderGroupHeader} itemSortFn={(a,b) => a.livello - b.livello} />
          </div>
      </div>

      {/* Dettaglio Modale */}
      {modalItem && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/90 backdrop-blur-md" onClick={() => setModalItem(null)}>
          <div className="bg-gray-900 border border-purple-500/30 rounded-2xl w-full max-w-lg max-h-[85vh] flex flex-col shadow-2xl overflow-hidden" onClick={e => e.stopPropagation()}>
             <div className="p-5 border-b border-gray-800 flex justify-between items-start bg-gray-800/50">
                <div>
                    <h3 className="text-xl font-black text-purple-400 uppercase">{modalItem.nome}</h3>
                    <p className="text-[10px] text-gray-500 uppercase font-bold">Livello {modalItem.livello} • {modalItem.aura_richiesta_nome}</p>
                </div>
                <button onClick={() => setModalItem(null)} className="text-gray-400 hover:text-white transition-colors">✕</button>
             </div>
             <div className="p-6 overflow-y-auto space-y-6 text-sm">
                <div><h4 className="text-[10px] font-black text-purple-500 uppercase mb-1">Prerequisiti</h4><p className="text-gray-300 italic">{modalItem.prerequisiti}</p></div>
                <div><h4 className="text-[10px] font-black text-gray-500 uppercase mb-1">Svolgimento</h4><div className="text-gray-300 whitespace-pre-wrap">{modalItem.svolgimento}</div></div>
                <div className="bg-purple-900/10 p-4 rounded-xl border border-purple-500/20"><h4 className="text-[10px] font-black text-purple-300 uppercase mb-1">Effetto</h4><div className="text-gray-200">{modalItem.effetto}</div></div>
             </div>
          </div>
        </div>
      )}

      {showProposals && <ProposalManager type="Cerimoniale" onClose={() => setShowProposals(false)} />}
    </div>
  );
};

export default CerimonialiTab;

==================================================
FILE: src\components\CharacterContext.jsx
==================================================
import React, { createContext, useState, useContext, useCallback, useEffect, useRef } from 'react';
import { useQueryClient, useIsMutating } from '@tanstack/react-query';
import { 
  getMessages, 
  markMessageAsRead, 
  deleteMessage, 
  getAdminPendingProposalsCount, 
  saveWebPushSubscription, 
  fetchAuthenticated 
} from '../api'; 
import NotificationPopup from './NotificationPopup';

import { 
  usePunteggi, 
  usePersonaggiList, 
  usePersonaggioDetail, 
  useAcquirableSkills, 
  useAcquirableInfusioni, 
  useAcquirableTessiture,
  useAcquirableCerimoniali
} from '../hooks/useGameData';

export const CharacterContext = createContext(null);

// --- HELPER UTILS ---
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

const sendSystemNotification = (title, body) => {
    if (!("Notification" in window)) return;
    if (Notification.permission === "granted") {
      try {
          new Notification(title, { body, icon: '/pwa-192x192.png', vibrate: [200, 100, 200] });
      } catch (e) { console.error("Errore notifica:", e); }
    }
};

export const CharacterProvider = ({ children, onLogout }) => {
  const queryClient = useQueryClient();
  
  const mutatingCount = useIsMutating();
  
  // --- STATI GLOBALI UI ---
  const [selectedCharacterId, setSelectedCharacterId] = useState(() => localStorage.getItem('kor35_last_char_id') || '');
  const [isStaff] = useState(() => localStorage.getItem('kor35_is_staff') === 'true');
// Riconosciamo se è un Master (Admin di Django) o uno Staffer semplice
  const [isMaster] = useState(() => localStorage.getItem('kor35_is_master') === 'true');
  const [isAdmin] = useState(() => localStorage.getItem('kor35_is_master') === 'true');
  const [staffWorkMode, setStaffWorkMode] = useState('dashboard');

  const [viewAll, setViewAll] = useState(false);
  
  // --- NUOVO STATO PER I TIMER (GESTIONE GLOBALE) ---
  const [activeTimers, setActiveTimers] = useState({});

  const updateTimerState = useCallback((timerData) => {
    setActiveTimers(prev => ({
        ...prev,
        [timerData.nome]: {
            ...timerData,
            endTime: new Date(timerData.data_fine).getTime()
        }
    }));
  }, []);

  const removeTimerState = useCallback((nomeTimer) => {
    setActiveTimers(prev => {
        const newState = { ...prev };
        delete newState[nomeTimer];
        return newState;
    });
  }, []);

  // --- FETCH INIZIALE TIMER ATTIVI ---
  useEffect(() => {
    const loadInitialTimers = async () => {
      try {
        const data = await fetchAuthenticated('/personaggi/api/timers/active/', onLogout);
        if (Array.isArray(data)) {
          data.forEach(t => updateTimerState(t));
        }
      } catch (err) {
        console.error("Errore caricamento timer iniziali", err);
      }
    };
    loadInitialTimers();
  }, [onLogout, updateTimerState]);


  // --- REACT QUERY HOOKS ---
  
  // 1. Punteggi
  const { data: punteggiList = [], isLoading: isLoadingPunteggi } = usePunteggi(onLogout);

  // 2. Lista Personaggi
  const { 
    data: personaggiList = [], 
    isLoading: isLoadingList, 
    refetch: refetchPersonaggiList 
  } = usePersonaggiList(onLogout, viewAll);

  // 3. Dettaglio Personaggio Selezionato
  const { 
    data: selectedCharacterData, 
    isLoading: isLoadingDetail,
    refetch: refetchCharacterDetail
  } = usePersonaggioDetail(selectedCharacterId, onLogout);

  // 4. Dati Lazy Loading (Estraiamo anche i refetch)
  const { 
      data: acquirableSkills = [], 
      refetch: refetchSkills 
  } = useAcquirableSkills(selectedCharacterId, onLogout);

  const { 
      data: acquirableInfusioni = [], 
      refetch: refetchInfusioni 
  } = useAcquirableInfusioni(selectedCharacterId);

  const { 
      data: acquirableTessiture = [], 
      refetch: refetchTessiture 
  } = useAcquirableTessiture(selectedCharacterId);

  const { 
      data: acquirableCerimoniali = [], 
      refetch: refetchCerimoniali 
  } = useAcquirableCerimoniali(selectedCharacterId);

  // --- LOGICA SELEZIONE AUTOMATICA PG ---
  useEffect(() => {
    if (!selectedCharacterId && personaggiList.length > 0) {
        const lastId = localStorage.getItem('kor35_last_char_id');
        const targetId = (lastId && personaggiList.some(p => p.id.toString() === lastId)) 
                         ? lastId 
                         : personaggiList[0].id;
        setSelectedCharacterId(targetId);
    }
  }, [personaggiList, selectedCharacterId]);

  // --- AZIONI CONTEXT ---
  const handleSelectCharacter = useCallback((id) => {
    setSelectedCharacterId(id);
    if(id) localStorage.setItem('kor35_last_char_id', id);
  }, []);

  // *** CORREZIONE CRUCIALE ***
  // Usiamo Promise.all per attendere che TUTTI i refetch siano completati
  // prima di restituire il controllo al componente chiamante (es. AbilitaTab).
  const refreshCharacterData = useCallback(async () => {
    await Promise.all([
        refetchCharacterDetail(),
        refetchSkills(),
        refetchInfusioni(),
        refetchTessiture(),
        refetchCerimoniali()
    ]);
  }, [refetchCharacterDetail, refetchSkills, refetchInfusioni, refetchTessiture, refetchCerimoniali]);

  const fetchPersonaggi = useCallback(() => {
    return refetchPersonaggiList();
  }, [refetchPersonaggiList]);

  const toggleViewAll = () => setViewAll(prev => !prev);

  // --- GESTIONE MESSAGGI ---
  const [userMessages, setUserMessages] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);

  const fetchUserMessages = useCallback(async (charId) => {
    if (!charId) return;
    try {
      const rawMsgs = await getMessages(charId, onLogout);
      const msgs = (rawMsgs || []).map(msg => ({
          ...msg,
          letto: msg.is_letto 
      }));
      const sorted = (msgs || []).sort((a, b) => {
        if (a.letto !== b.letto) return a.letto ? 1 : -1;
        return new Date(b.data_invio) - new Date(a.data_invio);
      });
      setUserMessages(sorted);
      setUnreadCount(sorted.filter(m => !m.letto).length);
    } catch (err) { console.error("Err msg:", err); }
  }, [onLogout]);

  useEffect(() => {
    if (selectedCharacterId) fetchUserMessages(selectedCharacterId);
  }, [selectedCharacterId, fetchUserMessages]);

  const handleMarkAsRead = async (msgId) => {
      setUserMessages(prev => prev.map(m => m.id === msgId ? { ...m, letto: true } : m)); 
      setUnreadCount(prev => Math.max(0, prev - 1));
      try { await markMessageAsRead(msgId, selectedCharacterId, onLogout); } 
      catch (e) { fetchUserMessages(selectedCharacterId); }
  };

  const handleDeleteMessage = async (msgId) => {
      if(!window.confirm("Cancellare messaggio?")) return;
      setUserMessages(prev => prev.filter(m => m.id !== msgId)); 
      try { await deleteMessage(msgId, selectedCharacterId, onLogout); } 
      catch (e) { fetchUserMessages(selectedCharacterId); }
  };

  // --- ADMIN & NOTIFICHE ---
  const [adminPendingCount, setAdminPendingCount] = useState(0);
  useEffect(() => {
      if (isAdmin && !viewAll) {
          const check = async () => {
              try { const d = await getAdminPendingProposalsCount(onLogout); setAdminPendingCount(d.count); } 
              catch (e) {}
          };
          check();
          const i = setInterval(check, 60000);
          return () => clearInterval(i);
      }
  }, [isAdmin, viewAll, onLogout]);

  const subscribeToPush = useCallback(async () => {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) return;
    try {
        const reg = await navigator.serviceWorker.ready;
        let sub = await reg.pushManager.getSubscription();
        if (!sub) {
            const key = urlBase64ToUint8Array("BIOIApSIeJdV1tp5iVxyLtm8KzM43_AQWV2ymS4iMjkIG1R5g399o6WRdZJY-xcUBZPyJ7EFRVgWqlbalOkGSYw");
            sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: key });
        }
        await saveWebPushSubscription(sub, onLogout);
    } catch (e) { console.error("WebPush Error:", e); }
  }, [onLogout]);

  useEffect(() => { if (selectedCharacterId) subscribeToPush(); }, [selectedCharacterId, subscribeToPush]);

  const [notification, setNotification] = useState(null);
  const ws = useRef(null);
  useEffect(() => {
    const wsUrl = window.location.hostname === 'localhost' ? 'ws://127.0.0.1:8000/ws/notifications/' : `wss://www.kor35.it/ws/notifications/`;
    if (ws.current) ws.current.close();
    ws.current = new WebSocket(wsUrl);
    ws.current.onmessage = (e) => {
      try {
        const d = JSON.parse(e.data);
        if (d.action === 'TIMER_SYNC') {
            updateTimerState(d.payload);
        }

        if (d.type === 'notification') {
           const msg = d.payload;
           const myId = parseInt(selectedCharacterId);
           if (msg.tipo === 'BROAD' || (msg.tipo === 'INDV' && msg.destinatario_id === myId) || msg.tipo === 'GROUP') {
              setNotification(msg);
              sendSystemNotification(msg.titolo, msg.testo.replace(/<[^>]+>/g, ''));
              fetchUserMessages(selectedCharacterId);
              queryClient.invalidateQueries(['personaggio', selectedCharacterId]);
           }
        }
      } catch (err) {}
    };
    return () => { if (ws.current) ws.current.close(); };
  }, [selectedCharacterId, fetchUserMessages, queryClient]);


  // --- VALUE DEL CONTEXT ---
  const value = {
    personaggiList,
    punteggiList,
    selectedCharacterId,
    
    characterData: selectedCharacterData, 
    selectedCharacterData,
    
    acquirableSkills,
    acquirableInfusioni,
    acquirableTessiture,
    acquirableCerimoniali,

    activeTimers,
    setActiveTimers,
    updateTimerState,
    removeTimerState,
    
    isLoading: isLoadingList || isLoadingDetail || isLoadingPunteggi || mutatingCount > 0,
    isLoadingList,
    isLoadingDetail,
    isSyncing: mutatingCount > 0,
    
    selectCharacter: handleSelectCharacter,
    refreshCharacterData,
    fetchPersonaggi, 
    
    loadSkillsOnDemand: () => {}, 
    loadInfusioniOnDemand: () => {},
    loadTessitureOnDemand: () => {},

    isStaff,
    isMaster,
    staffWorkMode,
    setStaffWorkMode,
    isAdmin,
    viewAll,
    toggleViewAll,
    adminPendingCount,
    userMessages,
    unreadCount,
    fetchUserMessages,
    handleMarkAsRead,
    handleDeleteMessage,
    subscribeToPush,
  };

  return (
    <CharacterContext.Provider value={value}>
      {children}
      <NotificationPopup notification={notification} onClose={() => setNotification(null)} />
    </CharacterContext.Provider>
  );
};

export const useCharacter = () => {
  const context = useContext(CharacterContext);
  if (!context) throw new Error('useCharacter deve essere usato dentro un CharacterProvider');
  return context;
};

==================================================
FILE: src\components\ComposeMessageModal.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { Dialog } from '@headlessui/react';
import { searchPersonaggi, sendPrivateMessage } from '../api';

const ComposeMessageModal = ({ isOpen, onClose, currentCharacterId, onMessageSent, onLogout }) => {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [selectedRecipient, setSelectedRecipient] = useState(null);
  const [titolo, setTitolo] = useState('');
  const [testo, setTesto] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  // Gestione ricerca debounce
  useEffect(() => {
    const delayDebounceFn = setTimeout(async () => {
      if (query.length >= 2 && !selectedRecipient) {
        try {
          const data = await searchPersonaggi(query, currentCharacterId);
          setResults(data);
        } catch (err) {
          console.error("Errore ricerca", err);
        }
      } else {
        setResults([]);
      }
    }, 300);

    return () => clearTimeout(delayDebounceFn);
  }, [query, currentCharacterId, selectedRecipient]);

  const handleSelect = (pg) => {
    setSelectedRecipient(pg);
    setQuery(pg.nome);
    setResults([]);
  };

  const handleResetRecipient = () => {
    setSelectedRecipient(null);
    setQuery('');
    setResults([]);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!selectedRecipient || !titolo || !testo) {
        setError("Tutti i campi sono obbligatori.");
        return;
    }

    setLoading(true);
    setError('');

    try {
      await sendPrivateMessage({
        destinatario_id: selectedRecipient.id,
        titolo: titolo,
        testo: testo
      }, onLogout);
      
      // Reset form
      setTitolo('');
      setTesto('');
      handleResetRecipient();
      onMessageSent(); // Callback per aggiornare lista o chiudere
      onClose();
    } catch (err) {
      setError("Errore nell'invio del messaggio: " + err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/70" aria-hidden="true" />
      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="w-full max-w-lg rounded-xl bg-gray-800 border border-gray-700 p-6 text-white shadow-xl">
          <Dialog.Title className="text-xl font-bold mb-4 text-indigo-400">Scrivi Messaggio</Dialog.Title>

          {error && <div className="mb-4 p-2 bg-red-900/50 border border-red-500 rounded text-sm text-red-200">{error}</div>}

          <form onSubmit={handleSubmit} className="space-y-4">
            
            {/* Campo Destinatario con Autocomplete */}
            <div className="relative">
              <label className="block text-sm font-medium text-gray-400 mb-1">A chi vuoi scrivere?</label>
              {selectedRecipient ? (
                <div className="flex items-center justify-between bg-indigo-900/30 border border-indigo-500/50 rounded p-2">
                    <span className="font-bold text-indigo-300">{selectedRecipient.nome}</span>
                    <button type="button" onClick={handleResetRecipient} className="text-gray-400 hover:text-white px-2">✕</button>
                </div>
              ) : (
                <>
                  <input
                    type="text"
                    className="w-full bg-gray-900 border border-gray-700 rounded p-2 focus:ring-2 focus:ring-indigo-500 outline-none"
                    placeholder="Digita le iniziali (min 2 caratteri)..."
                    value={query}
                    onChange={(e) => setQuery(e.target.value)}
                  />
                  {results.length > 0 && (
                    <ul className="absolute z-10 w-full bg-gray-700 border border-gray-600 rounded mt-1 max-h-40 overflow-y-auto shadow-lg">
                      {results.map((pg) => (
                        <li 
                          key={pg.id} 
                          className="p-2 hover:bg-gray-600 cursor-pointer border-b border-gray-600 last:border-0"
                          onClick={() => handleSelect(pg)}
                        >
                          {pg.nome}
                        </li>
                      ))}
                    </ul>
                  )}
                </>
              )}
            </div>

            {/* Titolo */}
            <div>
              <label className="block text-sm font-medium text-gray-400 mb-1">Oggetto</label>
              <input
                type="text"
                className="w-full bg-gray-900 border border-gray-700 rounded p-2 focus:ring-2 focus:ring-indigo-500 outline-none"
                value={titolo}
                onChange={(e) => setTitolo(e.target.value)}
                maxLength={100}
              />
            </div>

            {/* Testo */}
            <div>
              <label className="block text-sm font-medium text-gray-400 mb-1">Messaggio</label>
              <textarea
                className="w-full bg-gray-900 border border-gray-700 rounded p-2 focus:ring-2 focus:ring-indigo-500 outline-none h-32"
                value={testo}
                onChange={(e) => setTesto(e.target.value)}
              />
            </div>

            <div className="flex justify-end gap-3 mt-6">
              <button 
                type="button" 
                onClick={onClose}
                className="px-4 py-2 rounded bg-gray-700 hover:bg-gray-600 transition-colors"
              >
                Annulla
              </button>
              <button 
                type="submit" 
                disabled={loading || !selectedRecipient}
                className={`px-4 py-2 rounded bg-indigo-600 hover:bg-indigo-500 font-bold transition-colors ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                {loading ? 'Invio...' : 'Invia Messaggio'}
              </button>
            </div>
          </form>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

export default ComposeMessageModal;

==================================================
FILE: src\components\EventoSection.jsx
==================================================
import React, { useState } from 'react';
import { 
    MapPin, Edit2, Trash2, Calendar, 
    Users, Star, UserPlus, X, ChevronDown, ChevronUp, ShieldCheck 
} from 'lucide-react';

const EventoSection = ({ evento, isMaster, risorse, onEdit, onDelete, onUpdateEvento, onAddGiorno }) => {
    const [showPartecipanti, setShowPartecipanti] = useState(false);

    if (!evento) return null;

    // Filtriamo i personaggi per mostrare solo i GIOCANTI (flag giocante: true) per le iscrizioni
    const personaggiGiocanti = risorse.png?.filter(p => p.giocante === true) || [];

    const handleListChange = async (fieldName, targetId, action) => {
        let currentList = evento[fieldName] || [];
        // Estraiamo gli ID se la lista contiene oggetti
        const currentIds = currentList.map(item => typeof item === 'object' ? item.id : item);
        
        let newIds;
        const targetIdInt = parseInt(targetId);
        
        if (action === 'add') {
            if (currentIds.includes(targetIdInt)) return;
            newIds = [...currentIds, targetIdInt];
        } else {
            newIds = currentIds.filter(id => id !== targetIdInt);
        }

        // Chiamata al backend per aggiornare la lista Many-to-Many
        onUpdateEvento(evento.id, { [fieldName]: newIds });
    };

    return (
        <div className="bg-indigo-900/10 border-b border-gray-800 p-6 space-y-6 shadow-inner">
            {/* Header Evento */}
            <div className="flex flex-col md:flex-row justify-between items-start gap-4">
                <div className="space-y-1">
                    <div className="flex items-center gap-3">
                        <h1 className="text-3xl font-black uppercase text-white tracking-tighter">{evento.titolo}</h1>
                        {isMaster && (
                            <button onClick={() => onEdit('evento', evento)} className="p-1.5 bg-gray-800 rounded-lg text-indigo-400 hover:text-white transition-colors">
                                <Edit2 size={18}/>
                            </button>
                        )}
                    </div>
                    
                    <div className="flex flex-wrap gap-4 text-[10px] font-bold uppercase text-gray-400 italic">
                        <span className="flex items-center gap-1"><MapPin size={12} className="text-indigo-400"/> {evento.luogo || 'Senza luogo'}</span>
                        <span className="flex items-center gap-1"><Calendar size={12} className="text-indigo-400"/> {new Date(evento.data_inizio).toLocaleDateString()}</span>
                        <span className="text-indigo-400 flex items-center gap-1"><Star size={12}/> {evento.pc_guadagnati} PC</span>
                    </div>
                </div>

                {isMaster && (
                    <div className="flex gap-2">
                        <button onClick={onAddGiorno} className="px-4 py-2 bg-emerald-600 text-white rounded-lg text-xs font-black uppercase shadow-lg hover:bg-emerald-500 transition-all">
                            + Giorno
                        </button>
                        <button onClick={() => onDelete(evento.id)} className="p-2 bg-red-900/20 text-red-500 border border-red-900/30 rounded-lg hover:bg-red-600 hover:text-white transition-all">
                            <Trash2 size={20}/>
                        </button>
                    </div>
                )}
            </div>

            <div 
                className="text-gray-300 text-sm italic border-l-2 border-indigo-500 pl-4 bg-indigo-500/5 py-2 ql-editor-view"
                dangerouslySetInnerHTML={{ __html: evento.sinossi }}
            />

            {/* SEZIONE STAFF (Sempre visibile) */}
            <div className="space-y-3 pt-2">
                <div className="flex items-center gap-2 text-[10px] font-black text-indigo-400 uppercase tracking-widest">
                    <ShieldCheck size={14}/> Staff Assegnato
                </div>
                <div className="flex flex-wrap gap-2">
                    {evento.staff_details?.map(user => (
                        <div key={user.id} className="flex items-center gap-2 bg-indigo-900/30 border border-indigo-500/30 px-2 py-1 rounded-full text-[11px]">
                            <span className="font-bold">{user.username}</span>
                            {isMaster && (
                                <button onClick={() => handleListChange('staff_assegnato', user.id, 'remove')} className="text-indigo-400 hover:text-red-400">
                                    <X size={12}/>
                                </button>
                            )}
                        </div>
                    ))}
                    {isMaster && (
                        <select 
                            className="bg-gray-900 border border-gray-700 rounded text-[10px] p-1 outline-none focus:border-indigo-500"
                            onChange={(e) => {
                                if(e.target.value) handleListChange('staff_assegnato', e.target.value, 'add');
                                e.target.value = "";
                            }}
                        >
                            <option value="">Aggiungi Staff...</option>
                            {risorse.staff?.filter(s => !(evento.staff_assegnato || []).includes(s.id)).map(s => (
                                <option key={s.id} value={s.id}>{s.username}</option>
                            ))}
                        </select>
                    )}
                </div>
            </div>

            {/* SEZIONE PARTECIPANTI (Collassabile) */}
            <div className="border-t border-gray-800/50 pt-4">
                <button 
                    onClick={() => setShowPartecipanti(!showPartecipanti)}
                    className="flex items-center justify-between w-full text-[10px] font-black text-gray-500 uppercase tracking-widest hover:text-gray-300 transition-colors"
                >
                    <div className="flex items-center gap-2">
                        <Users size={14}/> Partecipanti ({evento.partecipanti?.length || 0})
                    </div>
                    {showPartecipanti ? <ChevronUp size={16}/> : <ChevronDown size={16}/>}
                </button>

                {showPartecipanti && (
                    <div className="mt-4 space-y-4 animate-in fade-in slide-in-from-top-1 duration-200">
                        <div className="flex flex-wrap gap-2">
                            {evento.partecipanti_details?.map(char => (
                                <div key={char.id} className="flex items-center gap-2 bg-gray-800 border border-gray-700 px-2 py-1 rounded text-[11px]">
                                    <span>{char.nome}</span>
                                    {isMaster && (
                                        <button onClick={() => handleListChange('partecipanti', char.id, 'remove')} className="text-gray-500 hover:text-red-500">
                                            <X size={12}/>
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>

                        {isMaster && (
                            <div className="flex items-center gap-2 bg-gray-950/50 p-3 rounded-xl border border-gray-800">
                                <UserPlus size={14} className="text-emerald-500"/>
                                <select 
                                    className="bg-transparent text-[11px] text-gray-400 outline-none flex-1"
                                    onChange={(e) => {
                                        if(e.target.value) handleListChange('partecipanti', e.target.value, 'add');
                                        e.target.value = "";
                                    }}
                                >
                                    <option value="">Iscrivi un Personaggio Giocante...</option>
                                    {personaggiGiocanti.map(p => (
                                        <option key={p.id} value={p.id}>{p.nome}</option>
                                    ))}
                                </select>
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
};

export default EventoSection;

==================================================
FILE: src\components\ForgingModal.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { X, Hammer, ShieldAlert, Check, Loader2, Coins, Send, Clock } from 'lucide-react';
import { useCharacter } from './CharacterContext';
import { forgiaOggetto, getCapableArtisans, createForgingRequest, validateForging } from '../api';

const ForgingModal = ({ infusione, onClose, onRefresh }) => {
  const { selectedCharacterData } = useCharacter();
  
  const [canForgeSelf, setCanForgeSelf] = useState(false);
  const [validationMsg, setValidationMsg] = useState('');
  const [capableArtisans, setCapableArtisans] = useState([]);
  const [isLoadingInfo, setIsLoadingInfo] = useState(true);
  
  const [selectedTarget, setSelectedTarget] = useState(''); // ''=Self (if allowed), or ArtisanID/ACADEMY
  const [offerCredits, setOfferCredits] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);
  const [msg, setMsg] = useState({ type: '', text: '' });

  // INITIAL CHECK
  useEffect(() => {
    const loadData = async () => {
      setIsLoadingInfo(true);
      try {
        // 1. Controlla se IO ho i requisiti
        const valData = await validateForging(selectedCharacterData.id, infusione.id);
        
        if (valData.can_forge) {
            // CASO A: Ho i requisiti -> Posso forgiare solo io.
            setCanForgeSelf(true);
        } else {
            // CASO B: Non ho i requisiti -> Devo chiedere aiuto.
            setCanForgeSelf(false);
            setValidationMsg(valData.reason || "Requisiti mancanti.");
            
            // Carica gli artigiani solo se serve aiuto
            const artisans = await getCapableArtisans(selectedCharacterData.id, null, null, infusione.id);
            setCapableArtisans(artisans || []);
        }
      } catch (e) {
        console.error(e);
        setMsg({ type: 'error', text: "Errore di comunicazione col server." });
      } finally {
        setIsLoadingInfo(false);
      }
    };
    loadData();
  }, [infusione, selectedCharacterData]);

  const handleExecute = async () => {
    setIsProcessing(true);
    setMsg({});
    
    try {
      if (canForgeSelf) {
         // FAI DA TE (Timer standard)
         await forgiaOggetto(infusione.id, selectedCharacterData.id, false);
         setMsg({ type: 'success', text: 'Forgiatura avviata! Controlla la coda.' });
      } else {
         // AIUTO ESTERNO
         if (selectedTarget === 'ACADEMY') {
             // Accademia
             await forgiaOggetto(infusione.id, selectedCharacterData.id, true);
             setMsg({ type: 'success', text: 'Forgiatura Accademia avviata!' });
         } else if (selectedTarget) {
             // Artigiano
             const art = capableArtisans.find(a => a.id == selectedTarget);
             await createForgingRequest(selectedCharacterData.id, infusione.id, art.nome, offerCredits);
             setMsg({ type: 'success', text: `Richiesta inviata a ${art.nome}!` });
         } else {
             throw new Error("Seleziona un metodo.");
         }
      }
      
      setTimeout(() => { onRefresh(); onClose(); }, 2000);
    } catch (err) {
      setMsg({ type: 'error', text: err.message || "Operazione fallita" });
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50">
       <div className="bg-gray-800 rounded-xl max-w-md w-full p-6 border border-gray-600 shadow-xl animate-fadeIn">
          
          <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
              <h3 className="text-xl font-bold text-white flex gap-2 items-center">
                  <Hammer className="text-amber-500" size={20}/> 
                  Forgia: {infusione.nome}
              </h3>
              <button onClick={onClose} className="text-gray-400 hover:text-white"><X/></button>
          </div>

          {isLoadingInfo ? (
              <div className="py-8 text-center text-gray-400"><Loader2 className="animate-spin inline mr-2"/> Analisi requisiti...</div>
          ) : (
              <div className="space-y-5">
                  
                  {/* FEEDBACK REQUISITI */}
                  {canForgeSelf ? (
                      <div className="bg-emerald-900/20 border border-emerald-700/50 p-3 rounded flex gap-3 items-center">
                          <Check className="text-emerald-500" size={24}/>
                          <div>
                              <h4 className="font-bold text-emerald-400 text-sm">Autosufficiente</h4>
                              <p className="text-emerald-200/70 text-xs">Hai tutti i requisiti. Procedi con la forgiatura.</p>
                          </div>
                      </div>
                  ) : (
                      <div className="bg-amber-900/20 border border-amber-700/50 p-3 rounded flex gap-3 items-center">
                          <ShieldAlert className="text-amber-500" size={24}/>
                          <div>
                              <h4 className="font-bold text-amber-400 text-sm">Requisiti Mancanti</h4>
                              <p className="text-amber-200/70 text-xs">{validationMsg}</p>
                          </div>
                      </div>
                  )}

                  {/* SELETTORE METODO (Solo se NON autosufficiente) */}
                  {!canForgeSelf && (
                      <div>
                          <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Chiedi Aiuto</label>
                          <select 
                              className="w-full bg-gray-900 border-gray-600 text-white rounded p-2 focus:border-indigo-500 outline-none"
                              value={selectedTarget} 
                              onChange={e => setSelectedTarget(e.target.value)}
                          >
                              <option value="">-- Seleziona Chi Esegue --</option>
                              <option value="ACADEMY">🏛️ Accademia (200 CR)</option>
                              {capableArtisans.length > 0 && (
                                  <optgroup label="Artigiani Disponibili">
                                      {capableArtisans.map(a => (
                                          <option key={a.id} value={a.id}>👤 {a.nome}</option>
                                      ))}
                                  </optgroup>
                              )}
                          </select>
                      </div>
                  )}

                  {/* INPUT OFFERTA (Solo se Artigiano selezionato) */}
                  {selectedTarget && selectedTarget !== 'ACADEMY' && !canForgeSelf && (
                      <div className="animate-fadeIn">
                          <label className="block text-xs font-bold text-gray-400 mb-1">Offerta all'Artigiano (CR)</label>
                          <div className="relative">
                              <Coins className="absolute left-3 top-2.5 text-yellow-500" size={16}/>
                              <input 
                                  type="number" 
                                  className="w-full bg-gray-900 border-gray-600 text-white rounded p-2 pl-10 focus:border-yellow-500 outline-none"
                                  value={offerCredits} 
                                  onChange={e=>setOfferCredits(e.target.value)} 
                                  placeholder="0"
                              />
                          </div>
                      </div>
                  )}
                  
                  {/* MESSAGGI STATO */}
                  {msg.text && (
                      <div className={`p-3 rounded text-sm border flex items-center gap-2 ${msg.type === 'error' ? 'bg-red-900/20 border-red-800 text-red-300' : 'bg-emerald-900/20 border-emerald-800 text-emerald-300'}`}>
                          {msg.type === 'error' ? <ShieldAlert size={16}/> : <Check size={16}/>}
                          {msg.text}
                      </div>
                  )}

                  {/* BOTTONE AZIONE */}
                  <button 
                      onClick={handleExecute} 
                      disabled={isProcessing || (!canForgeSelf && !selectedTarget)}
                      className={`
                          w-full py-2.5 rounded-lg font-bold flex justify-center items-center gap-2 transition-all
                          disabled:opacity-50 disabled:cursor-not-allowed
                          ${selectedTarget === 'ACADEMY' 
                              ? 'bg-yellow-600 hover:bg-yellow-500 text-white' 
                              : 'bg-emerald-600 hover:bg-emerald-500 text-white'}
                      `}
                  >
                      {isProcessing ? <Loader2 className="animate-spin"/> : (
                          selectedTarget === 'ACADEMY' ? <Coins size={18}/> : 
                          (canForgeSelf ? <Hammer size={18}/> : <Send size={18}/>)
                      )}
                      
                      {canForgeSelf 
                          ? 'Inizia Forgiatura (Fai da te)' 
                          : (selectedTarget === 'ACADEMY' ? 'Paga 200 CR e Avvia' : 'Invia Richiesta')}
                  </button>
              </div>
          )}
       </div>
    </div>
  );
};

export default ForgingModal;

==================================================
FILE: src\components\ForgingQueue.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { Loader2, Hammer, CheckCircle, Clock, User, Trash2 } from 'lucide-react';
import { completeForging } from '../api';
import { useCharacter } from './CharacterContext';
import GraftInstallationModal from './GraftInstallationModal'; // Assicurati che il percorso sia corretto

const ForgingItem = ({ item, onComplete, onOpenGraftModal, currentCharacterId }) => {
  // ... (tutto il codice timer esistente rimane uguale) ...
  const [timeLeft, setTimeLeft] = useState(item.secondi_rimanenti);
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    // ... (logica timer identica a prima) ...
    const calculateTimeLeft = () => {
        const now = new Date();
        const end = new Date(item.data_fine);
        const diff = Math.max(0, (end - now) / 1000);
        return diff;
    };
    setTimeLeft(calculateTimeLeft());
    const interval = setInterval(() => {
      const remaining = calculateTimeLeft();
      setTimeLeft(remaining);
      if (remaining <= 0) clearInterval(interval);
    }, 1000);
    return () => clearInterval(interval);
  }, [item.data_fine]);

  // Logica differenziata per il Click
  const handleClick = () => {
      // Se ha slot permessi, è un innesto/mutazione -> APRI MODALE
      if (item.infusione_slot_permessi && item.infusione_slot_permessi.length > 0) {
          onOpenGraftModal(item);
      } else {
          // Altrimenti comportamento standard
          handleCollect();
      }
  };

  const handleCollect = async () => {
    setIsProcessing(true);
    try {
        await onComplete(item.id);
    } catch (e) {
        setIsProcessing(false);
    }
  };

  const isReady = timeLeft <= 0;
  const canCollect = item.can_collect !== undefined ? item.can_collect : true;

  // Format MM:SS
  const formatTime = (seconds) => {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  };

  return (
    <div className="bg-gray-800 border border-gray-700 p-3 rounded-lg flex items-center justify-between shadow-sm animate-fadeIn hover:bg-gray-750 transition-colors">
      <div className="flex items-center gap-3">
         {/* ... (Parte visiva identica a prima) ... */}
         <div className={`p-2 rounded-full ${isReady ? 'bg-green-900/30 text-green-400' : 'bg-amber-900/30 text-amber-500'}`}>
            {isReady ? <CheckCircle size={20} /> : <Hammer size={20} className={timeLeft > 0 ? "animate-pulse" : ""} />}
        </div>
        <div>
            <h4 className="font-bold text-gray-200 text-sm">{item.infusione_nome}</h4>
            {item.info_extra && (
                <div className="text-xs text-indigo-300 flex items-center gap-1 mt-0.5 font-medium">
                    <User size={12}/> {item.info_extra}
                </div>
            )}
            <div className="text-xs text-gray-400 mt-1 flex items-center gap-1">
                <Clock size={12}/>
                {isReady ? (
                    <span className="text-green-400 font-bold">Completato</span>
                ) : (
                    <span>Termina in: <span className="font-mono text-gray-300">{formatTime(timeLeft)}</span></span>
                )}
            </div>
        </div>
      </div>

      {isReady ? (
          canCollect ? (
            <button
                onClick={handleClick} // <--- CAMBIATO QUI
                disabled={isProcessing}
                className="px-4 py-1.5 rounded text-xs font-bold transition-all bg-green-600 hover:bg-green-500 text-white shadow-lg shadow-green-900/20 flex items-center gap-2 active:scale-95 disabled:opacity-50"
            >
                {isProcessing ? <Loader2 className="animate-spin" size={14} /> : "Ritira/Installa"}
            </button>
          ) : (
            <span className="text-xs text-gray-500 italic px-2 bg-gray-900/50 py-1 rounded">
                In attesa ritiro cliente
            </span>
          )
      ) : (
        <div className="text-gray-500 text-xs italic px-2">In lavorazione</div>
      )}
    </div>
  );
};

const ForgingQueue = ({ queue, refetchQueue }) => {
  const { selectedCharacterId, refreshCharacterData } = useCharacter();
  
  // Stato per la modale
  const [selectedGraftTask, setSelectedGraftTask] = useState(null);

  const handleCompleteStandard = async (forgiaturaId) => {
    try {
        await completeForging(forgiaturaId, selectedCharacterId);
        await Promise.all([refetchQueue(), refreshCharacterData()]);
    } catch (error) {
        alert("Errore nel ritiro: " + error.message);
    }
  };

  const handleGraftSuccess = async () => {
      // Chiamato quando la modale finisce con successo
      setSelectedGraftTask(null);
      await Promise.all([refetchQueue(), refreshCharacterData()]);
  };

  if (!queue || queue.length === 0) return null;

  return (
    <>
        <div className="mb-6 bg-gray-800/50 border border-gray-700 rounded-lg p-4 shadow-lg">
            <h3 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-3 flex items-center gap-2 border-b border-gray-700 pb-2">
                <Hammer size={16} className="text-amber-500"/> 
                Coda di Forgiatura <span className="text-gray-600">({queue.length})</span>
            </h3>
            
            <div className="space-y-2">
                {queue.map(item => (
                    <ForgingItem 
                        key={item.id} 
                        item={item} 
                        onComplete={handleCompleteStandard} 
                        onOpenGraftModal={setSelectedGraftTask} // <--- Passiamo il setter
                        currentCharacterId={selectedCharacterId}
                    />
                ))}
            </div>
        </div>

        {/* MODALE INNESTO */}
        {selectedGraftTask && (
            <GraftInstallationModal 
                task={selectedGraftTask}
                onClose={() => setSelectedGraftTask(null)}
                onSuccess={handleGraftSuccess}
            />
        )}
    </>
  );
};

export default ForgingQueue;

==================================================
FILE: src\components\GameTab.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { useCharacter } from './CharacterContext';
import { 
    Heart, Zap, Crosshair, Clock, Battery, RefreshCw, 
    Star, MessageSquare, Briefcase, Backpack, AlertCircle, Plus, Minus,
    ChevronDown, ChevronUp, Hexagon, Activity, Weight 
} from 'lucide-react';

import { 
    useOptimisticStatChange, 
} from '../hooks/useGameData';

import ActiveItemWidget from './ActiveItemWidget'; 

// --- WIDGET DANNI (Aggiornato per PS - Punti Guscio) ---
const BodyDamageWidget = ({ stats, maxHp, maxArmor, maxShell, onHit }) => {
    // Zone del corpo
    const zones = [
        { id: 'PV_TR', name: 'Tronco', d: "M70,55 C70,55 85,65 100,65 C115,65 130,55 130,55 C135,65 135,80 130,130 C120,145 80,145 70,130 C65,80 65,65 70,55 Z", cx: 100, cy: 90 },
        { id: 'PV_RA', name: 'Braccio Dx', d: "M132,55 C145,52 155,58 155,70 C155,90 150,110 160,135 C162,140 150,145 145,135 C135,110 135,90 132,80 Z", cx: 145, cy: 95 },
        { id: 'PV_LA', name: 'Braccio Sx', d: "M68,55 C55,52 45,58 45,70 C45,90 50,110 40,135 C38,140 50,145 55,135 C65,110 65,90 68,80 Z", cx: 55, cy: 95 },
        { id: 'PV_RL', name: 'Gamba Dx', d: "M105,135 C115,135 125,140 125,150 C125,180 128,210 125,240 C120,250 140,255 130,260 C110,260 110,240 110,220 C110,190 102,150 105,135 Z", cx: 120, cy: 190 },
        { id: 'PV_LL', name: 'Gamba Sx', d: "M95,135 C85,135 75,140 75,150 C75,180 72,210 75,240 C80,250 60,255 70,260 C90,260 90,240 90,220 C90,190 98,150 95,135 Z", cx: 80, cy: 190 },
    ];




    const getZoneColor = (current) => {
        if (current <= 0) return '#ef4444';
        if (current < maxHp / 2) return '#eab308';
        return '#3b82f6';
    };

    // Calcolo opacità barre
    const armorOpacity = maxArmor > 0 ? (stats['PA_CUR'] / maxArmor) : 0;
    const shellOpacity = maxShell > 0 ? (stats['PS_CUR'] / maxShell) : 0;

    return (
        <div className="relative w-full max-w-[280px] mx-auto aspect-3/4 select-none">
            <svg viewBox="0 0 200 280" className="w-full h-full drop-shadow-2xl">
                <defs>
                    <filter id="glow-shell" x="-20%" y="-20%" width="140%" height="140%">
                        <feGaussianBlur stdDeviation="3" result="blur" />
                        <feComposite in="SourceGraphic" in2="blur" operator="over" />
                    </filter>
                </defs>

                {/* LAYER 1: GUSCIO (PS) */}
                <g 
                    opacity={Math.max(0.1, shellOpacity)} 
                    className="transition-all duration-500"
                    style={{ pointerEvents: maxShell > 0 ? 'auto' : 'none', cursor: maxShell > 0 ? 'pointer' : 'default' }}
                    onClick={() => maxShell > 0 && onHit('PS_CUR', maxShell)}
                    filter="url(#glow-shell)"
                >
                    <ellipse cx="100" cy="130" rx="90" ry="140" fill="transparent" stroke="#8b5cf6" strokeWidth="3" strokeDasharray={shellOpacity === 0 ? "4 4" : "0"} />
                    {maxShell > 0 && <text x="100" y="15" fill="#a78bfa" fontSize="10" textAnchor="middle" fontWeight="bold">GUSCIO {stats['PS_CUR']}/{maxShell}</text>}
                </g>

                {/* LAYER 2: ARMATURA (PA) */}
                <g 
                    opacity={Math.max(0.1, armorOpacity)} 
                    className="transition-all duration-500"
                    style={{ pointerEvents: maxArmor > 0 ? 'auto' : 'none', cursor: maxArmor > 0 ? 'pointer' : 'default' }}
                    onClick={() => maxArmor > 0 && onHit('PA_CUR', maxArmor)}
                >
                    <path d="M100,15 C130,15 165,50 165,130 C165,220 140,265 100,265 C60,265 35,220 35,130 C35,50 70,15 100,15 Z" fill="rgba(16, 185, 129, 0.1)" stroke="#10b981" strokeWidth="2" strokeDasharray={armorOpacity === 0 ? "2 2" : "0"} />
                    {maxArmor > 0 && <text x="100" y="275" fill="#34d399" fontSize="10" textAnchor="middle" fontWeight="bold">ARM {stats['PA_CUR']}/{maxArmor}</text>}
                </g>

                {/* LAYER 3: CORPO */}
                <g className="filter drop-shadow-md">
                    <circle cx="100" cy="35" r="18" fill="#4b5563" stroke="#9ca3af" />
                    {zones.map(z => {
                        const val = stats[z.id];
                        return (
                            <g key={z.id} onClick={() => onHit(z.id, maxHp)} className="cursor-pointer hover:opacity-80 transition-opacity">
                                <path d={z.d} fill={getZoneColor(val)} stroke="rgba(255,255,255,0.4)" strokeWidth="1" strokeLinejoin="round" />
                                <text x={z.cx} y={z.cy} fill="white" fontSize="10" textAnchor="middle" pointerEvents="none" fontWeight="bold" style={{textShadow: '0px 1px 2px black'}}>{val}</text>
                            </g>
                        );
                    })}
                </g>
            </svg>
            {stats['PV_TR'] <= 0 && (
                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-red-900/90 text-white px-4 py-2 rounded-xl border-2 border-red-500 animate-pulse text-center shadow-2xl z-20">
                    <AlertCircle className="mx-auto mb-1 text-red-400" />
                    <span className="font-black text-lg uppercase tracking-widest">COMA</span>
                </div>
            )}
        </div>
    );
};

const DamageControlPanel = ({ stats, maxHp, maxArmor, maxShell, onChange }) => {
    const [isOpen, setIsOpen] = useState(false);

    const rows = [
        { id: 'PS_CUR', label: 'Guscio (PS)', max: maxShell, color: 'text-purple-400' },
        { id: 'PA_CUR', label: 'Armatura', max: maxArmor, color: 'text-emerald-400' },
        { id: 'PV_TR', label: 'Tronco', max: maxHp, color: 'text-blue-400' },
        { id: 'PV_RA', label: 'Br. Dx', max: maxHp, color: 'text-blue-300' },
        { id: 'PV_LA', label: 'Br. Sx', max: maxHp, color: 'text-blue-300' },
        { id: 'PV_RL', label: 'Gb. Dx', max: maxHp, color: 'text-blue-300' },
        { id: 'PV_LL', label: 'Gb. Sx', max: maxHp, color: 'text-blue-300' },
    ];

    return (
        <div className="bg-gray-800 rounded-xl border border-gray-700 overflow-hidden">
            <button onClick={() => setIsOpen(!isOpen)} className="w-full flex justify-between items-center p-3 bg-gray-900/50 hover:bg-gray-700 transition-colors">
                <span className="text-xs font-bold uppercase tracking-wider text-gray-400 flex items-center gap-2"><Crosshair size={14}/> Controlli Manuali</span>
                {isOpen ? <ChevronUp size={16}/> : <ChevronDown size={16}/>}
            </button>
            {isOpen && (
                <div className="p-2 space-y-1 animate-in slide-in-from-top-2">
                    {rows.map(r => {
                        if (r.max <= 0 && (r.id === 'PS_CUR' || r.id === 'PA_CUR')) return null;
                        const val = stats[r.id];
                        return (
                            <div key={r.id} className="flex items-center justify-between bg-gray-900/30 p-2 rounded">
                                <span className={`text-xs font-bold ${r.color} w-20`}>{r.label}</span>
                                <div className="flex items-center gap-2">
                                    <span className="text-xs font-mono text-white w-8 text-right">{val}/{r.max}</span>
                                    <div className="flex gap-1">
                                        <button onClick={() => onChange(r.id, 'add', r.max)} className="p-1 bg-green-900/50 hover:bg-green-700 rounded text-green-200"><Plus size={12}/></button>
                                        <button onClick={() => onChange(r.id, 'consuma', r.max)} className="p-1 bg-red-900/50 hover:bg-red-700 rounded text-red-200"><Minus size={12}/></button>
                                        <button onClick={() => onChange(r.id, 'reset', r.max)} className="p-1 bg-blue-900/50 hover:bg-blue-700 rounded text-blue-200"><RefreshCw size={12}/></button>
                                    </div>
                                </div>
                            </div>
                        )
                    })}
                </div>
            )}
        </div>
    );
};

const ChakraWidget = ({ current, max, onChange }) => {
    return (
        <div className="bg-gray-800 rounded-xl p-3 border border-gray-700 shadow-md">
            <div className="flex justify-between items-center mb-2">
                <span className="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2"><Hexagon size={12} className="text-pink-500" /> Chakra</span>
                <div className="flex gap-2">
                    <button onClick={() => onChange('CHK_CUR', 'add', max)} className="text-xs text-green-400 hover:text-green-300 font-bold px-2 bg-green-900/20 rounded">+1</button>
                    <button onClick={() => onChange('CHK_CUR', 'reset', max)} className="text-gray-500 hover:text-white"><RefreshCw size={12}/></button>
                </div>
            </div>
            <div className="flex flex-wrap gap-1.5">
                {[...Array(max)].map((_, i) => (
                    <button key={i} onClick={() => onChange('CHK_CUR', 'consuma', max)} disabled={i >= current} className={`w-5 h-5 rounded-full border flex items-center justify-center transition-all ${i < current ? 'bg-pink-600 border-pink-400 shadow-[0_0_8px_#db2777] scale-100' : 'bg-gray-900 border-gray-700 scale-90 opacity-50'}`}>
                        {i < current && <div className="w-1.5 h-1.5 bg-white rounded-full animate-pulse" />}
                    </button>
                ))}
            </div>
            <div className="text-right mt-1 text-[9px] text-gray-500 font-mono">{current} / {max}</div>
        </div>
    );
};

const CapacityDashboard = ({ capacityUsed, capacityMax, capacityConsumers, heavyUsed, heavyMax, heavyConsumers }) => {
    const isOverloaded = capacityUsed > capacityMax;
    const isHeavyOverloaded = heavyUsed > heavyMax;

    return (
        <div className="w-full bg-gray-800 rounded-xl border border-gray-700 p-3 shadow-md mb-4 flex flex-col md:flex-row gap-4">
            <div className={`flex-1 flex flex-col gap-2 p-2 rounded-lg border bg-gray-900/30 ${isOverloaded ? 'border-red-500/50 bg-red-900/10' : 'border-gray-700/50'}`}>
                <div className="flex justify-between items-center border-b border-gray-700/50 pb-1">
                    <span className="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2"><Backpack size={12} className="text-indigo-400"/> Oggetti Speciali (COG)</span>
                    <span className={`text-xs font-bold font-mono ${isOverloaded ? 'text-red-400' : 'text-indigo-400'}`}>{capacityUsed} / {capacityMax}</span>
                </div>
                <div className="flex flex-wrap gap-1.5">
                    {capacityConsumers.length > 0 ? capacityConsumers.map((item) => (
                        <div key={item.id} className="flex items-center gap-1.5 bg-gray-800 px-2 py-1 rounded border border-gray-600 shadow-sm"><div className="w-1.5 h-1.5 rounded-full bg-indigo-500 shrink-0"></div><span className="text-[10px] text-gray-300 truncate font-mono max-w-[120px]">{item.nome}</span></div>
                    )) : <span className="text-[10px] text-gray-600 italic px-1">Nessuno</span>}
                </div>
            </div>
            <div className={`flex-1 flex flex-col gap-2 p-2 rounded-lg border bg-gray-900/30 ${isHeavyOverloaded ? 'border-orange-500/50 bg-orange-900/10' : 'border-gray-700/50'}`}>
                <div className="flex justify-between items-center border-b border-gray-700/50 pb-1">
                    <span className="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2"><Weight size={12} className="text-orange-400"/> Oggetti Pesanti (OGP)</span>
                    <span className={`text-xs font-bold font-mono ${isHeavyOverloaded ? 'text-orange-400' : 'text-green-400'}`}>{heavyUsed} / {heavyMax}</span>
                </div>
                <div className="flex flex-wrap gap-1.5">
                    {heavyConsumers.length > 0 ? heavyConsumers.map((item) => (
                        <div key={item.id} className="flex items-center gap-1.5 bg-gray-800 px-2 py-1 rounded border border-gray-600 shadow-sm"><div className="w-1.5 h-1.5 rounded-full bg-orange-500 shrink-0"></div><span className="text-[10px] text-gray-300 truncate font-mono max-w-[120px]">{item.nome}</span></div>
                    )) : <span className="text-[10px] text-gray-600 italic px-1">Carico leggero</span>}
                </div>
            </div>
        </div>
    );
};

// --- MAIN GAMETAB ---
const GameTab = ({ onNavigate }) => {
    const { selectedCharacterData: char, unreadCount, updateCharacter, fetchCharacterData } = useCharacter();
    const [favorites, setFavorites] = useState([]);
    
    const statMutation = useOptimisticStatChange();

    useEffect(() => {
        const savedFavs = JSON.parse(localStorage.getItem('kor35_favorites') || '[]');
        setFavorites(savedFavs);
    }, []);

    // --- FUNZIONI HELPER PER VISUALIZZAZIONE ---
    const isActiveByTime = (item) => {
        if (!item.data_fine_attivazione) return true;
        const now = new Date().getTime();
        const end = new Date(item.data_fine_attivazione).getTime();
        return end >= now;
    };

    const isActiveByCharges = (item) => {
        if (item.spegne_a_zero_cariche) {
             const hasCharges = (item.cariche_attuali || 0) > 0;
             if (!hasCharges && !isActiveByTime(item)) return false;
        }
        return true;
    };

    // --- FILTRO OGGETTI ATTIVI (LOGICA GAME TAB) ---
    const activeItems = useMemo(() => {
        // Protezione anti-crash: se char non è ancora caricato, ritorna array vuoto
        if (!char || !char.oggetti) return [];
        
        const activatables = [];

        // 1. Identifica gli Host Attivi (Equipaggiati o Installati)
        const activeHosts = char.oggetti.filter(item => {
             const isPhysEquipped = (item.tipo_oggetto === 'FIS' && item.is_equipaggiato);
             const isInnateInstalled = (['INN', 'MUT'].includes(item.tipo_oggetto) && item.slot_corpo);
             return isPhysEquipped || isInnateInstalled;
        });

        // 2. Estrai tutto ciò che è attivabile (Host e le loro Mod)
        activeHosts.forEach(host => {
             // A. Aggiungi l'Host se ha meccaniche proprie (cariche/durata)
             if (host.cariche_massime > 0 || host.durata_totale > 0) {
                 activatables.push(host);
             }

             // B. Aggiungi i Potenziamenti (Mod/Materia) installati nell'Host
             if (host.potenziamenti_installati && host.potenziamenti_installati.length > 0) {
                 host.potenziamenti_installati.forEach(mod => {
                     if (mod.cariche_massime > 0 || mod.durata_totale > 0) {
                         activatables.push(mod);
                     }
                 });
             }
        });

        return activatables;
    }, [char]); // Dipendenza da 'char' completa

    // --- FILTRO ARMI (CON PROTEZIONE CRASH) ---
    const weapons = (char && char.oggetti) 
        ? char.oggetti.filter(i => 
            i.is_equipaggiato && 
            i.attacco_base && 
            isActiveByCharges(i)
          ) 
        : [];

    const handleStatChange = (key, mode, maxOverride) => {
        statMutation.mutate({ charId: char.id, stat_sigla: key, mode, max_override: maxOverride || 0 });
    };

    const toggleFavorite = (item) => {
        let newFavs;
        if (favorites.find(f => f.id === item.id)) {
            newFavs = favorites.filter(f => f.id !== item.id);
        } else {
            newFavs = [...favorites, { id: item.id, nome: item.nome, testo: item.TestoFormattato }];
        }
        setFavorites(newFavs);
        localStorage.setItem('kor35_favorites', JSON.stringify(newFavs));
    };

    if (!char) return <div className="p-8 text-center text-white">Caricamento...</div>;

    // Statistiche Tattiche
    const maxHP = char.statistiche_primarie?.find(x => x.sigla === 'PV')?.valore_max || 0;
    const maxArmor = char.statistiche_primarie?.find(x => x.sigla === 'PA')?.valore_max || 0;
    const maxShell = char.statistiche_primarie?.find(x => x.sigla === 'PS')?.valore_max || 0;
    const maxChakra = char.statistiche_primarie?.find(x => x.sigla === 'CHA')?.valore_max || 1;

    const tempStats = char.statistiche_temporanee || {};
    const tacticalStats = {
        'PV_TR': tempStats['PV_TR'] !== undefined ? tempStats['PV_TR'] : maxHP,
        'PV_RA': tempStats['PV_RA'] !== undefined ? tempStats['PV_RA'] : maxHP,
        'PV_LA': tempStats['PV_LA'] !== undefined ? tempStats['PV_LA'] : maxHP,
        'PV_RL': tempStats['PV_RL'] !== undefined ? tempStats['PV_RL'] : maxHP,
        'PV_LL': tempStats['PV_LL'] !== undefined ? tempStats['PV_LL'] : maxHP,
        'PA_CUR': tempStats['PA_CUR'] !== undefined ? tempStats['PA_CUR'] : maxArmor,
        'PS_CUR': tempStats['PS_CUR'] !== undefined ? tempStats['PS_CUR'] : maxShell,
        'CHK_CUR': tempStats['CHK_CUR'] !== undefined ? tempStats['CHK_CUR'] : maxChakra,
    };

    // Logica Capacità
    const statCog = char.statistiche_primarie?.find(s => s.sigla === 'COG');
    const capacityMax = statCog ? statCog.valore_max : 10;
    const capacityConsumers = char.oggetti.filter(i => i.is_equipaggiato && i.tipo_oggetto === 'FIS' && i.potenziamenti_installati?.length > 0);
    const capacityUsed = capacityConsumers.length;
    
    const statOgp = char.statistiche_primarie?.find(s => s.sigla === 'OGP');
    const heavyMax = statOgp ? statOgp.valore_max : 0;
    const heavyConsumers = char.oggetti.filter(i => i.is_equipaggiato && i.is_pesante);
    const heavyUsed = heavyConsumers.length;

    return (
        <div className="pb-24 px-2 space-y-6 animate-fadeIn text-gray-100 pt-2">
            
            <CapacityDashboard 
                capacityUsed={capacityUsed} capacityMax={capacityMax} capacityConsumers={capacityConsumers}
                heavyUsed={heavyUsed} heavyMax={heavyMax} heavyConsumers={heavyConsumers}
            />

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="bg-gray-900 rounded-xl p-4 border border-gray-700 shadow-lg flex flex-col items-center">
                    <h3 className="text-[10px] uppercase tracking-widest text-gray-500 mb-3 font-bold w-full flex items-center gap-2"><Activity size={12} /> Status Fisico</h3>
                    <BodyDamageWidget stats={tacticalStats} maxHp={maxHP} maxArmor={maxArmor} maxShell={maxShell} onHit={(id, max) => handleStatChange(id, 'consuma', max)} />
                </div>
                <div className="flex flex-col gap-4">
                    <DamageControlPanel stats={tacticalStats} maxHp={maxHP} maxArmor={maxArmor} maxShell={maxShell} onChange={handleStatChange} />
                    {(maxChakra > 0) && <ChakraWidget current={tacticalStats['CHK_CUR']} max={maxChakra} onChange={handleStatChange} />}
                </div>
            </div>

            {/* 2. ATTACCHI BASE + MOD */}
            {weapons.length > 0 && (
                <section>
                    <h3 className="text-[10px] uppercase tracking-widest text-red-400 mb-2 font-bold flex items-center gap-2 ml-1">
                        <Crosshair size={12} /> Attacchi
                    </h3>
                    <div className="grid grid-cols-1 gap-2">
                        {weapons.map(w => (
                            <div key={w.id} className="bg-linear-to-r from-red-900/20 to-gray-900/20 border border-red-500/30 p-3 rounded-lg shadow-sm">
                                <div className="flex justify-between items-start mb-2">
                                    <div>
                                        <div className="font-bold text-red-100 text-sm flex items-center gap-2">
                                            {w.nome}
                                            {w.is_pesante && <Weight size={12} className="text-orange-500" title="Oggetto Pesante"/>}
                                        </div>
                                        <div className="text-[10px] text-red-300/60 uppercase">{w.tipo_oggetto_display}</div>
                                    </div>
                                    <div className="text-right">
                                         <div className="text-lg font-mono font-bold text-red-400 drop-shadow-sm">
                                             {w.attacco_formattato || w.attacco_base}
                                         </div>
                                    </div>
                                </div>

                                {w.potenziamenti_installati && w.potenziamenti_installati.some(m => m.attacco_base) && (
                                    <div className="mt-2 space-y-1">
                                        {w.potenziamenti_installati
                                            .filter(m => m.attacco_base)
                                            .filter(m => isActiveByTime(m))
                                            .map(mod => (
                                            <div key={mod.id} className="flex justify-between items-center bg-black/30 rounded px-2 py-1 border-l-2 border-yellow-500">
                                                <div className="flex items-center gap-2">
                                                    <Zap size={10} className="text-yellow-500" />
                                                    <span className="text-xs text-gray-300 font-medium">{mod.nome}</span>
                                                </div>
                                                <span className="font-mono text-xs font-bold text-yellow-100">
                                                    {mod.attacco_formattato || mod.attacco_base}
                                                </span>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </section>
            )}

            {/* 3. DISPOSITIVI ATTIVI (Ora mostra tutto) */}
            <section>
                <h3 className="text-[10px] uppercase tracking-widest text-emerald-400 font-bold flex items-center gap-2 mb-2 ml-1">
                    <Zap size={12} /> Dispositivi Attivi
                </h3>
                <div className="flex flex-wrap gap-3">
                    {activeItems.map(item => (
                        <ActiveItemWidget 
                            key={item.id} 
                            item={item} 
                            // IMPORTANTE: Assicura il refresh dei dati al click
                            onUpdate={fetchCharacterData} 
                        />
                    ))}
                    {activeItems.length === 0 && <p className="text-gray-600 text-xs italic w-full text-center py-4">Nessun dispositivo attivo.</p>}
                </div>
            </section>

            {/* Link Navigazione */}
            <div className="grid grid-cols-2 gap-3 mt-4">
                <button onClick={() => onNavigate('messaggi')} className="bg-gray-800 p-3 rounded-lg border border-gray-700 flex justify-between shadow items-center hover:bg-gray-750 transition-colors">
                    <div className="flex gap-2 text-indigo-400 font-bold text-xs"><MessageSquare size={16} /> Messaggi</div>
                    {unreadCount > 0 ? <span className="bg-red-500 text-white text-xs font-bold px-2 py-0.5 rounded-full animate-pulse">{unreadCount}</span> : <span className="text-gray-600 text-xs">-</span>}
                </button>
                <button onClick={() => onNavigate('transazioni')} className="bg-gray-800 p-3 rounded-lg border border-gray-700 flex justify-between shadow items-center hover:bg-gray-750 transition-colors">
                    <div className="flex gap-2 text-amber-400 font-bold text-xs"><Briefcase size={16} /> Lavori</div>
                    {char.lavori_pendenti_count > 0 ? <span className="bg-amber-500 text-black text-xs font-bold px-2 py-0.5 rounded-full animate-bounce">{char.lavori_pendenti_count}</span> : <span className="text-gray-600 text-xs">-</span>}
                </button>
            </div>

            {favorites.length > 0 && (
                <section className="mt-6 pt-4 border-t border-gray-800">
                    <h3 className="text-[10px] uppercase tracking-widest text-yellow-500 mb-3 font-bold flex items-center gap-2 ml-1"><Star size={12} /> Prontuario Rapido</h3>
                    <div className="space-y-3">
                        {favorites.map(fav => (
                            <div key={fav.id} className="bg-yellow-900/5 border border-yellow-700/20 p-3 rounded-lg relative group">
                                <div className="flex justify-between items-start mb-1">
                                    <span className="font-bold text-yellow-200/80 text-sm">{fav.nome}</span>
                                    <button onClick={() => toggleFavorite(fav)} className="text-yellow-800 hover:text-red-400"><Star size={12} fill="currentColor"/></button>
                                </div>
                                <div className="text-[11px] text-gray-400 leading-snug prose prose-invert max-w-none" dangerouslySetInnerHTML={{ __html: fav.testo }} />
                            </div>
                        ))}
                    </div>
                </section>
            )}
        </div>
    );
};

export default GameTab;

==================================================
FILE: src\components\GenericGroupedList.jsx
==================================================
import React from 'react';

// Funzione helper per determinare il colore del testo (Bianco/Nero)
const getContrastYIQ = (hexcolor) => {
    if (!hexcolor) return 'black';
    const hex = hexcolor.replace("#", "");
    if (hex.length !== 6) return 'black';
    
    var r = parseInt(hex.substr(0, 2), 16);
    var g = parseInt(hex.substr(2, 2), 16);
    var b = parseInt(hex.substr(4, 2), 16);
    var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? 'black' : 'white';
}

const GenericGroupedList = ({ 
    items, 
    groupByKey, 
    renderItem, 
    renderHeader, 
    titleKey = "nome", 
    colorKey = "colore", 
    iconKey = "icona_url", 
    orderKey = "ordine",
    itemSortFn, // <--- NUOVA PROP: Funzione opzionale per ordinare gli item dentro il gruppo
    compact = false 
}) => {

    if (!items || items.length === 0) return null;

    // 1. Raggruppa gli elementi
    const groupedItems = items.reduce((acc, item) => {
        const groupObj = item[groupByKey];
        
        const groupId = groupObj ? groupObj.id : 'no-group';
        const groupName = groupObj ? groupObj[titleKey] : 'Altro';
        const groupColor = groupObj ? groupObj[colorKey] : '#cccccc';
        const groupIcon = groupObj ? groupObj[iconKey] : null;
        // Se orderKey non esiste sull'oggetto, mettilo in fondo (9999)
        const groupOrder = groupObj && groupObj[orderKey] !== undefined ? groupObj[orderKey] : 9999;

        if (!acc[groupId]) {
            acc[groupId] = {
                id: groupId,
                name: groupName,
                color: groupColor,
                icon: groupIcon,
                order: groupOrder,
                items: []
            };
        }
        acc[groupId].items.push(item);
        return acc;
    }, {});

    // 2. Ordina i GRUPPI (Le schede/header)
    const sortedGroups = Object.values(groupedItems).sort((a, b) => {
        if (a.order !== b.order) return a.order - b.order;
        return a.name.localeCompare(b.name);
    });

    return (
        <div className="space-y-4">
            {sortedGroups.map(group => {
                // 3. Ordina gli ITEMS dentro il gruppo (se fornita la funzione)
                const sortedItems = itemSortFn 
                    ? [...group.items].sort(itemSortFn) 
                    : group.items;

                // Se c'è una funzione custom per l'header, usala.
                if (renderHeader) {
                    return (
                        <div 
                            key={group.id} 
                            className="border border-gray-700 rounded-lg overflow-hidden shadow-sm mb-4 bg-gray-800"
                            style={{ borderColor: group.color }}
                        >
                            {renderHeader(group)}

                            <div className="p-2">
                                <ul className={`divide-y divide-gray-700 ${compact ? 'text-sm' : ''}`}>
                                    {sortedItems.map((item, index) => (
                                        <React.Fragment key={index}>
                                            {renderItem(item)}
                                        </React.Fragment>
                                    ))}
                                </ul>
                            </div>
                        </div>
                    );
                }

                // --- DEFAULT HEADER (Fallback) ---
                const textColor = getContrastYIQ(group.color);
                return (
                    <div 
                        key={group.id} 
                        className="border border-gray-700 rounded-lg overflow-hidden shadow-sm mb-4 bg-gray-800"
                        style={{ borderColor: group.color }}
                    >
                        <div 
                            className={`px-3 py-1 flex items-center justify-between font-bold ${compact ? 'text-sm' : 'text-base'}`}
                            style={{ backgroundColor: group.color, color: textColor }}
                        >
                            <div className="flex items-center gap-2">
                                {group.icon && (
                                    <div 
                                        className="w-5 h-5"
                                        style={{
                                            maskImage: `url(${group.icon})`,
                                            WebkitMaskImage: `url(${group.icon})`,
                                            maskSize: 'contain',
                                            WebkitMaskSize: 'contain',
                                            backgroundColor: textColor
                                        }}
                                    />
                                )}
                                <span>{group.name}</span>
                            </div>
                            <span className={`text-xs px-2 py-0.5 rounded-full bg-white/20`}>
                                {group.items.length}
                            </span>
                        </div>

                        <div className="p-2">
                            <ul className={`divide-y divide-gray-700 ${compact ? 'text-sm' : ''}`}>
                                {sortedItems.map((item, index) => (
                                    <React.Fragment key={index}>
                                        {renderItem(item)}
                                    </React.Fragment>
                                ))}
                            </ul>
                        </div>
                    </div>
                );
            })}
        </div>
    );
};

export default GenericGroupedList;

==================================================
FILE: src\components\GenericHeader.jsx
==================================================
import React from 'react';
import { Bell } from 'lucide-react';

const GenericHeader = ({ 
    title = "KOR 35", 
    subtitle = "Master Tool", 
    rightSlot
}) => {
    return (
        <header className="h-16 bg-gray-950 border-b border-gray-800 flex items-center justify-between px-4 z-40 shadow-2xl shrink-0 w-full">
            {/* LEFT: Logo e Titoli (NESSUN MENU QUI) */}
            <div className="flex items-center gap-3">
                <div className="flex items-center gap-2">
                    <img src="/Logo Kor-AD_Trasp.png" alt="Logo" className="h-8 w-8 object-contain" />
                    <div className="flex flex-col leading-tight">
                        <span className="font-black text-lg uppercase italic tracking-tighter">
                            {title.split(' ')[0]} <span className="text-indigo-500">{title.split(' ')[1]}</span>
                        </span>
                        <span className="text-[8px] font-bold text-gray-500 uppercase tracking-[0.2em]">{subtitle}</span>
                    </div>
                </div>
            </div>

            {/* RIGHT: Slot (dove va il Menu) + Notifiche */}
            <div className="flex items-center gap-3">
                {rightSlot}
                <button className="p-2 text-gray-500 hover:text-indigo-400 relative">
                    <Bell size={20} />
                    <span className="absolute top-1 right-1 w-2 h-2 bg-red-600 rounded-full border border-gray-950"></span>
                </button>
            </div>
        </header>
    );
};

export default GenericHeader;

==================================================
FILE: src\components\GiornoSection.jsx
==================================================
import React, { useState } from 'react'; 
import { Calendar, Clock, Edit2, Trash, ChevronDown, ChevronUp, BookOpen, Plus } from 'lucide-react';
import QuestItem from './QuestItem';
import RichTextDisplay from './RichTextDisplay';

const GiornoSection = ({ giorno, gIdx, isMaster, risorse, onEdit, onDelete, onAddQuest, questHandlers }) => {
    const [showDettagli, setShowDettagli] = useState(false);

    // LOGICA DI ORDINAMENTO AGGIUNTA
    // Crea una copia dell'array e ordina per orario_indicativo
    const sortedQuests = [...(giorno.quests || [])].sort((a, b) => {
        // Se manca l'orario, considera come fine giornata ("23:59:59") per metterlo in fondo
        const timeA = a.orario_indicativo || "23:59:59";
        const timeB = b.orario_indicativo || "23:59:59";
        return timeA.localeCompare(timeB);
    });
    
    const formatTime = (iso) => iso ? new Date(iso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : "--:--";
    const formatDate = (iso) => iso ? new Date(iso).toLocaleDateString([], { day: '2-digit', month: 'long', year: 'numeric' }) : "";

    return (
        <div className="space-y-6 w-full max-w-full">
            <div className="flex justify-between items-start border-b border-emerald-500/30 pb-3 gap-2">
                <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-1">
                        <span className="bg-emerald-600 text-white px-2 py-0.5 rounded text-[10px] font-black uppercase whitespace-nowrap">Giorno {gIdx + 1}</span>
                        <span className="text-[10px] font-bold text-gray-400 uppercase flex items-center gap-1 truncate">
                            <Calendar size={12}/> {formatDate(giorno.data_ora_inizio)}
                        </span>
                    </div>
                    
                    {/* Titolo Principale */}
                    <h2 className="text-2xl font-black italic text-white uppercase tracking-tight truncate">
                        {giorno.titolo || `Giorno ${gIdx + 1}`}
                    </h2>
                    
                    {/* Sinossi Breve */}
                    {giorno.sinossi_breve && (
                        <div className="text-sm text-indigo-300 italic font-medium bg-indigo-900/10 p-2 rounded-lg border border-indigo-500/20 mt-2">
                            <RichTextDisplay content={giorno.sinossi_breve} />
                        </div>
                    )}

                    <div className="flex flex-wrap items-center gap-3 text-[10px] text-emerald-400 font-bold uppercase italic mt-2">
                        <span className="flex items-center gap-1 whitespace-nowrap"><Clock size={12}/> {formatTime(giorno.data_ora_inizio)} - {formatTime(giorno.data_ora_fine)}</span>
                        
                        {/* Bottone per espandere i dettagli completi */}
                        {giorno.descrizione_completa && (
                            <button 
                                onClick={() => setShowDettagli(!showDettagli)}
                                className="flex items-center gap-1 text-white bg-emerald-900/40 px-2 py-1 rounded hover:bg-emerald-800 transition-colors"
                            >
                                <BookOpen size={10}/> 
                                {showDettagli ? "Nascondi Plot" : "Leggi Plot Completo"}
                                {showDettagli ? <ChevronUp size={10}/> : <ChevronDown size={10}/>}
                            </button>
                        )}
                    </div>
                </div>

                {isMaster && (
                    <div className="flex gap-2 shrink-0">
                        <button onClick={() => onEdit('giorno', giorno)} className="text-gray-500 hover:text-white p-1"><Edit2 size={16}/></button>
                        <button onClick={() => onDelete(giorno.id)} className="text-red-900 hover:text-red-500 p-1"><Trash size={16}/></button>
                        <button onClick={() => onAddQuest(giorno.id)} className="bg-emerald-600 px-3 py-1.5 rounded text-[10px] font-black uppercase whitespace-nowrap flex items-center gap-1">
                            <Plus size={12}/> Quest
                        </button>
                    </div>
                )}
            </div>

            {/* Sezione Collassata della Descrizione Completa */}
            {showDettagli && giorno.descrizione_completa && (
                <div className="bg-emerald-950/20 border-l-2 border-emerald-500 p-4 rounded-r-lg animate-in fade-in w-full">
                    <h4 className="text-[10px] font-black text-emerald-500 uppercase mb-2">Dettagli Plot / Note Master</h4>
                    <div className="text-xs text-gray-400 bg-black/20 p-2 rounded">
                        <RichTextDisplay content={giorno.descrizione_completa} />
                    </div>
                </div>
            )}

            <div className="grid gap-8 w-full">
                {/* QUI è la correzione: mappiamo 'sortedQuests' invece di 'giorno.quests' */}
                {sortedQuests.map(quest => (
                    <QuestItem 
                        key={quest.id} 
                        quest={quest} 
                        isMaster={isMaster} 
                        risorse={risorse} 
                        onEdit={onEdit} 
                        // Espando i questHandlers (onAddSub, onRemoveSub, ecc.)
                        onAddSub={questHandlers.onAddSub}
                        onRemoveSub={questHandlers.onRemoveSub}
                        onStatChange={questHandlers.onStatChange}
                        onSaveNotes={questHandlers.onSaveNotes}
                        onScanQr={questHandlers.onScanQr}
                    />
                ))}
            </div>
        </div>
    );
};

export default GiornoSection;

==================================================
FILE: src\components\GraftInstallationModal.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { X, Activity, User, Coins, Send, Loader2, Trash2, CheckCircle } from 'lucide-react';
import { useCharacter } from './CharacterContext';
import { 
    installaInnesto, // IMPORTANTE: Usa questo per l'installazione diretta
    richiediAssemblaggio, 
    searchPersonaggi, 
    getBodySlots 
} from '../api';

const GraftInstallationModal = ({ task, onClose, onSuccess }) => {
    const { selectedCharacterData } = useCharacter();
    const [selectedSlot, setSelectedSlot] = useState('');
    
    // Liste candidati
    const [compatibleCandidates, setCompatibleCandidates] = useState([]);
    const [filteredCandidates, setFilteredCandidates] = useState([]);
    
    const [selectedTargetUser, setSelectedTargetUser] = useState(null);
    const [offer, setOffer] = useState(0);
    const [isLoading, setIsLoading] = useState(false);
    const [isDiscarding, setIsDiscarding] = useState(false);

    // Parsing slot permessi (es. "HD1, HD2")
    const allowedSlotsCodes = task.infusione_slot_permessi 
        ? task.infusione_slot_permessi.split(',').map(s => s.trim()) 
        : [];
        
    const allSlots = getBodySlots();
    const availableSlots = allSlots.filter(s => allowedSlotsCodes.includes(s.code));

    // 1. Carica candidati compatibili all'avvio
    useEffect(() => {
        const fetchCandidates = async () => {
            try {
                // Passiamo stringa vuota "" per ottenere tutti i compatibili senza filtro nome
                const res = await searchPersonaggi("", selectedCharacterData.id, task.infusione_id);
                console.log("Candidati trovati:", res); // DEBUG
                setCompatibleCandidates(res);
                setFilteredCandidates(res);
            } catch (e) { 
                console.error("Err fetch candidates", e); 
            }
        };
        fetchCandidates();
    }, [task.infusione_id, selectedCharacterData.id]);

    // 2. Filtra candidati quando cambia lo slot
    useEffect(() => {
        if (!selectedSlot) {
            setFilteredCandidates(compatibleCandidates);
            return;
        }

        const filtered = compatibleCandidates.filter(c => {
            const occupied = c.slots_occupati || [];
            return !occupied.includes(selectedSlot);
        });
        setFilteredCandidates(filtered);

        if (selectedTargetUser && selectedTargetUser.id !== selectedCharacterData.id) {
            const isStillValid = filtered.find(c => c.id === selectedTargetUser.id);
            if (!isStillValid) setSelectedTargetUser(null);
        }
    }, [selectedSlot, compatibleCandidates, selectedCharacterData.id, selectedTargetUser]);

    // Determina se l'installazione è diretta (senza proposta)
    const isDirectInstall = selectedTargetUser && (
        selectedTargetUser.id === selectedCharacterData.id || 
        selectedTargetUser.is_mine // <--- Assicurati che il backend invii questo campo nel serializer
    );

    const handleConfirm = async () => {
        if (!selectedSlot) return alert("Seleziona uno slot corporeo!");
        if (!selectedTargetUser) return alert("Seleziona un paziente!");
        
        setIsLoading(true);
        try {
            console.log("--- DEBUG CONFERMA ---");
            console.log("Io (Dottore):", selectedCharacterData.nome, selectedCharacterData.id);
            console.log("Target (Paziente):", selectedTargetUser.nome, selectedTargetUser.id);
            console.log("Is Direct Install?", isDirectInstall);

            if (isDirectInstall) {
                // --- INSTALLAZIONE DIRETTA ---
                console.log("Eseguo installaInnesto...");
                await installaInnesto(
                    task.id, 
                    selectedSlot, 
                    selectedCharacterData.id, // Forgiatore
                    selectedTargetUser.id     // Destinatario (Me o Mio Alt)
                ); 
                alert(`Operazione completata con successo su ${selectedTargetUser.nome}!`);
            } else {
                // --- PROPOSTA A TERZI ---
                const payload = {
                    committente_id: selectedTargetUser.id, // ID del Paziente
                    artigiano_nome: selectedCharacterData.nome, // Nome del Dottore
                    forgiatura_id: task.id,
                    slot_destinazione: selectedSlot,
                    offerta: offer,
                    tipo_operazione: 'GRAF'
                };
                console.log("Invio Payload Proposta:", payload); // <--- CONTROLLA QUESTO LOG
                
                await richiediAssemblaggio(payload);
                alert(`Proposta di operazione inviata a ${selectedTargetUser.nome}!`);
            }
            onSuccess();
            onClose();
        } catch (error) {
            console.error("Errore operazione:", error);
            alert("Errore: " + error.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handleDiscard = async () => {
        if (!confirm("Sei sicuro? L'oggetto verrà distrutto.")) return;
        alert("Funzione di scarto non ancora implementata.");
        setIsDiscarding(false);
    };

    return (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center p-4 z-50 animate-fadeIn">
            <div className="bg-gray-800 rounded-xl w-full max-w-lg border border-gray-600 shadow-2xl flex flex-col max-h-[90vh]">
                
                {/* Header */}
                <div className="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-900 rounded-t-xl shrink-0">
                    <div>
                        <h3 className="text-lg font-bold text-white flex items-center gap-2">
                            <Activity className="text-pink-500"/> Sala Operatoria
                        </h3>
                        <p className="text-xs text-gray-400">Finalizzazione: {task.infusione_nome}</p>
                    </div>
                    <button onClick={onClose}><X className="text-gray-400 hover:text-white"/></button>
                </div>

                <div className="p-6 overflow-y-auto space-y-6">
                    
                    {/* 1. SELEZIONE SLOT */}
                    <div>
                        <h4 className="text-sm font-bold text-gray-300 uppercase mb-2 flex items-center gap-2">
                            1. Seleziona Slot Corporeo
                        </h4>
                        {availableSlots.length > 0 ? (
                            <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
                                {availableSlots.map(s => (
                                    <button 
                                        key={s.code}
                                        onClick={() => setSelectedSlot(s.code)}
                                        className={`p-2 border rounded text-xs font-bold transition-all ${
                                            selectedSlot === s.code 
                                            ? 'bg-pink-600 border-pink-400 text-white ring-2 ring-pink-400/50' 
                                            : 'bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        {s.name}
                                    </button>
                                ))}
                            </div>
                        ) : (
                            <div className="text-red-400 text-sm">Nessuno slot definito per questo innesto.</div>
                        )}
                        {!selectedSlot && <p className="text-xs text-amber-500 mt-1">* Seleziona uno slot per vedere i candidati validi.</p>}
                    </div>

                    {/* 2. SELEZIONE PAZIENTE */}
                    <div className={`transition-opacity ${!selectedSlot ? 'opacity-50 pointer-events-none' : 'opacity-100'}`}>
                        <h4 className="text-sm font-bold text-gray-300 uppercase mb-2">2. Seleziona Paziente</h4>
                        
                        {/* Opzione ME STESSO */}
                        <div 
                            onClick={() => setSelectedTargetUser(selectedCharacterData)}
                            className={`p-3 rounded border mb-3 cursor-pointer flex items-center justify-between ${
                                selectedTargetUser?.id === selectedCharacterData.id
                                ? 'bg-indigo-900/50 border-indigo-500 text-white'
                                : 'bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600'
                            }`}
                        >
                            <div className="flex items-center gap-3">
                                <User className="text-indigo-400"/>
                                <div>
                                    <div className="font-bold">Me Stesso ({selectedCharacterData.nome})</div>
                                    <div className="text-xs text-gray-400">Installazione Immediata • Gratuita</div>
                                </div>
                            </div>
                            {selectedTargetUser?.id === selectedCharacterData.id && <CheckCircle size={18} className="text-indigo-400"/>}
                        </div>

                        {/* Lista ALTRI CANDIDATI */}
                        <div className="text-xs font-bold text-gray-500 mb-1 uppercase">Altri Pazienti Compatibili</div>
                        <div className="bg-gray-900 border border-gray-700 rounded max-h-40 overflow-y-auto">
                            {filteredCandidates.filter(c => c.id !== selectedCharacterData.id).length === 0 ? (
                                <div className="p-3 text-gray-500 text-center text-sm">
                                    Nessun altro candidato (o slot occupato).
                                </div>
                            ) : (
                                filteredCandidates
                                    .filter(c => c.id !== selectedCharacterData.id)
                                    .map(u => (
                                    <div 
                                        key={u.id}
                                        onClick={() => setSelectedTargetUser(u)}
                                        className={`p-2 border-b border-gray-800 cursor-pointer flex justify-between items-center hover:bg-gray-800 ${
                                            selectedTargetUser?.id === u.id ? 'bg-gray-700 text-white' : 'text-gray-300'
                                        }`}
                                    >
                                        <div>
                                            <span className="font-medium">{u.nome}</span>
                                            {u.is_mine && <span className="ml-2 text-[10px] bg-blue-900 text-blue-200 px-1 rounded">MIO</span>}
                                        </div>
                                        {selectedTargetUser?.id === u.id && <CheckCircle size={14} className="text-green-500"/>}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>

                    {/* 3. COSTO (Solo se Altro Giocatore) */}
                    {selectedTargetUser && !isDirectInstall && (
                        <div className="bg-gray-900/50 p-3 rounded border border-gray-700 animate-fadeIn">
                             <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Richiesta Compenso (CR)</label>
                             <div className="relative">
                                 <Coins className="absolute left-2 top-2.5 text-yellow-500" size={16}/>
                                 <input 
                                     type="number" 
                                     className="w-full bg-gray-800 border-gray-600 rounded p-2 pl-8 text-white focus:border-indigo-500 outline-none"
                                     value={offer} 
                                     onChange={e => setOffer(e.target.value)}
                                     placeholder="0"
                                     min="0"
                                 />
                             </div>
                             <p className="text-xs text-gray-500 mt-1">Il destinatario riceverà una proposta da accettare.</p>
                        </div>
                    )}

                </div>

                {/* Footer Actions */}
                <div className="p-4 bg-gray-900 border-t border-gray-700 rounded-b-xl flex gap-3 shrink-0">
                    <button 
                        onClick={() => setIsDiscarding(!isDiscarding)}
                        className="p-3 rounded-lg bg-red-900/30 text-red-400 hover:bg-red-900/50 hover:text-red-200 border border-red-900/50 transition-colors"
                        title="Scarta Oggetto"
                    >
                        <Trash2 size={20}/>
                    </button>

                    {isDiscarding ? (
                        <button 
                            onClick={handleDiscard}
                            className="flex-1 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg py-2 animate-fadeIn"
                        >
                            Conferma Scarto
                        </button>
                    ) : (
                        <button 
                            onClick={handleConfirm}
                            disabled={isLoading || !selectedSlot || !selectedTargetUser}
                            className={`flex-1 font-bold py-3 rounded-lg shadow-lg flex justify-center items-center gap-2 transition-all ${
                                isLoading || !selectedSlot || !selectedTargetUser
                                ? 'bg-gray-700 text-gray-500 cursor-not-allowed'
                                : isDirectInstall 
                                    ? 'bg-green-600 hover:bg-green-500 text-white' 
                                    : 'bg-indigo-600 hover:bg-indigo-500 text-white'
                            }`}
                        >
                            {isLoading ? <Loader2 className="animate-spin"/> : (isDirectInstall ? <Activity/> : <Send/>)}
                            {isDirectInstall ? 'INSTALLA SUBITO' : 'INVIA PROPOSTA'}
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
};

export default GraftInstallationModal;

==================================================
FILE: src\components\GroupedSkillList.jsx
==================================================
import React, { useMemo, useState } from 'react';
import PunteggioDisplay from './PunteggioDisplay';

// Sotto-componente per la riga singola (Gestisce lo stato di espansione)
const SkillRow = ({ 
  skill, 
  group, 
  onItemClick, 
  renderSubtitle, 
  showDescription, 
  actionRenderer 
}) => {
  // Stato locale per gestire l'apertura/chiusura della descrizione
  const [isExpanded, setIsExpanded] = useState(false);

  const handleDescriptionClick = (e) => {
    e.stopPropagation(); // Evita di attivare onItemClick (apertura modale) se si clicca sul testo
    setIsExpanded(!isExpanded);
  };

  return (
    <li className="p-3 flex flex-col sm:flex-row sm:items-center justify-between hover:bg-gray-800/60 transition-colors gap-3 border-b border-gray-700/50 last:border-0">
      {/* Parte Sinistra (Cliccabile per aprire dettaglio modale) */}
      <div 
        className="flex flex-col grow cursor-pointer"
        onClick={() => onItemClick && onItemClick(skill)}
      >
        <div className="flex items-center">
          <div className="mr-3 shrink-0">
            {group.charData ? (
              <PunteggioDisplay 
                punteggio={group.charData} 
                displayText="none" 
                size="xs" 
                iconType="inv_circle" 
              />
            ) : (
              <div className="w-4 h-4 bg-gray-600 rounded-full" />
            )}
          </div>
          <span className="font-semibold text-gray-200 text-base block">{skill.nome}</span>
        </div>
        
        {/* Sottotitolo (es. Requisiti/Costo) */}
        {renderSubtitle && renderSubtitle(skill)}
        
        {/* Descrizione Collassabile (Logica Accordion) */}
        {showDescription && skill.descrizione && (
          <div
            onClick={handleDescriptionClick}
            className={`text-xs text-gray-400 pl-7 mt-1 prose prose-invert prose-sm leading-snug cursor-pointer hover:text-gray-200 transition-colors select-none ${
              isExpanded ? '' : 'line-clamp-1'
            }`}
            title={isExpanded ? "Clicca per ridurre" : "Clicca per espandere"}
            // Usa dangerouslySetInnerHTML per supportare eventuali tag HTML nella descrizione
            dangerouslySetInnerHTML={{ __html: skill.descrizione }}
          />
        )}
      </div>
      
      {/* Parte Destra (Azioni/Pulsanti) */}
      {actionRenderer && (
        <div className="flex items-center gap-2 shrink-0 self-end sm:self-center ml-7 sm:ml-0">
          {actionRenderer(skill)}
        </div>
      )}
    </li>
  );
};

const GroupedSkillList = ({ 
  skills, 
  punteggiList, 
  onItemClick, 
  actionRenderer, 
  renderSubtitle, 
  showDescription = true // Default a true per mostrare le descrizioni
}) => {
  
  const { sortedSections } = useMemo(() => {
    if (!skills) return { sortedSections: [] };

    const groups = skills.reduce((acc, skill) => {
      let charName = "Altro";
      let charObj = null;
      let charId = null;

      if (skill.caratteristica) {
        if (typeof skill.caratteristica === 'object') {
            charName = skill.caratteristica.nome;
            charId = skill.caratteristica.id;
            charObj = skill.caratteristica; 
        } else if (typeof skill.caratteristica === 'number') {
             charId = skill.caratteristica;
        } else {
             charName = String(skill.caratteristica);
        }
      }

      if (punteggiList && punteggiList.length > 0) {
        let found = null;
        if (charId) found = punteggiList.find(p => p.id === charId);
        if (!found && charName !== "Altro") found = punteggiList.find(p => p.nome === charName);
        
        if (found) {
            charObj = found;
            charName = found.nome;
        }
      }

      if (!acc[charName]) acc[charName] = { skills: [], charData: charObj };
      acc[charName].skills.push(skill);
      return acc;
    }, {});

    Object.values(groups).forEach(group => {
        group.skills.sort((a, b) => a.nome.localeCompare(b.nome));
    });

    const sections = [];
    const usedKeys = new Set();

    if (punteggiList) {
        punteggiList.forEach(p => {
            if (groups[p.nome]) {
                sections.push({ name: p.nome, ...groups[p.nome] });
                usedKeys.add(p.nome);
            }
        });
    }

    Object.keys(groups).sort().forEach(key => {
        if (!usedKeys.has(key)) {
            sections.push({ name: key, ...groups[key] });
        }
    });

    return { sortedSections: sections };
  }, [skills, punteggiList]);

  if (!skills || skills.length === 0) {
     return <p className="text-gray-500 bg-gray-800 p-4 rounded-lg text-center italic">Nessuna abilità trovata.</p>;
  }

  return (
    <div className="space-y-6">
      {sortedSections.map((group) => {
        const charName = group.name;
        const headerBg = group.charData?.colore || '#374151';
        
        return (
            <div 
                key={charName} 
                className="bg-gray-900/40 rounded-xl overflow-hidden shadow-sm border border-gray-700"
                style={{ borderColor: headerBg }}
            >
              {/* Header con PunteggioDisplay */}
              <div 
                  className="px-4 py-2 border-b border-black/20 flex items-center"
                  style={{ backgroundColor: headerBg }}
              >
                  {group.charData ? (
                      <PunteggioDisplay 
                         punteggio={group.charData}
                         displayText="name" 
                         iconType="inv_circle"
                         size="m"
                         className="bg-transparent! shadow-none! p-0 w-full justify-start text-white"
                      />
                  ) : (
                      <h4 className="text-lg font-bold uppercase tracking-wider text-white">
                         {charName}
                      </h4>
                  )}
              </div>
              
              {/* Lista Skills usando il nuovo componente SkillRow */}
              <ul className="divide-y divide-gray-700/50">
                {group.skills.map((skill) => (
                  <SkillRow 
                    key={skill.id}
                    skill={skill}
                    group={group}
                    onItemClick={onItemClick}
                    renderSubtitle={renderSubtitle}
                    showDescription={showDescription}
                    actionRenderer={actionRenderer}
                  />
                ))}
              </ul>
            </div>
        );
      })}
    </div>
  );
};

export default GroupedSkillList;

==================================================
FILE: src\components\HomeTab.jsx
==================================================
import React, { useMemo } from 'react';
import { useCharacter } from './CharacterContext';
import { Coins, Star, Bell, Backpack, Zap } from 'lucide-react';
import PunteggioDisplay from './PunteggioDisplay';
import GenericGroupedList from './GenericGroupedList';
import IconaPunteggio from './IconaPunteggio';
import ActiveItemWidget from './ActiveItemWidget'; // <--- IMPORT WIDGET

// --- NUOVI COMPONENTI ---
import LogViewer from './LogViewer';
import TransazioniViewer from './TransazioniViewer';

// --- Componenti Helper ---

const StatRow = ({ label, value, icon }) => (
  <div className="flex justify-between items-center p-2 bg-gray-800 rounded-md">
    <div className="flex items-center">
      {icon}
      <span className="ml-2 font-semibold text-gray-300 capitalize">{label}</span>
    </div>
    <span className="text-xl font-bold text-white">{value}</span>
  </div>
);

// (ItemList commentato come nel tuo originale)
// const ItemList = ({ title, items, keyField = 'id', nameField = 'nome' }) => (
//   <div className="mb-6">
// ...
//   </div>
// );

const LoadingComponent = () => (
  <div className="p-8 text-center text-lg text-gray-400">
    Caricamento dati personaggio...
  </div>
);


// --- Componente Scheda ---

const CharacterSheet = ({ data }) => {
  const { punteggiList, subscribeToPush, fetchCharacterData } = useCharacter(); // <--- AGGIUNTO fetchCharacterData

  const {
    nome,
    crediti,
    punti_caratteristica,
    punteggi_base, 
    modificatori_calcolati, 
    abilita_possedute, 
    oggetti,
    // log_eventi <-- RIMOSSO: Ora gestito da LogViewer
  } = data;

  // --- LOGICA FILTRO OGGETTI ATTIVI ---
  const activeItems = useMemo(() => {
    if (!oggetti) return [];
    
    return oggetti.filter(obj => {
      // 1. Mostra sempre Innesti (INN) e Mod (MOD), anche se scarichi
      if (['INN', 'MOD'].includes(obj.tipo_oggetto)) return true;
      
      // 2. Mostra oggetti fisici (es. armi/bacchette) SOLO se hanno cariche attive > 0
      if (obj.cariche_attuali > 0) return true;
      
      return false;
    });
  }, [oggetti]);

  // Calcolo Statistiche
  const { stat_primarie, caratteristiche, aure_possedute } = useMemo(() => {
    if (!punteggiList || punteggiList.length === 0 || !punteggi_base) { 
      return { stat_primarie: [], caratteristiche: [], aure_possedute: [] };
    }

    const sortByOrdine = (a, b) => (a.ordine || 0) - (b.ordine || 0);
    const sortByPunteggioOrdine = (a, b) => (a.punteggio.ordine || 0) - (b.punteggio.ordine || 0);

    const primarie = punteggiList
        .filter(p => p.tipo === 'ST' && p.is_primaria)
        .sort(sortByOrdine);

    const punteggiMappati = Object.entries(punteggi_base) 
      .map(([nome, valore]) => {
        const punteggio = punteggiList.find(p => p.nome === nome);
        if (punteggio) return { punteggio, valore };
        return null; 
      })
      .filter(Boolean); 

    const chars = punteggiMappati
        .filter(item => item.punteggio.tipo === 'CA')
        .sort(sortByPunteggioOrdine);
    
    const aure = punteggiMappati
        .filter(item => item.punteggio.tipo === 'AU')
        .sort(sortByPunteggioOrdine);

    return { stat_primarie: primarie, caratteristiche: chars, aure_possedute: aure };

  }, [punteggiList, punteggi_base]);

  // --- RENDER ITEM ABILITÀ ---
  const renderAbilitaItem = (abilita) => {
    const iconUrl = abilita.caratteristica?.icona_url;
    const iconColor = abilita.caratteristica?.colore;

    return (
        <li className="py-2 px-2 hover:bg-gray-700/50 transition-colors rounded-sm cursor-default border-b border-gray-700/50 last:border-0">
            <div className="flex items-center gap-2">
                <div className="mt-1 self-start shrink-0">
                    <IconaPunteggio 
                        url={iconUrl}
                        color={iconColor}
                        mode="cerchio_inv" 
                        size="xs"
                    />
                </div>
                <span className="font-bold text-gray-200 text-base">
                    {abilita.nome}
                </span>
            </div>

            {abilita.descrizione && (
                <div
                    className="text-sm text-gray-400 pl-8 mt-1 prose prose-invert prose-sm max-w-none leading-snug"
                    dangerouslySetInnerHTML={{ __html: abilita.descrizione }}
                />
            )}
        </li>
    );
  };

  // --- RENDER HEADER GRUPPO (PunteggioDisplay) ---
  const renderGroupHeader = (group) => {
    const fakePunteggio = {
        nome: group.name,
        colore: group.color,
        icona_url: group.icon
    };

    return (
        <PunteggioDisplay 
            punteggio={fakePunteggio}
            value={group.items.length} 
            displayText="name"
            iconType="inv_circle" 
            size="s"              
            className="rounded-b-none" 
        />
    );
  };

  return (
    <div className="p-4 max-w-4xl mx-auto">
      
      {/* Banner Notifiche */}
      {'Notification' in window && Notification.permission !== 'granted' && (
         <div className="mb-6 p-4 bg-indigo-900/50 rounded-lg border border-indigo-500 flex flex-col sm:flex-row justify-between items-center gap-3">
            <div className="flex items-center gap-3">
                <div className="bg-indigo-600 p-2 rounded-full">
                    <Bell size={20} className="text-white" />
                </div>
                <div>
                    <p className="font-bold text-white text-sm">Notifiche Push</p>
                    <p className="text-xs text-indigo-200">Ricevi messaggi anche ad app chiusa.</p>
                </div>
            </div>
            <button onClick={() => subscribeToPush()} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-medium rounded shadow transition-colors w-full sm:w-auto">
                Attiva
            </button>
         </div>
      )}

      <h2 className="text-4xl font-bold text-indigo-400 mb-6 text-center">{nome}</h2>
      
      {/* --- NUOVA SEZIONE: DISPOSITIVI ATTIVI --- */}
      {activeItems && activeItems.length > 0 && (
        <div className="mb-6">
          <div className="flex items-center gap-2 mb-3 border-b border-gray-700 pb-2">
             <Zap className="w-5 h-5 text-yellow-400" />
             <h3 className="text-2xl font-semibold text-gray-200">Dispositivi Attivi</h3>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {activeItems.map(item => (
              <ActiveItemWidget 
                key={item.id} 
                item={item} 
                onUpdate={fetchCharacterData} 
              />
            ))}
          </div>
        </div>
      )}

      {/* Valute */}
      <div className="grid grid-cols-2 gap-4 mb-6 max-w-lg mx-auto"> 
        <StatRow label="CR" value={crediti || 0} icon={<Coins className="text-yellow-400" />} />
        <StatRow label="PC" value={punti_caratteristica || 0} icon={<Star className="text-blue-400" />} />
      </div>

      {/* Statistiche Primarie */}
      {stat_primarie.length > 0 && (
        <div className="mb-6">
          <h3 className="text-2xl font-semibold mb-3 text-gray-200 border-b border-gray-700 pb-2">Statistiche</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"> 
            {stat_primarie.map((punteggio) => {
              if (!punteggio.parametro) return null; 
              const mods = modificatori_calcolati[punteggio.parametro] || {add: 0, mol: 1.0};
              const valore_finale = (punteggio.valore_predefinito + mods.add) * mods.mol;
              
              return (
                <PunteggioDisplay
                  key={punteggio.id}
                  punteggio={punteggio}
                  value={Math.round(valore_finale)} 
                  displayText="name"
                  iconType="inv_circle"
                  size="m"
                />
              );
            })}
          </div>
        </div>
      )}

      {/* Caratteristiche */}
      {caratteristiche.length > 0 && (
        <div className="mb-6">
          <h3 className="text-2xl font-semibold mb-3 text-gray-200 border-b border-gray-700 pb-2">Caratteristiche</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            {caratteristiche.map(({ punteggio, valore }) => (
                <PunteggioDisplay
                  key={punteggio.id} 
                  punteggio={punteggio} 
                  value={valore}         
                  displayText="name"   
                  iconType="inv_circle"
                  size="m"
                />
            ))}
          </div>
        </div>
      )}

      {/* Aure Possedute */}
      {aure_possedute.length > 0 && (
        <div className="mb-6">
            <h3 className="text-2xl font-semibold mb-3 text-gray-200 border-b border-gray-700 pb-2">Aure Possedute</h3>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {aure_possedute.map(({ punteggio, valore }) => (
                    <PunteggioDisplay
                        key={punteggio.id}
                        punteggio={punteggio}
                        value={valore}
                        displayText="name"
                        iconType="inv_circle"
                        size="m"
                    />
                ))}
            </div>
        </div>
      )}

      {/* Abilità */}
      {/* <div className="mb-6">
        <h3 className="text-2xl font-semibold mb-3 text-gray-200 border-b border-gray-700 pb-2">Abilità</h3>
        {abilita_possedute && abilita_possedute.length > 0 ? (
            <GenericGroupedList 
                items={abilita_possedute}
                groupByKey="caratteristica"
                orderKey="ordine"
                titleKey="nome"             
                colorKey="colore"           
                iconKey="icona_url"         
                renderItem={renderAbilitaItem}
                renderHeader={renderGroupHeader}
                compact={false} 
            />
        ) : (
            <p className="text-gray-500 bg-gray-800 p-4 rounded-lg shadow-inner">Nessuna abilità trovata.</p>
        )}
      </div> */}

      {/* Oggetti - Se vuoi riattivare ItemList, scommenta qui sotto. Per ora è commentato come da originale */}
      {/* <ItemList title="Oggetti" items={oggetti} /> */}

      {/* --- SEZIONE LOG EVENTI (PAGINATA) --- */}
      {/* <div className="mb-6">
         <LogViewer />
      </div> */}

      {/* --- SEZIONE TRANSAZIONI (PAGINATA) --- */}
      {/* <div className="mb-6">
         <h3 className="text-2xl font-semibold mb-3 text-gray-200 border-b border-gray-700 pb-2">Transazioni</h3>
         <TransazioniViewer />
      </div> */}

      {/* Modificatori (Accordion) */}
      {modificatori_calcolati && (
        <details className="mt-4 bg-gray-800 rounded-lg shadow-inner">
          <summary className="text-xl font-semibold text-gray-200 p-3 cursor-pointer select-none">
            Statistiche Secondarie (Dettagli)
          </summary>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 p-4 border-t border-gray-700">
            {Object.entries(modificatori_calcolati).map(([parametro, mods]) => {
              const punteggio = punteggiList.find(p => p.parametro === parametro);
              if (!punteggio || punteggio.is_primaria) return null;
              
              const valore_finale = (punteggio.valore_predefinito + mods.add) * mods.mol;
              return (
                <PunteggioDisplay
                  key={punteggio.id}
                  punteggio={punteggio}
                  value={Math.round(valore_finale)} 
                  displayText="name"
                  iconType="inv_circle"
                  size="m"
                />
              );
            })}
          </div>
        </details>
      )}
    </div>
  );
};

const HomeTab = () => {
  const { 
    selectedCharacterData, 
    isLoadingDetail,
    isLoadingPunteggi, 
    selectedCharacterId, 
    error 
  } = useCharacter();

  if (isLoadingDetail || isLoadingPunteggi) return <LoadingComponent />;
  if (error && !selectedCharacterData) return <div className="p-4 text-center text-red-400">Errore nel caricamento. Riprova.</div>;
  if (!selectedCharacterId) return <div className="p-8 text-center text-gray-400"><h2 className="text-2xl font-bold mb-4">Benvenuto!</h2><p>Seleziona un personaggio.</p></div>;
  if (!selectedCharacterData) return <div className="p-8 text-center text-gray-400"><p>Nessun dato trovato.</p></div>;

  return <CharacterSheet data={selectedCharacterData} />;
};

export default HomeTab;

==================================================
FILE: src\components\HtmlViewerModal.jsx
==================================================
import React from 'react';

// Icona per il pulsante di chiusura (da lucide-react)
const X = (props) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M18 6 6 18" />
    <path d="m6 6 12 12" />
  </svg>
);

const HtmlViewerModal = ({ htmlContent, onClose }) => {
  if (!htmlContent) {
    return null;
  }

  return (
    // Overlay scuro che copre l'intera pagina
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 p-4">
      
      {/* Contenitore della modale */}
      <div className="flex flex-col w-full h-full max-w-4xl max-h-[90vh] bg-gray-800 rounded-lg shadow-2xl overflow-hidden">
        
        {/* Header della modale */}
        <div className="flex items-center justify-between p-4 border-b border-gray-700">
          <h2 className="text-xl font-bold text-white">Risultato Scansione</h2>
          <button
            onClick={onClose}
            className="p-2 text-gray-400 rounded-full hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-indigo-500"
            aria-label="Chiudi"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Contenuto (iframe) */}
        <div className="grow p-4 bg-white overflow-auto">
          <iframe
            srcDoc={htmlContent}
            title="Contenuto QR"
            className="w-full h-full border-0"
            sandbox="allow-scripts allow-same-origin" // Aggiunge un po' di sicurezza
          />
        </div>

        {/* Footer con pulsante di chiusura (utile per mobile) */}
        <div className="p-4 border-t border-gray-700 text-center">
           <button
            onClick={onClose}
            className="px-6 py-2 font-bold text-white bg-indigo-600 rounded-md shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500"
          >
            Chiudi
          </button>
        </div>
      </div>
    </div>
  );
};

export default HtmlViewerModal;



==================================================
FILE: src\components\IconaPunteggio.jsx
==================================================
import React from 'react';
import { API_BASE_URL } from '../api';

// Helper per il contrasto (ROBUSTO: gestisce anche hex a 3 cifre)
export const getContrastColor = (hexColor) => {
  if (!hexColor) return 'white';
  try {
    let hex = hexColor.replace('#', '');
    // Espande la notazione breve (es. "fff" -> "ffffff")
    if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
    }
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    // Se il parsing fallisce (NaN), ritorna bianco per sicurezza
    if (isNaN(r) || isNaN(g) || isNaN(b)) return 'white';

    const luminanza = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminanza > 0.5 ? 'black' : 'white';
  } catch (e) {
    return 'white';
  }
};

const IconaPunteggio = ({ url, color = '#000000', mode = 'normal', size = 'm', className = '' }) => {
  if (!url) return null;

  let fullUrl = url;
  if (!url.startsWith('http')) {
      const cleanBase = API_BASE_URL.endsWith('/') ? API_BASE_URL.slice(0, -1) : API_BASE_URL;
      const cleanPath = url.startsWith('/') ? url : `/${url}`;
      fullUrl = `${cleanBase}${cleanPath}`;
  }

  const contrastColor = getContrastColor(color);

  // --- DIMENSIONI INTERMEDIE ---
  const sizeMap = {
    xs: 'w-4.5 h-4.5', // 18px
    s:  'w-7 h-7',     // 28px
    m:  'w-11 h-11',   // 44px
    l:  'w-[4.5rem] h-[4.5rem]', // 72px
    xl: 'w-28 h-28',   // 112px
  };

  const iconSizeMap = {
    xs: 'w-3 h-3',
    s:  'w-4.5 h-4.5',
    m:  'w-7 h-7',
    l:  'w-11 h-11',
    xl: 'w-20 h-20',
  };

  const containerSize = sizeMap[size] || sizeMap.m;
  const iconSize = iconSizeMap[size] || iconSizeMap.m;

  let containerBg = 'transparent';
  let iconFill = color; 
  let borderRadius = '0';
  let isRaw = false;

  if (mode === 'raw') {
      isRaw = true;
  } else if (mode === 'normal') {
      iconFill = color;
  } else if (mode === 'cerchio') {
      containerBg = contrastColor === 'white' ? '#1f2937' : '#f3f4f6';
      iconFill = color;
      borderRadius = '50%';
  } else if (mode === 'cerchio_inv') {
      containerBg = color;
      iconFill = contrastColor; // Qui usa il colore calcolato (Bianco/Nero)
      borderRadius = '50%';
  }

  if (isRaw) {
    return (
      <div className={`flex items-center justify-center shrink-0 ${containerSize} ${className}`}>
         <img 
            src={fullUrl} 
            alt="" 
            className="w-full h-full object-contain"
            onError={(e) => e.target.style.display = 'none'} 
         />
      </div>
    );
  }

  return (
    <div 
      className={`flex items-center justify-center shrink-0 shadow-sm ${containerSize} ${className}`}
      style={{ backgroundColor: containerBg, borderRadius }}
    >
      <div className={`${iconSize} relative overflow-hidden`}>
         <img 
            src={fullUrl} 
            alt="" 
            className="w-full h-full object-contain"
            style={{
               transform: 'translateX(-1000px)',
               filter: `drop-shadow(1000px 0 0 ${iconFill})`
            }}
            onError={(e) => e.target.style.display = 'none'}
         />
      </div>
    </div>
  );
};

export default IconaPunteggio;

==================================================
FILE: src\components\InfusioniTab.jsx
==================================================
import React, { useState, Fragment } from 'react';
import { Tab } from '@headlessui/react';
import { useCharacter } from './CharacterContext';
import { Loader2, ShoppingCart, Info, CheckCircle2, PlusCircle, FileEdit, Hammer } from 'lucide-react';

// --- COMPONENTS ---
import TecnicaDetailModal from './TecnicaDetailModal';
import GenericGroupedList from './GenericGroupedList';
import PunteggioDisplay from './PunteggioDisplay';     
import IconaPunteggio from './IconaPunteggio';
import ProposalManager from './ProposalManager';
import ForgingQueue from './ForgingQueue'; 
import ForgingModal from './ForgingModal'; // <--- NUOVO MODALE IMPORTATO

// --- API & HOOKS ---
import { acquireInfusione } from '../api.js'; // startForging rimosso da qui, lo gestisce ForgingModal
import { useForgingQueue } from '../hooks/useGameData'; 

function classNames(...classes) {
  return classes.filter(Boolean).join(' ');
}

const InfusioniTab = ({ onLogout }) => {
  const {
    selectedCharacterData: char,
    selectedCharacterId, 
    acquirableInfusioni, 
    refreshCharacterData,
    isLoadingAcquirable,
    isLoadingDetail
  } = useCharacter();
  
  // Hook per la coda di forgiatura (aggiornamento automatico)
  const { data: forgingQueue, refetch: refetchQueue } = useForgingQueue(selectedCharacterId);
  
  // --- STATI LOCALI ---
  const [modalItem, setModalItem] = useState(null); // Per i dettagli (Info)
  const [isAcquiring, setIsAcquiring] = useState(null); // Loading acquisto
  const [showProposals, setShowProposals] = useState(false); // Gestione proposte

  // Stato per la modale di forgiatura avanzata
  const [selectedInfusioneForgia, setSelectedInfusioneForgia] = useState(null);

  // --- HANDLERS ---

  const handleOpenModal = (item) => setModalItem(item);

  // Gestione Acquisto Nuova Infusione (Apprendimento)
  const handleAcquire = async (item, e) => {
    e.stopPropagation();
    if (isAcquiring || !selectedCharacterId) return;
    
    const costoFinale = item.costo_effettivo ?? (item.costo_crediti || item.livello * 100);
    
    if (!window.confirm(`Apprendere l'Infusione "${item.nome}" per ${costoFinale} Crediti?`)) return;
    
    setIsAcquiring(item.id);
    try {
      await acquireInfusione(item.id, selectedCharacterId, onLogout);
      await refreshCharacterData(); 
    } catch (error) {
      alert(`Errore: ${error.message}`);
    } finally {
      setIsAcquiring(null);
    }
  };

  // Gestione Apertura Forgiatura (MODIFICATO)
  // Invece di avviare subito, apriamo la modale per scegliere il metodo
  const handleForgeClick = (item, e) => {
    e.stopPropagation();
    setSelectedInfusioneForgia(item);
  };

  // Callback quando la forgiatura viene avviata dalla modale
  const onForgingStarted = () => {
      refetchQueue();       // Aggiorna la coda visuale
      refreshCharacterData(); // Aggiorna i crediti spesi
      setSelectedInfusioneForgia(null); // Chiudi modale
  };

  // --- LOGICA UI ---

  const sortItems = (items) => [...items].sort((a, b) => a.livello - b.livello);
  
  const possessed = sortItems(char?.infusioni_possedute || []);
  const acquirable = sortItems(acquirableInfusioni || []);

  if (isLoadingAcquirable || isLoadingDetail || !char) {
    return (
      <div className="flex justify-center items-center h-64">
        <Loader2 className="animate-spin text-indigo-500" size={48} />
      </div>
    );
  }

  // Render Header Gruppo (es. per Aura)
  const renderGroupHeader = (group) => {
    const fakePunteggio = {
        nome: group.name,
        colore: group.color,
        icona_url: group.icon 
    };

    return (
        <PunteggioDisplay 
            punteggio={fakePunteggio}
            value={group.items.length}
            displayText="name"
            iconType="inv_circle"
            size="s"
            className="rounded-b-none"
        />
    );
  };

  // Render Elemento Lista (Posseduto)
  const renderPossessedItem = (item) => {
    const iconUrl = item.aura_richiesta?.icona_url;
    const iconColor = item.aura_richiesta?.colore;

    return (
      <li className="flex justify-between items-center py-2 px-2 hover:bg-gray-700/50 transition-colors rounded-sm border-b border-gray-700/50 last:border-0 gap-2">
        <div className="flex items-center gap-3 cursor-pointer grow" onClick={() => handleOpenModal(item)}>
            <div className="shrink-0 mt-0.5 relative">
                <IconaPunteggio url={iconUrl} color={iconColor} mode="cerchio_inv" size="xs" />
                <span className="absolute -top-2 -right-2 bg-gray-900 text-gray-200 text-[9px] font-bold px-1 py-0.5 rounded-full border border-gray-600 leading-none">
                    L{item.livello}
                </span>
            </div>
            <span className="font-bold text-gray-200 text-base">{item.nome}</span>
        </div>
        
        {/* Tasto Forgia (Apre Modale) */}
        <button
            onClick={(e) => handleForgeClick(item, e)}
            className="flex items-center gap-1 px-3 py-1.5 bg-orange-700 hover:bg-orange-600 text-white rounded text-xs font-bold uppercase tracking-wider transition-all shadow-sm hover:shadow-orange-500/20 active:scale-95"
        >
            <Hammer size={14} /> 
            <span className="hidden sm:inline">Forgia</span>
        </button>

        <button
            onClick={(e) => {e.stopPropagation(); handleOpenModal(item)}}
            className="p-2 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full transition-colors ml-1"
        >
            <Info size={18} />
        </button>
      </li>
    );
  };

  // Render Elemento Lista (Acquistabile)
  const renderAcquirableItem = (item) => {
    const iconUrl = item.aura_richiesta?.icona_url;
    const iconColor = item.aura_richiesta?.colore;
    
    const costoPieno = item.costo_pieno ?? (item.costo_crediti || item.livello * 100);
    const costoEffettivo = item.costo_effettivo ?? costoPieno;
    const hasDiscount = costoEffettivo < costoPieno;
    const canAfford = char.crediti >= costoEffettivo;

    return (
      <li className="flex flex-col sm:flex-row sm:items-center justify-between py-3 px-2 hover:bg-gray-700/50 transition-colors rounded-sm border-b border-gray-700/50 last:border-0 gap-2">
        <div className="flex items-center gap-3 cursor-pointer grow" onClick={() => handleOpenModal(item)}>
            <div className="shrink-0 mt-0.5 relative">
                <IconaPunteggio url={iconUrl} color={iconColor} mode="cerchio_inv" size="xs" />
                <span className="absolute -top-2 -right-2 bg-gray-900 text-gray-200 text-[9px] font-bold px-1 py-0.5 rounded-full border border-gray-600 leading-none">
                    L{item.livello}
                </span>
            </div>
            
            <div className="flex flex-col">
                <span className="font-bold text-gray-200 text-base">{item.nome}</span>
                <div className="text-xs text-gray-400 flex gap-2 mt-0.5 sm:hidden">
                    {hasDiscount ? (
                        <div className="flex items-center gap-1">
                             <span className="text-red-500 line-through decoration-red-500 opacity-70">{costoPieno}</span>
                             <span className={canAfford ? "text-green-400 font-bold" : "text-red-400 font-bold"}>{costoEffettivo} CR</span>
                        </div>
                    ) : (
                        <span className={canAfford ? "text-yellow-300" : "text-red-400"}>{costoEffettivo} CR</span>
                    )}
                </div>
            </div>
        </div>

        <div className="flex items-center justify-end gap-3 w-full sm:w-auto">
            <div className="hidden sm:flex flex-col items-end text-xs font-mono mr-1">
                {hasDiscount ? (
                    <div className="flex flex-col items-end leading-none mt-1">
                        <span className="text-[10px] text-red-500 line-through decoration-red-500 opacity-80">{costoPieno}</span>
                        <span className="text-green-400 font-bold">{costoEffettivo} CR</span>
                    </div>
                ) : (
                    <span className={canAfford ? "text-yellow-300" : "text-red-400 font-bold"}>{costoEffettivo} CR</span>
                )}
            </div>

            <button
                onClick={(e) => handleAcquire(item, e)}
                disabled={!canAfford || isAcquiring === item.id}
                className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-bold transition-all shadow-md ml-auto sm:ml-0 ${
                    canAfford 
                    ? 'bg-indigo-600 hover:bg-indigo-500 text-white hover:shadow-indigo-500/20' 
                    : 'bg-gray-700 text-gray-500 cursor-not-allowed opacity-50'
                }`}
            >
                {isAcquiring === item.id ? (
                    <Loader2 className="animate-spin" size={16} />
                ) : (
                    <>
                        <ShoppingCart size={16} />
                        <span className="hidden sm:inline">Apprendi</span>
                    </>
                )}
            </button>
            
            <button
                onClick={(e) => {e.stopPropagation(); handleOpenModal(item)}}
                className="p-2 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full transition-colors"
            >
                <Info size={18} />
            </button>
        </div>
      </li>
    );
  };

  const PossessedList = (
      <GenericGroupedList 
        items={possessed} 
        groupByKey="aura_richiesta"
        orderKey="ordine"
        titleKey="nome"
        colorKey="colore"
        iconKey="icona_url"
        renderItem={renderPossessedItem}
        renderHeader={renderGroupHeader}
        itemSortFn={(a, b) => a.livello - b.livello} 
      />
  );

  const AcquirableList = (
      <GenericGroupedList 
        items={acquirable} 
        groupByKey="aura_richiesta"
        orderKey="ordine"
        titleKey="nome"
        colorKey="colore"
        iconKey="icona_url"
        renderItem={renderAcquirableItem}
        renderHeader={renderGroupHeader}
        itemSortFn={(a, b) => a.livello - b.livello}
      />
  );

  return (
    <>
      <div className="w-full p-4 max-w-6xl mx-auto pb-24">
        {/* Header Crediti */}
        <div className="mb-4 flex justify-between items-center bg-gray-800 p-3 rounded-lg border border-gray-700 shadow-sm max-w-3xl mx-auto">
            <div className="text-sm text-gray-400">Disponibilità:</div>
            <div className="flex gap-4">
                <div className="flex items-center gap-1 text-yellow-400 font-bold">
                    <span>{char.crediti}</span> <span className="text-xs font-normal text-gray-400">CR</span>
                </div>
            </div>
        </div>

        {/* Coda di Forgiatura Attiva */}
        <div className="max-w-3xl mx-auto">
            <ForgingQueue queue={forgingQueue} refetchQueue={refetchQueue} />
        </div>

        {/* Bottone Gestione Proposte */}
        <div className="flex justify-end mb-6 max-w-3xl mx-auto">
            <button 
                onClick={() => setShowProposals(true)}
                className="flex items-center gap-2 bg-gray-800 hover:bg-gray-700 text-indigo-300 hover:text-white px-4 py-2 rounded-lg border border-gray-600 transition-all shadow-sm text-sm font-medium"
            >
                <FileEdit size={16} />
                Gestisci Proposte Infusione
            </button>
        </div>

        {/* Visualizzazione Mobile (Tabs) */}
        <div className="md:hidden">
            <Tab.Group>
              <Tab.List className="flex space-x-1 rounded-xl bg-gray-800/80 p-1 mb-6 shadow-inner">
                {['Possedute', 'Nuove'].map((category, idx) => (
                  <Tab as={Fragment} key={category}>
                    {({ selected }) => (
                      <button className={classNames(
                          'w-full rounded-lg py-2.5 text-sm font-medium leading-5 transition-all',
                          selected ? 'bg-indigo-600 text-white shadow' : 'text-gray-400 hover:bg-gray-700/50 hover:text-white'
                      )}>
                        {category} <span className="ml-1 opacity-60 text-xs">
                            ({idx === 0 ? possessed.length : acquirable.length})
                        </span>
                      </button>
                    )}
                  </Tab>
                ))}
              </Tab.List>
              <Tab.Panels>
                <Tab.Panel className="focus:outline-none animate-fadeIn">{PossessedList}</Tab.Panel>
                <Tab.Panel className="focus:outline-none animate-fadeIn">{AcquirableList}</Tab.Panel>
              </Tab.Panels>
            </Tab.Group>
        </div>

        {/* Visualizzazione Desktop (Griglia) */}
        <div className="hidden md:grid grid-cols-2 gap-6">
            <div>
                <div className="flex items-center gap-2 mb-4 pb-2 border-b border-gray-700">
                    <CheckCircle2 className="w-6 h-6 text-green-500" />
                    <h2 className="text-xl font-bold text-white">
                        Infusioni Possedute 
                        <span className="ml-2 text-sm font-normal text-gray-400">({possessed.length})</span>
                    </h2>
                </div>
                {PossessedList}
            </div>
            <div>
                <div className="flex items-center gap-2 mb-4 pb-2 border-b border-gray-700">
                    <PlusCircle className="w-6 h-6 text-indigo-500" />
                    <h2 className="text-xl font-bold text-white">
                        Nuove Infusioni
                        <span className="ml-2 text-sm font-normal text-gray-400">({acquirable.length})</span>
                    </h2>
                </div>
                {AcquirableList}
            </div>
        </div>
      </div>
      
      {/* Modale Dettagli Infusione */}
      {modalItem && (
        <TecnicaDetailModal tecnica={modalItem} type="Infusione" onClose={() => setModalItem(null)} />
      )}

      {/* Modale Gestione Proposte */}
      {showProposals && (
        <ProposalManager type="Infusione" onClose={() => setShowProposals(false)} />
      )}

      {/* Modale Forgiatura Avanzata (NUOVA) */}
      {selectedInfusioneForgia && (
        <ForgingModal 
            infusione={selectedInfusioneForgia}
            onClose={() => setSelectedInfusioneForgia(null)}
            onRefresh={onForgingStarted}
        />
      )}
    </>
  );
};

export default InfusioniTab;

==================================================
FILE: src\components\InventoryTab.jsx
==================================================
import React, { useState, useEffect, memo, useCallback } from 'react';
import { useCharacter } from './CharacterContext';
import { 
    ShoppingBag, Box, Shield, Zap, Loader2, Wrench, 
    Info, ChevronUp, ChevronDown, Activity, Power, Battery, 
    Clock, RefreshCw, Sparkles, Swords, Lock, User
} from 'lucide-react';
import ShopModal from './ShopModal';
import ItemAssemblyModal from './ItemAssemblyModal';
import { useOptimisticEquip, useOptimisticRecharge } from '../hooks/useGameData';

// --- UTILS ---
const formatDuration = (seconds) => {
    if (!seconds) return "";
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    
    const parts = [];
    if (h > 0) parts.push(`${h}h`);
    if (m > 0) parts.push(`${m}m`);
    if (s > 0 || parts.length === 0) parts.push(`${s}s`);
    
    return parts.join(' ');
};

const LazyList = ({ items, renderItem, batchSize = 10 }) => {
    const [displayedItems, setDisplayedItems] = useState([]);
    
    useEffect(() => {
        // Reset quando cambiano gli items
        setDisplayedItems(items.slice(0, batchSize));
    }, [items, batchSize]);

    const showMore = () => {
        setDisplayedItems(prev => items.slice(0, prev.length + batchSize));
    };

    return (
        <div className="space-y-2">
            {displayedItems.map(renderItem)}
            
            {displayedItems.length < items.length && (
                <button 
                    onClick={showMore}
                    className="w-full py-3 mt-2 text-sm font-bold text-gray-400 bg-gray-800/50 hover:bg-gray-700 border border-dashed border-gray-600 rounded-lg transition-colors flex items-center justify-center gap-2"
                >
                    <ChevronDown size={16} /> Carica altri ({items.length - displayedItems.length})
                </button>
            )}
        </div>
    );
};

// --- COMPONENTE VISUALE CORPO (SVG ORGANICO 8 SLOT) ---
const InventoryBodyWidget = ({ slots, onSlotClick, selectedItemId }) => {
    const paths = {
        'HD1': { d: "M75,35 C75,20 85,10 100,10 C115,10 125,20 125,35 C125,45 100,48 75,35 Z", name: "Cranio (HD1)" },
        'HD2': { d: "M75,35 C100,48 125,45 125,35 C125,50 115,65 100,65 C85,65 75,50 75,35 Z", name: "Volto (HD2)" },
        'TR1': { d: "M70,55 C70,55 85,65 100,65 C115,65 130,55 130,55 C132,60 133,85 130,100 C100,105 100,105 70,100 C67,85 68,60 70,55 Z", name: "Torace (TR1)" },
        'TR2': { d: "M70,100 C100,105 100,105 130,100 C128,120 120,145 100,145 C80,145 72,120 70,100 Z", name: "Addome (TR2)" },
        'LA': { d: "M68,55 C55,52 45,58 45,70 C45,90 50,110 40,135 C38,140 50,145 55,135 C65,110 65,90 68,80 Z", name: "Braccio Sx (LA)" },
        'RA': { d: "M132,55 C145,52 155,58 155,70 C155,90 150,110 160,135 C162,140 150,145 145,135 C135,110 135,90 132,80 Z", name: "Braccio Dx (RA)" },
        'LL': { d: "M95,135 C85,135 75,140 75,150 C75,180 72,210 75,240 C80,250 60,255 70,260 C90,260 90,240 90,220 C90,190 98,150 95,135 Z", name: "Gamba Sx (LL)" },
        'RL': { d: "M105,135 C115,135 125,140 125,150 C125,180 128,210 125,240 C120,250 140,255 130,260 C110,260 110,240 110,220 C110,190 102,150 105,135 Z", name: "Gamba Dx (RL)" }
    };

    return (
        <div className="relative w-full max-w-[260px] mx-auto drop-shadow-xl select-none">
            <svg viewBox="0 0 200 280" className="w-full h-auto filter drop-shadow-lg">
                <defs>
                    <filter id="glow-selected" x="-20%" y="-20%" width="140%" height="140%">
                        <feGaussianBlur stdDeviation="2" result="blur" />
                        <feComposite in="SourceGraphic" in2="blur" operator="over" />
                    </filter>
                </defs>
                <g opacity="0.2">
                     {Object.values(paths).map((p, i) => <path key={i} d={p.d} fill="#1f2937" stroke="none" />)}
                </g>
                {Object.entries(paths).map(([code, { d, name }]) => {
                    const item = slots[code] && slots[code][0];
                    const isOccupied = !!item;
                    const isSelected = item && item.id === selectedItemId;
                    const auraColor = item?.aura?.colore || '#4b5563'; 
                    const fillColor = isOccupied ? auraColor : 'transparent';
                    const strokeColor = isOccupied ? (isSelected ? '#ffffff' : 'rgba(255,255,255,0.5)') : '#374151';
                    const opacity = isOccupied ? (isSelected ? 1 : 0.7) : 0.1;
                    const cursor = isOccupied ? 'cursor-pointer' : 'cursor-default';
                    const filter = isSelected ? 'url(#glow-selected)' : '';

                    return (
                        <g key={code} onClick={() => isOccupied && onSlotClick(item)} className={`transition-all duration-300 ${cursor}`}>
                            <path d={d} fill={fillColor} stroke={strokeColor} strokeWidth={isSelected ? 2 : 1} fillOpacity={opacity} filter={filter} className={`transition-all duration-300 ${isOccupied ? 'hover:fill-opacity-100 hover:stroke-white' : ''}`} />
                            <title>{name} {isOccupied ? `: ${item.nome}` : '(Vuoto)'}</title>
                        </g>
                    );
                })}
            </svg>
        </div>
    );
};

// --- COMPONENTE CARD INVENTARIO (MEMOIZED PER PERFORMANCE) ---
// Usa memo per evitare re-render dell'intera lista quando cambia lo stato di un solo elemento
const InventoryItemCard = memo(({ item, isExpanded, onToggleExpand, onEquip, onRecharge, onAssembly }) => {
    const isPhysical = item.tipo_oggetto === 'FIS';
    const canBeModified = (isPhysical || ['INN', 'MUT'].includes(item.tipo_oggetto)) && (item.classe_oggetto_nome || item.tipo_oggetto === 'INN');
    const isActive = item.is_active;

    // Render Statistiche (Solo != 0)
    const renderStats = (statistiche) => {
        if (!statistiche || statistiche.length === 0) return null;
        // Filtra statistiche con valore 0 (inutile mostrarle come +0)
        const activeStats = statistiche.filter(s => s.valore !== 0);
        if (activeStats.length === 0) return null;

        return (
            <div className="flex flex-wrap gap-2 mt-2">
                {activeStats.map((stat, idx) => {
                    // Costruisce la condizione se presente
                    const hasCondition = stat.usa_limitazione_aura || stat.usa_limitazione_elemento || stat.usa_condizione_text;
                    const conditionTitle = stat.condizione_text || "Condizionale";
                    
                    return (
                        <div key={idx} className="flex items-center bg-gray-900 border border-gray-600 rounded px-2 py-1 text-xs shadow-sm">
                            <span className="font-bold text-gray-300 mr-1">{stat.statistica.nome}</span>
                            <span className={`font-mono font-bold ${stat.valore > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                {stat.valore > 0 ? '+' : ''}{stat.valore}
                            </span>
                            {hasCondition && (
                                <div className="ml-1 text-amber-500" title={conditionTitle}>
                                    <Lock size={10} />
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        );
    };

    // Render Componenti (Mattoni) con Icone
    const renderComponents = (componenti) => {
        if (!componenti || componenti.length === 0) return null;
        return (
            <div className="flex flex-wrap gap-1 items-center justify-end">
                {componenti.map((comp, idx) => {
                    const val = comp.valore || 1;
                    const icons = [];
                    for(let i=0; i<val; i++) {
                        icons.push(
                            <div key={`${idx}-${i}`} className="w-5 h-5 rounded bg-gray-800 border border-gray-600 flex items-center justify-center p-0.5 shadow-sm" title={comp.caratteristica.nome}>
                                {comp.caratteristica.icona_url ? (
                                    <img src={comp.caratteristica.icona_url} alt={comp.caratteristica.sigla} className="w-full h-full object-contain" />
                                ) : (
                                    <span className="text-[9px] font-bold text-gray-300">{comp.caratteristica.sigla}</span>
                                )}
                            </div>
                        );
                    }
                    return icons;
                })}
            </div>
        );
    };

    // Render Info Cariche
    const renderChargeInfo = () => {
        if (!item.cariche_massime && !item.durata_totale) return null;
        const isLow = item.cariche_attuali === 0;

        return (
            <div className="mt-2 bg-black/20 p-2 rounded border border-gray-600/50 flex flex-col gap-1">
                <div className="flex justify-between items-center text-xs">
                    <div className="flex items-center gap-2">
                        <span className={`flex items-center gap-1 font-bold ${isLow ? 'text-red-500' : 'text-yellow-500'}`}>
                            <Battery size={14} /> 
                            <span className="text-sm">{item.cariche_attuali}</span> 
                            <span className="text-gray-500">/</span> 
                            <span>{item.cariche_massime || '-'}</span>
                        </span>
                    </div>
                    {(item.cariche_massime > 0 && item.cariche_attuali < item.cariche_massime) && (
                        <button 
                            onClick={(e) => { e.stopPropagation(); onRecharge(item); }}
                            className="flex items-center gap-1 px-2 py-0.5 bg-yellow-900/50 hover:bg-yellow-800 text-yellow-200 border border-yellow-700 rounded text-[10px] uppercase font-bold tracking-wide transition-colors"
                        >
                            <RefreshCw size={10} /> {item.costo_ricarica} CR
                        </button>
                    )}
                </div>
                {item.durata_totale > 0 && (
                    <div className="text-[10px] text-blue-300 flex items-center gap-1 border-t border-gray-700/50 pt-1 mt-1">
                        <Clock size={10} /> Durata: {formatDuration(item.durata_totale)}
                    </div>
                )}
            </div>
        );
    };

    const getStatusStyle = () => {
        if (isActive) return 'border-2 border-green-500 shadow-[0_0_15px_rgba(34,197,94,0.2)] bg-green-900/10';
        if (item.is_equipaggiato) return 'border-2 border-yellow-600/60 bg-yellow-900/10'; 
        return 'border border-gray-700 bg-gray-800 hover:border-gray-600'; 
    };

    return (
        <div className={`relative p-3 mb-3 rounded-lg flex flex-col transition-all ${getStatusStyle()}`}>
            
            {/* HEADER CARD */}
            <div className="flex items-start justify-between cursor-pointer" onClick={() => onToggleExpand(item.id)}>
                <div className="flex items-center gap-3 w-full">
                    {/* Icona Aura (con fallback) */}
                    <div className="w-10 h-10 rounded bg-gray-900 border border-gray-600 flex items-center justify-center shrink-0 overflow-hidden shadow-inner" title={item.aura?.nome || "Oggetto"}>
                         {item.aura?.icona_url ? (
                             <img src={item.aura.icona_url} className="w-7 h-7 object-contain" alt={item.aura.nome}/>
                         ) : (
                             <Sparkles size={20} color={item.aura?.colore || '#888'}/>
                         )}
                    </div>
                    
                    <div className="flex flex-col w-full">
                        <div className="flex items-center justify-between w-full">
                            <h4 className={`font-bold text-sm sm:text-base leading-tight ${isActive ? 'text-green-400' : item.is_equipaggiato ? 'text-yellow-500' : 'text-gray-200'}`}>
                                {item.nome}
                            </h4>
                            
                            {/* Componenti (Mattoni) in alto a destra */}
                            <div className="ml-auto flex items-center">
                                {renderComponents(item.componenti)}
                                {/* Livello Badge */}
                                {item.livello > 0 && (
                                    <span className="ml-2 text-[9px] bg-gray-700 text-gray-300 px-1.5 py-0.5 rounded border border-gray-600 font-mono shrink-0">
                                        Lv.{item.livello}
                                    </span>
                                )}
                            </div>
                        </div>
                        
                        <div className="flex justify-between items-center mt-1">
                            <div className="text-[10px] text-gray-500 uppercase tracking-wider flex gap-2">
                                <span>{item.tipo_oggetto_display}</span>
                                {item.classe_oggetto_nome && <span>• {item.classe_oggetto_nome}</span>}
                            </div>
                            
                            {/* Icona Espandi */}
                            <div className="text-gray-500">
                                {isExpanded ? <ChevronUp size={16} /> : <ChevronDown size={16} />}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {/* EXPANDED CONTENT */}
            {isExpanded && (
                <div className="mt-3 animate-fadeIn space-y-3 border-t border-gray-700/50 pt-2">
                    
                    {/* Attacco Base */}
                    {item.attacco_formattato && (
                        <div className="bg-red-900/20 border border-red-900/40 p-2 rounded flex items-center gap-2 text-red-300 text-xs font-bold shadow-inner">
                            <Swords size={14} />
                            <span>ATTACCO: {item.attacco_formattato}</span>
                        </div>
                    )}

                    {/* Statistiche Base e Modificatori */}
                    {renderStats(item.statistiche)}

                    {/* Descrizione */}
                    <div className="text-xs text-gray-300 prose prose-invert prose-sm max-w-none leading-relaxed bg-black/10 p-2 rounded border border-gray-700/30">
                         <div dangerouslySetInnerHTML={{ __html: item.testo_formattato_personaggio || item.testo || item.descrizione || "Nessun dato disponibile." }} />
                         {item.data_fine_attivazione && (
                             <div className="mt-2 pt-2 border-t border-gray-700 text-[10px] text-orange-400 font-mono text-right">
                                 Scade: {new Date(item.data_fine_attivazione).toLocaleString()}
                             </div>
                         )}
                    </div>

                    {/* Info Cariche */}
                    {renderChargeInfo()}

                    {/* Potenziamenti Installati */}
                    {item.potenziamenti_installati && item.potenziamenti_installati.length > 0 && (
                        <div className="pl-2 border-l-2 border-indigo-500/30 mt-2 bg-indigo-900/5 p-2 rounded">
                            <p className="text-[10px] font-bold text-indigo-400 uppercase mb-2 flex items-center gap-1">
                                <Zap size={12} /> Moduli Installati:
                            </p>
                            <div className="space-y-2">
                                {item.potenziamenti_installati.map(mod => (
                                    <div key={mod.id} className={`p-2 rounded border text-xs ${mod.is_active !== false ? 'bg-indigo-900/20 border-indigo-500/20' : 'bg-red-900/10 border-red-900/30 opacity-70'}`}>
                                        <div className="flex justify-between items-start mb-1">
                                            <div className="flex flex-col">
                                                <span className="font-bold text-indigo-200">{mod.nome}</span>
                                                <span className="text-[9px] text-gray-500">{mod.tipo_oggetto_display}</span>
                                            </div>
                                            {/* Icone componenti mod */}
                                            {renderComponents(mod.componenti)}
                                        </div>
                                        {/* Statistiche Mod */}
                                        {renderStats(mod.statistiche)}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    
                    {/* Bottoni Azione */}
                    <div className="flex gap-2 mt-2 pt-2 border-t border-gray-700/30">
                        {canBeModified && (
                            <button
                                onClick={(e) => { e.stopPropagation(); onAssembly(item); }}
                                className="flex-1 py-2 rounded text-xs font-bold bg-gray-700 hover:bg-gray-600 text-amber-400 border border-gray-600 flex items-center justify-center gap-2 shadow-sm"
                            >
                                <Wrench size={14} /> Modifica
                            </button>
                        )}
                        {isPhysical && (
                            <button 
                                onClick={(e) => { e.stopPropagation(); onEquip(item.id); }}
                                className={`flex-1 py-2 rounded text-xs font-bold transition-all active:scale-95 flex items-center justify-center gap-2 shadow-sm ${
                                    item.is_equipaggiato
                                    ? 'bg-red-900/80 hover:bg-red-800 text-red-100 border border-red-700'
                                    : 'bg-emerald-700 hover:bg-emerald-600 text-white border border-emerald-600'
                                }`}
                            >
                                {item.is_equipaggiato ? <><Power size={14}/> Rimuovi</> : <><Shield size={14}/> Equipaggia</>}
                            </button>
                        )}
                    </div>

                </div>
            )}
        </div>
    );
});

// --- MAIN INVENTORY TAB ---
const InventoryTab = ({ onLogout }) => {
  const { selectedCharacterData: characterData, isLoading: isContextLoading } = useCharacter();
  
  const [items, setItems] = useState([]);
  const [showShop, setShowShop] = useState(false);
  const [showAssembly, setShowAssembly] = useState(false);
  const [assemblyHost, setAssemblyHost] = useState(null);
  const [selectedBodyItem, setSelectedBodyItem] = useState(null);
  const [expandedItems, setExpandedItems] = useState({});

  const equipMutation = useOptimisticEquip();
  const rechargeMutation = useOptimisticRecharge();

  useEffect(() => {
    if (characterData?.oggetti) setItems(characterData.oggetti);
    else setItems([]);
  }, [characterData]);

  const handleToggleEquip = (itemId) => equipMutation.mutate({ itemId, charId: characterData.id });

  const handleRecharge = (item) => {
      const costo = item.costo_ricarica || 0;
      const metodo = item.testo_ricarica || "Standard";
      if (window.confirm(`Ricaricare ${item.nome}?\nCosto: ${costo} CR\nMetodo: ${metodo}`)) {
          rechargeMutation.mutate({ oggetto_id: item.id, charId: characterData.id });
      }
  };

  const handleOpenAssembly = (item) => { setAssemblyHost(item); setShowAssembly(true); };
  const handleAssemblyComplete = () => { setShowAssembly(false); setAssemblyHost(null); };
  
  // Toggle ottimizzato
  const toggleExpand = useCallback((itemId) => {
      setExpandedItems(prev => ({ ...prev, [itemId]: !prev[itemId] }));
  }, []);

  if (isContextLoading) return <div className="p-8 text-center text-gray-500 flex justify-center"><Loader2 className="animate-spin" /></div>;
  if (!characterData) return <div className="p-4 text-center text-red-400">Nessun personaggio selezionato.</div>;

  const corpoItems = items.filter(i => ['INN', 'MUT'].includes(i.tipo_oggetto));
  const equipItems = items.filter(i => i.is_equipaggiato && i.tipo_oggetto === 'FIS');
  const zainoItems = items.filter(i => !i.is_equipaggiato && !['INN', 'MUT'].includes(i.tipo_oggetto));

  // Render Helper per liste (utilizza il componente Memoizzato)
    const renderList = (list) => (
        <LazyList 
            items={list} 
            batchSize={10} // Carica 10 elementi alla volta per fluidità immediata
            renderItem={(item) => (
                <InventoryItemCard 
                    key={item.id} 
                    item={item} 
                    isExpanded={!!expandedItems[item.id]}
                    onToggleExpand={toggleExpand}
                    onEquip={handleToggleEquip}
                    onRecharge={handleRecharge}
                    onAssembly={handleOpenAssembly}
                />
            )}
        />
    );
  
  const slots = {};
  const genericItems = [];
  corpoItems.forEach(item => {
      if (item.slot_corpo) {
          if (!slots[item.slot_corpo]) slots[item.slot_corpo] = [];
          slots[item.slot_corpo].push(item);
      } else genericItems.push(item);
  });

  return (
    <div className="pb-24 px-1 space-y-6 animate-fadeIn">
      <div className="flex justify-between items-center p-3 rounded-lg border border-gray-700 shadow-sm mb-4 sticky top-0 z-20 backdrop-blur-md bg-gray-800/90">
         <h2 className="text-xl font-bold text-white flex items-center gap-2"><Box className="text-indigo-400" /> Inventario</h2>
         <button onClick={() => setShowShop(true)} className="flex items-center gap-2 bg-yellow-600 hover:bg-yellow-500 text-white px-3 py-1.5 rounded-lg font-bold shadow-lg shadow-yellow-900/20 transition-all active:scale-95 text-xs sm:text-sm border border-yellow-500">
            <ShoppingBag size={16} /><span>Negozio</span>
         </button>
      </div>

      <section>
        <h3 className="text-sm font-bold text-indigo-300 mb-3 flex items-center gap-2 uppercase tracking-wider pl-1"><Activity size={16} /> Diagnostica Corporea</h3>
        {corpoItems.length > 0 ? (
            <div className="bg-gray-900/50 p-4 rounded-xl border border-gray-700 mb-6 flex flex-col md:flex-row items-center md:items-start gap-6">
                <div className="w-full md:w-1/3 flex flex-col items-center">
                    <InventoryBodyWidget slots={slots} onSlotClick={setSelectedBodyItem} selectedItemId={selectedBodyItem?.id} />
                    <p className="text-xs text-gray-500 mt-2 text-center italic">Clicca sulle zone colorate per i dettagli</p>
                </div>
                <div className="w-full md:w-2/3 flex flex-col gap-4">
                    <div className={`transition-all duration-300 origin-top ${selectedBodyItem ? 'opacity-100 scale-100' : 'opacity-0 scale-95 h-0 overflow-hidden'}`}>
                        {selectedBodyItem && (
                            <div className="bg-gray-800/80 border border-indigo-500/50 rounded-lg p-2 shadow-lg shadow-indigo-900/20 relative animate-fadeIn">
                                <div className="absolute top-2 right-2 z-10">
                                    <button onClick={() => setSelectedBodyItem(null)} className="text-gray-400 hover:text-white bg-gray-900 rounded-full p-1 border border-gray-600"><Info size={14}/></button>
                                </div>
                                <h4 className="text-xs uppercase tracking-widest text-indigo-400 font-bold mb-2 pl-1 flex items-center gap-2"><Activity size={12}/> Dettaglio Impianto</h4>
                                <InventoryItemCard 
                                    item={selectedBodyItem} 
                                    isExpanded={true} 
                                    onToggleExpand={()=>{}} 
                                    onEquip={handleToggleEquip}
                                    onRecharge={handleRecharge}
                                    onAssembly={handleOpenAssembly}
                                />
                            </div>
                        )}
                    </div>
                    {!selectedBodyItem && genericItems.length === 0 && <div className="hidden md:flex h-full items-center justify-center text-gray-600 italic text-sm p-8 border border-dashed border-gray-800 rounded-lg">Seleziona una parte del corpo per vedere l'innesto.</div>}
                    {genericItems.length > 0 && (
                        <div className="border-t border-gray-700 pt-4">
                            <h4 className="text-xs font-bold text-gray-500 uppercase mb-2">Potenziamenti Sistemici</h4>
                            {renderList(genericItems)}
                        </div>
                    )}
                </div>
            </div>
        ) : <p className="text-gray-600 italic text-sm p-4 text-center border border-dashed border-gray-700 rounded-lg bg-gray-800/30">Sistemi organici standard.</p>}
      </section>

      <section>
        <h3 className="text-sm font-bold text-emerald-300 mb-3 flex items-center gap-2 uppercase tracking-wider pl-1"><Shield size={16} /> Equipaggiamento Attivo</h3>
        {equipItems.length > 0 ? renderList(equipItems) : <p className="text-gray-600 italic text-sm p-4 text-center border border-dashed border-gray-700 rounded-lg bg-gray-800/30">Mani vuote.</p>}
      </section>

      <section>
        <h3 className="text-sm font-bold text-gray-400 mb-3 flex items-center gap-2 uppercase tracking-wider pl-1"><Box size={16} /> Zaino</h3>
        {zainoItems.length > 0 ? renderList(zainoItems) : <p className="text-gray-600 italic text-sm p-4 text-center border border-dashed border-gray-700 rounded-lg bg-gray-800/30">Zaino vuoto.</p>}
      </section>

      {showShop && <ShopModal onClose={() => setShowShop(false)} />}
      {showAssembly && assemblyHost && <ItemAssemblyModal hostItem={assemblyHost} inventory={items} onClose={() => { setShowAssembly(false); setAssemblyHost(null); }} onRefresh={handleAssemblyComplete} />}
    </div>
  );
};

export default InventoryTab;

==================================================
FILE: src\components\ItemAssemblyModal.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { 
    X, Wrench, Send, ShieldAlert, Shield, ShieldCheck, // <--- AGGIUNTO Shield e ShieldCheck
    Cpu, UserCheck, Loader2, Coins, GraduationCap, Trash2 
} from 'lucide-react';
import { useCharacter } from './CharacterContext';
import { validateAssembly, createAssemblyRequest, getCapableArtisans } from '../api'; 
import { useOptimisticAssembly } from '../hooks/useGameData';

const ItemAssemblyModal = ({ hostItem, inventory, onClose, onRefresh }) => {
  const { selectedCharacterData } = useCharacter();
  
  const [mode, setMode] = useState('INSTALL'); // 'INSTALL' o 'REMOVE'
  const [selectedMod, setSelectedMod] = useState(null); 
  
  // Stati validazione
  const [isValidating, setIsValidating] = useState(false);
  const [validationData, setValidationData] = useState(null);
  const [capableArtisans, setCapableArtisans] = useState([]);
  const [isLoadingArtisans, setIsLoadingArtisans] = useState(false);
  
  // Input Utente
  const [selectedTarget, setSelectedTarget] = useState(''); 
  const [offerCredits, setOfferCredits] = useState(0);
  
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);

  // --- MUTATIONS OTTIMISTICHE ---
  const installMutation = useOptimisticAssembly('monta');
  const removeMutation = useOptimisticAssembly('smonta');

  // Filtro oggetti installabili (Zaino)
  const compatibleMods = useMemo(() => {
     if (mode !== 'INSTALL') return [];
     return inventory.filter(item => {
        if (item.is_equipaggiato) return false;
        // Filtra per tipi compatibili (Mod, Materia, Potenziamento)
        if (!['MOD', 'MAT', 'POT'].includes(item.tipo_oggetto)) return false;
        return true; 
     });
  }, [inventory, mode]);

  const installedMods = hostItem.potenziamenti_installati || [];

  // Reset selezione al cambio modalità
  useEffect(() => {
    setSelectedMod(null);
    setValidationData(null);
    setError(null);
    setSuccess(null);
    setCapableArtisans([]);
  }, [mode]);

  // --- VALIDAZIONE & RECUPERO TECNICI ---
  useEffect(() => {
    if (selectedMod && selectedCharacterData) {
        setIsValidating(true);
        setValidationData(null);
        setCapableArtisans([]);
        setError(null);
        
        // LOGICA DIVERSIFICATA PER MODALITA'
        if (mode === 'INSTALL') {
            // Caso INSTALLAZIONE: Chiede al server se è compatibile
            validateAssembly(selectedCharacterData.id, hostItem.id, selectedMod.id)
                .then(data => {
                    setValidationData(data);
                    
                    // Se non può farlo da solo, cerca tecnici
                    if (data.is_valid && !data.can_do_self) {
                        fetchArtisans(data);
                    }
                })
                .catch(err => setError("Errore validazione: " + err.message))
                .finally(() => setIsValidating(false));
        } else {
            // Caso RIMOZIONE:
            // Simuliamo una validazione positiva per sbloccare la UI (l'oggetto è già lì)
            const mockValidation = {
                is_valid: true,
                can_do_self: true, // Di base proviamo a farla fare al PG
                can_use_academy: true, 
                warning: "Assicurati di avere le competenze o usa un tecnico."
            };
            setValidationData(mockValidation);
            setIsValidating(false);
            
            // Opzionale: Carica comunque i tecnici per la rimozione se vuoi
            // fetchArtisans(mockValidation);
        }
    }
  }, [selectedMod, hostItem.id, selectedCharacterData, mode]);

  // Funzione helper per caricare artigiani
  const fetchArtisans = (valData) => {
      setIsLoadingArtisans(true);
      getCapableArtisans(selectedCharacterData.id, hostItem.id, selectedMod.id, null)
          .then(artisans => setCapableArtisans(artisans))
          .finally(() => setIsLoadingArtisans(false));
  };


  // --- HANDLERS OTTIMISTICI ---

  const handleInstall = () => {
     if (!selectedMod) return;
     setIsProcessing(true);
     
     installMutation.mutate(
        { 
           host_id: hostItem.id, 
           mod_id: selectedMod.id, 
           charId: selectedCharacterData.id,
           useAcademy: false 
        },
        {
            onSuccess: () => {
                setSuccess("Installazione completata!");
                setTimeout(() => {
                    onRefresh(); 
                }, 1000);
            },
            onError: (err) => {
                setError("Errore installazione: " + err.message);
                setIsProcessing(false);
            }
        }
     );
  };

  const handleRemove = () => {
     if (!selectedMod) return;
     if (!window.confirm("Rimuovere questo componente?")) return;

     setIsProcessing(true);
     
     removeMutation.mutate(
        { 
           host_id: hostItem.id, 
           mod_id: selectedMod.id, 
           charId: selectedCharacterData.id,
           useAcademy: false
        },
        {
            onSuccess: () => {
                setSuccess("Componente rimosso!");
                setTimeout(() => {
                    onRefresh();
                }, 1000);
            },
            onError: (err) => {
                setError("Errore rimozione: " + err.message);
                setIsProcessing(false);
            }
        }
     );
  };

  const handleSendRequest = async () => {
     if (!selectedTarget) return;
     setIsProcessing(true);
     try {
        await createAssemblyRequest(
            selectedCharacterData.id, 
            hostItem.id, 
            selectedMod.id, 
            selectedTarget, 
            offerCredits,
            mode === 'INSTALL' ? 'INST' : 'RIMO'
        );
        setSuccess("Richiesta inviata con successo!");
        setTimeout(onClose, 2000);
     } catch (err) {
        setError(err.message);
     } finally {
        setIsProcessing(false);
     }
  };

  // Funzione per gestire l'uso dell'Accademia
  const handleAcademy = () => {
      if(!window.confirm("Usare i servizi dell'Accademia? (Costo in crediti maggiorato)")) return;
      
      const mutation = mode === 'INSTALL' ? installMutation : removeMutation;
      setIsProcessing(true);
      
      mutation.mutate(
        { 
           host_id: hostItem.id, 
           mod_id: selectedMod.id, 
           charId: selectedCharacterData.id,
           useAcademy: true 
        },
        {
            onSuccess: () => {
                setSuccess("Operazione completata dall'Accademia!");
                setTimeout(onRefresh, 1000);
            },
            onError: (err) => {
                setError("Errore Accademia: " + err.message);
                setIsProcessing(false);
            }
        }
     );
  };


  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm animate-fadeIn">
      <div className="bg-gray-900 w-full max-w-lg rounded-xl shadow-2xl border border-gray-700 flex flex-col max-h-[90vh]">
        
        {/* HEADER */}
        <div className="flex justify-between items-center p-4 border-b border-gray-800">
            <h3 className="text-lg font-bold text-white flex items-center gap-2">
                <Wrench className="text-amber-500"/> Assemblaggio
            </h3>
            <button onClick={onClose} className="text-gray-400 hover:text-white transition-colors">
                <X size={24} />
            </button>
        </div>

        {/* HOST ITEM INFO */}
        <div className="p-4 bg-gray-800/50 border-b border-gray-800 flex items-center gap-3">
             <div className="bg-gray-700 p-2 rounded">
                 <Cpu size={24} className="text-indigo-400"/>
             </div>
             <div>
                 <div className="text-xs text-gray-500 uppercase font-bold">Oggetto Ospite</div>
                 <div className="font-bold text-white">{hostItem.nome}</div>
             </div>
        </div>

        {/* TABS MODE */}
        <div className="flex border-b border-gray-700">
            <button 
                onClick={() => setMode('INSTALL')}
                className={`flex-1 py-3 text-sm font-bold uppercase transition-colors ${mode === 'INSTALL' ? 'bg-indigo-600 text-white' : 'hover:bg-gray-800 text-gray-400'}`}
            >
                Installa Mod
            </button>
            <button 
                onClick={() => setMode('REMOVE')}
                className={`flex-1 py-3 text-sm font-bold uppercase transition-colors ${mode === 'REMOVE' ? 'bg-red-900/50 text-red-200 border-b-2 border-red-500' : 'hover:bg-gray-800 text-gray-400'}`}
            >
                Rimuovi Mod
            </button>
        </div>

        {/* CONTENT SCROLLABLE */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
            
            {/* SELEZIONE MOD */}
            <div>
                <label className="block text-xs font-bold text-gray-500 uppercase mb-2">
                    {mode === 'INSTALL' ? 'Seleziona Componente da Zaino' : 'Seleziona Componente Installato'}
                </label>
                
                {mode === 'INSTALL' ? (
                    compatibleMods.length > 0 ? (
                        <div className="grid grid-cols-1 gap-2">
                            {compatibleMods.map(mod => (
                                <button 
                                    key={mod.id} 
                                    onClick={() => setSelectedMod(mod)}
                                    className={`p-3 rounded border text-left flex justify-between items-center transition-all ${selectedMod?.id === mod.id ? 'bg-indigo-900/40 border-indigo-500 ring-1 ring-indigo-500' : 'bg-gray-800 border-gray-700 hover:border-gray-500'}`}
                                >
                                    <span className="font-bold text-sm text-gray-200">{mod.nome}</span>
                                    <span className="text-xs text-gray-500">{mod.tipo_oggetto_display}</span>
                                </button>
                            ))}
                        </div>
                    ) : <p className="text-gray-500 italic text-sm text-center py-4">Nessun componente compatibile nello zaino.</p>
                ) : (
                    installedMods.length > 0 ? (
                        <div className="grid grid-cols-1 gap-2">
                            {installedMods.map(mod => (
                                <button 
                                    key={mod.id} 
                                    onClick={() => setSelectedMod(mod)}
                                    className={`p-3 rounded border text-left flex justify-between items-center transition-all ${selectedMod?.id === mod.id ? 'bg-red-900/20 border-red-500 ring-1 ring-red-500' : 'bg-gray-800 border-gray-700 hover:border-gray-500'}`}
                                >
                                    <span className="font-bold text-sm text-gray-200">{mod.nome}</span>
                                    <Trash2 size={16} className="text-red-400"/>
                                </button>
                            ))}
                        </div>
                    ) : <p className="text-gray-500 italic text-sm text-center py-4">Nessun componente installato su questo oggetto.</p>
                )}
            </div>

            {/* VALIDATION & ACTIONS */}
            {selectedMod && (
                <div className="animate-fadeIn space-y-4 border-t border-gray-700 pt-4">
                    
                    {/* INFO SELEZIONE */}
                    <div className="flex items-center gap-2 text-sm text-indigo-300 font-bold bg-indigo-900/20 p-2 rounded">
                        <Wrench size={16}/> 
                        {mode === 'INSTALL' ? `Installare ${selectedMod.nome}?` : `Rimuovere ${selectedMod.nome}?`}
                    </div>

                    {/* LOADING VALIDATION */}
                    {isValidating && <div className="text-center py-2"><Loader2 className="animate-spin inline text-indigo-400"/> <span className="text-xs text-gray-400">Verifica compatibilità...</span></div>}

                    {/* VALIDATION RESULT */}
                    {!isValidating && validationData && (
                        <div className={`text-sm p-3 rounded border ${validationData.is_valid ? 'bg-green-900/10 border-green-800' : 'bg-red-900/10 border-red-800'}`}>
                             {validationData.is_valid ? (
                                <div className="text-green-400 flex items-center gap-2">
                                    <ShieldCheck size={16}/> {mode === 'INSTALL' ? "Compatibilità confermata." : "Pronto per la rimozione."}
                                </div>
                             ) : (
                                <div className="text-red-400 flex items-center gap-2">
                                    <ShieldAlert size={16}/> {validationData.error_message || "Non compatibile."}
                                </div>
                             )}

                             {/* Warning/Info aggiuntivi */}
                             {validationData.warning && (
                                <div className="mt-1 text-xs text-yellow-500 italic">
                                    {validationData.warning}
                                </div>
                             )}

                             {/* Requisiti Skill */}
                             {validationData.requires_skill && (
                                <div className="mt-2 text-xs text-gray-400">
                                    Richiede abilità: <span className="text-white font-bold">{validationData.required_skill_name}</span>
                                    {validationData.can_do_self ? (
                                        <span className="text-green-500 ml-2">(Posseduta)</span>
                                    ) : (
                                        <span className="text-red-500 ml-2">(Mancante)</span>
                                    )}
                                </div>
                             )}
                        </div>
                    )}

                    {/* ACTION BUTTONS */}
                    <div className="flex gap-2 items-center">
                        {/* Fai da te */}
                        {validationData?.can_do_self && (
                            <button 
                                onClick={mode === 'INSTALL' ? handleInstall : handleRemove}
                                disabled={isProcessing}
                                className={`flex-1 text-white py-3 rounded-lg font-bold shadow-lg disabled:opacity-50 flex justify-center items-center gap-2
                                    ${mode === 'INSTALL' ? 'bg-emerald-600 hover:bg-emerald-500' : 'bg-red-600 hover:bg-red-500'}
                                `}
                            >
                                {isProcessing ? <Loader2 className="animate-spin"/> : <Wrench size={18}/>}
                                {mode === 'INSTALL' ? 'Procedi (Fai da te)' : 'Smonta (Fai da te)'}
                            </button>
                        )}
                        
                        {/* Accademia */}
                        {validationData?.can_use_academy && (
                            <button 
                                onClick={handleAcademy}
                                disabled={isProcessing}
                                className="flex-1 bg-blue-600 hover:bg-blue-500 text-white py-3 rounded-lg font-bold shadow-lg flex justify-center items-center gap-2"
                            >
                                <GraduationCap size={18}/> Accademia
                            </button>
                        )}
                    </div>

                    {/* RICHIESTA ARTIGIANO (Se non può fare da solo) */}
                    {(!validationData?.can_do_self || capableArtisans.length > 0) && (
                        <div className="bg-gray-800 p-3 rounded-lg border border-gray-700">
                            <h4 className="text-xs font-bold text-gray-400 uppercase mb-2">Richiedi a Tecnico</h4>
                            
                            {isLoadingArtisans ? (
                                <div className="text-center py-2"><Loader2 className="animate-spin inline"/></div>
                            ) : capableArtisans.length === 0 ? (
                                <p className="text-red-400 text-xs italic">Nessun tecnico disponibile al momento.</p>
                            ) : (
                                <>
                                    <select 
                                        className="w-full bg-gray-900 text-white border border-gray-600 rounded p-2 mb-2 text-sm"
                                        value={selectedTarget}
                                        onChange={(e) => setSelectedTarget(e.target.value)}
                                    >
                                        <option value="">-- Seleziona Tecnico --</option>
                                        {capableArtisans.map(a => (
                                            <option key={a.id} value={a.id}>{a.nome} (Liv {a.livello_tecnico})</option>
                                        ))}
                                    </select>
                                    {selectedTarget && (
                                        <div className="flex gap-2 mb-2">
                                            <div className="bg-gray-900 border border-gray-600 rounded px-3 flex items-center text-yellow-500">
                                                <Coins size={16}/>
                                            </div>
                                            <input 
                                                type="number" placeholder="Offerta CR"
                                                className="w-full bg-gray-800 border border-gray-600 rounded-lg p-2 pl-2 text-white h-full"
                                                value={offerCredits} onChange={e=>setOfferCredits(e.target.value)}
                                            />
                                        </div>
                                    )}
                                    <button 
                                        onClick={handleSendRequest}
                                        disabled={isProcessing || !selectedTarget}
                                        className="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-lg font-bold disabled:opacity-50 flex items-center gap-2 w-full justify-center"
                                    >
                                        <Send size={18}/> Invia Richiesta
                                    </button>
                                </>
                            )}
                        </div>
                    )}

                </div>
            )}

            {/* Feedback */}
            {error && <div className="p-3 bg-red-900/30 border border-red-800 rounded text-red-200 text-sm flex items-center gap-2"><ShieldAlert size={16}/> {error}</div>}
            {success && <div className="p-3 bg-emerald-900/30 border border-emerald-800 rounded text-emerald-200 text-sm font-bold text-center">{success}</div>}

        </div>
      </div>
    </div>
  );
};

export default ItemAssemblyModal;

==================================================
FILE: src\components\JobRequestsWidget.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { getAssemblyRequests, acceptAssemblyRequest, rejectAssemblyRequest } from '../api';
import { Check, X, Hammer, Loader2, User, Box } from 'lucide-react';

const JobRequestsWidget = ({ characterId }) => {
  const [requests, setRequests] = useState([]);
  const [loading, setLoading] = useState(true);
  const [processingId, setProcessingId] = useState(null); // Traccia quale richiesta stiamo gestendo

  // --- CARICAMENTO RICHIESTE ---
  const fetchRequests = async () => {
    try {
      const data = await getAssemblyRequests();
      // Filtra le richieste:
      // 1. Dove IO sono l'artigiano (artigiano === characterId)
      // 2. Che sono ancora IN ATTESA (stato === 'PEND')
      // Nota: Adatta 'PEND' se il tuo backend usa un codice diverso (es. 'IN_ATTESA')
      const myJobs = data.filter(r => 
        (r.artigiano === characterId || r.artigiano?.id === characterId) && 
        r.stato === 'PEND' 
      );
      setRequests(myJobs);
    } catch (error) {
      console.error("Errore caricamento richieste lavoro:", error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (characterId) fetchRequests();
    // Opzionale: Polling ogni 30 secondi per nuovi lavori
    const interval = setInterval(() => { if(characterId) fetchRequests(); }, 30000);
    return () => clearInterval(interval);
  }, [characterId]);

  // --- GESTIONE ACCETTAZIONE ---
  const handleAccept = async (reqId) => {
    setProcessingId(reqId);
    try {
      await acceptAssemblyRequest(reqId);
      // Rimuovi la richiesta dalla lista locale con animazione (simulata)
      setRequests(prev => prev.filter(r => r.id !== reqId));
      // Feedback utente (puoi sostituire con un toast notification)
      alert("Lavoro completato! I crediti sono stati trasferiti."); 
    } catch (error) {
      alert("Errore durante l'accettazione: " + error.message);
    } finally {
      setProcessingId(null);
    }
  };

  // --- GESTIONE RIFIUTO ---
  const handleReject = async (reqId) => {
    if(!confirm("Sei sicuro di voler rifiutare questo lavoro?")) return;
    
    setProcessingId(reqId);
    try {
      await rejectAssemblyRequest(reqId);
      setRequests(prev => prev.filter(r => r.id !== reqId));
    } catch (error) {
      alert("Errore durante il rifiuto: " + error.message);
    } finally {
      setProcessingId(null);
    }
  };

  // Se sta caricando o non ci sono richieste, non mostrare nulla (o mostra spinner)
  if (loading && requests.length === 0) return null;
  if (requests.length === 0) return null;

  return (
    <div className="mb-6 bg-gray-800 border border-amber-500/50 rounded-lg overflow-hidden shadow-lg animate-fadeIn ring-1 ring-amber-500/20">
      {/* Header Widget */}
      <div className="bg-amber-900/40 px-4 py-3 border-b border-amber-500/30 flex items-center justify-between">
        <div className="flex items-center gap-2">
            <Hammer className="text-amber-500" size={20} />
            <h3 className="font-bold text-amber-100 text-sm uppercase tracking-wider">
                Richieste di Lavoro ({requests.length})
            </h3>
        </div>
        <span className="flex h-2 w-2 relative">
            <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-amber-400 opacity-75"></span>
            <span className="relative inline-flex rounded-full h-2 w-2 bg-amber-500"></span>
        </span>
      </div>
      
      {/* Lista Richieste */}
      <div className="divide-y divide-gray-700">
        {requests.map(req => (
          <div key={req.id} className="p-4 flex flex-col md:flex-row justify-between items-start md:items-center gap-4 hover:bg-gray-700/30 transition-colors">
            
            {/* Dettagli Lavoro */}
            <div className="space-y-1 w-full">
              <div className="flex items-center gap-2 text-sm text-gray-300">
                <User size={14} className="text-indigo-400"/>
                <span className="font-bold text-white">{req.committente_nome || "Cliente"}</span> 
                <span>richiede installazione:</span>
              </div>
              
              <div className="flex items-center gap-2 bg-gray-900/50 p-2 rounded border border-gray-600/50">
                <Box size={16} className="text-cyan-400" />
                <span className="text-cyan-200 font-mono text-sm">{req.componente_nome}</span>
                <span className="text-gray-500">➔</span>
                <span className="text-emerald-200 font-mono text-sm">{req.host_nome}</span>
              </div>

              <div className="flex items-center gap-2 text-xs mt-1">
                 <span className="text-yellow-500 font-bold bg-yellow-500/10 px-2 py-0.5 rounded">
                    Offerta: {req.offerta_crediti} CR
                 </span>
                 <span className="text-gray-500">
                    {new Date(req.data_creazione).toLocaleDateString()}
                 </span>
              </div>
            </div>

            {/* Pulsanti Azione */}
            <div className="flex gap-2 w-full md:w-auto shrink-0">
              <button 
                onClick={() => handleAccept(req.id)}
                disabled={!!processingId}
                className="flex-1 md:flex-none bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed font-medium text-sm shadow-lg shadow-emerald-900/20"
              >
                {processingId === req.id ? <Loader2 className="animate-spin" size={16}/> : <Check size={16} />}
                Accetta
              </button>
              
              <button 
                onClick={() => handleReject(req.id)}
                disabled={!!processingId}
                className="flex-1 md:flex-none bg-red-900/30 hover:bg-red-900/60 text-red-300 border border-red-800/50 px-3 py-2 rounded-lg flex items-center justify-center gap-2 transition-all active:scale-95 disabled:opacity-50 text-sm"
              >
                <X size={16} />
                Rifiuta
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default JobRequestsWidget;

==================================================
FILE: src\components\LoginPage.jsx
==================================================
import React, { useState } from 'react';

const LoginPage = ({ onLoginSuccess }) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      const response = await fetch('https://www.kor35.it/auth/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, password }),
      });

      if (!response.ok) {
        throw new Error('Credenziali non valide. Riprova.');
      }

      const data = await response.json();

      if (data.token) {
        localStorage.setItem('kor35_token', data.token);
        localStorage.setItem('kor35_is_staff', data.is_staff);
        localStorage.setItem('kor35_is_master', data.is_superuser);
        
        // --- CORREZIONE FONDAMENTALE PER "t is not a function" ---
        // Controlliamo se la funzione esiste prima di chiamarla
        if (typeof onLoginSuccess === 'function') {
            onLoginSuccess(data.token);
        } else {
            // Se la funzione non c'è, ricarichiamo la pagina per ripristinare l'app
            console.warn("onLoginSuccess mancante, ricarico l'app...");
            window.location.reload();
        }
      } else {
        throw new Error('Token non ricevuto dal server.');
      }
    } catch (err) {
      console.error("Login error:", err);
      setError(err.message || 'Si è verificato un errore durante il login.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white p-4">
      <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-lg shadow-lg">
        <h1 className="text-3xl font-bold text-center text-indigo-400">KOR-35</h1>
        <h2 className="text-xl font-bold text-center">Login</h2>
        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label
              htmlFor="username"
              className="block text-sm font-medium text-gray-300"
            >
              Username
            </label>
            <input
              id="username"
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
              className="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-200 border border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
          </div>
          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-300"
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              className="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-200 border border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
          </div>
          {error && (
            <p className="text-sm text-center text-red-400">{error}</p>
          )}
          <div>
            <button
              type="submit"
              disabled={isLoading}
              className="w-full px-4 py-2 font-bold text-white bg-indigo-600 rounded-md shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isLoading ? 'Accesso in corso...' : 'Accedi'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default LoginPage;

==================================================
FILE: src\components\LogViewer.jsx
==================================================
import React, { useState } from 'react';
import { usePersonaggioLogs } from '../hooks/useGameData';

const LogViewer = () => {
  const [page, setPage] = useState(1);
  const { data, isLoading, isPlaceholderData } = usePersonaggioLogs(page);

  if (isLoading) return <div className="p-4 text-center">Caricamento log...</div>;

  return (
    <div className="log-container">
      <h3 className="text-xl font-bold mb-4">Registro Eventi</h3>
      
      <div className="space-y-2">
        {data?.results?.map((log, index) => (
          <div key={log.id || index} className="p-3 bg-gray-800 rounded border border-gray-700 text-sm">
            <div className="text-gray-400 text-xs mb-1">
              {new Date(log.data).toLocaleString()}
            </div>
            <div>{log.testo_log}</div>
          </div>
        ))}
      </div>

      {/* Controlli Paginazione */}
      <div className="flex justify-between mt-4">
        <button
          onClick={() => setPage(old => Math.max(old - 1, 1))}
          disabled={page === 1}
          className="px-4 py-2 bg-blue-600 rounded disabled:opacity-50"
        >
          Precedente
        </button>
        <span className="py-2">Pagina {page}</span>
        <button
          onClick={() => {
            if (!isPlaceholderData && data.next) {
              setPage(old => old + 1);
            }
          }}
          disabled={isPlaceholderData || !data?.next}
          className="px-4 py-2 bg-blue-600 rounded disabled:opacity-50"
        >
          Successivo
        </button>
      </div>
    </div>
  );
};

export default LogViewer;

==================================================
FILE: src\components\MainPage.jsx
==================================================
import React, { useState, useEffect } from 'react';
// --- LOGICA PWA ---
import { useRegisterSW } from 'virtual:pwa-register/react'; 
import { Link } from 'react-router-dom';

import HomeTab from './HomeTab.jsx';
import QrTab from './QrTab.jsx';
import QrResultModal from './QrResultModal.jsx';
import { useCharacter } from './CharacterContext';
import { TimerOverlay } from './TimerOverlay';
import { fetchAuthenticated } from '../api'; 
import packageInfo from '../../package.json';

import { 
    Home, QrCode, Zap, TestTube2, Scroll, LogOut, Mail, Backpack, 
    Menu, X, UserCog, RefreshCw, Filter, DownloadCloud, ScrollText, 
    ArrowRightLeft, Gamepad2, Loader2, ExternalLink, Tag, Users,
    Pin, PinOff, Briefcase, ClipboardCheck, Globe, ChevronRight
} from 'lucide-react';

import AbilitaTab from './AbilitaTab.jsx';
import MessaggiTab from './MessaggiTab.jsx';
import InfusioniTab from './InfusioniTab.jsx'; 
import TessitureTab from './TessitureTab.jsx'; 
import CerimonialiTab from './CerimonialiTab.jsx'; 
import AdminMessageTab from './AdminMessageTab.jsx';
import InventoryTab from './InventoryTab.jsx';
import LogViewer from './LogViewer.jsx';
import TransazioniViewer from './TransazioniViewer.jsx';
import GameTab from './GameTab.jsx';
import JobRequestsWidget from './JobRequestsWidget.jsx'; 
import PersonaggiTab from './PersonaggiTab.jsx';

// VERSIONE APP
const APP_VERSION = packageInfo.version;

// CONFIGURAZIONE TAB DISPONIBILI
const AVAILABLE_TABS = [
    { id: 'inventario', label: 'Zaino', icon: Backpack, component: InventoryTab },
    { id: 'abilita', label: 'Abilità', icon: Zap, component: AbilitaTab },
    { id: 'tessiture', label: 'Tessiture', icon: Scroll, component: TessitureTab },
    { id: 'infusioni', label: 'Infusioni', icon: TestTube2, component: InfusioniTab },
    { id: 'cerimoniali', label: 'Cerimoniali', icon: Users, component: CerimonialiTab },
    { id: 'qr', label: 'Scanner', icon: QrCode, component: QrTab },
    { id: 'messaggi', label: 'Messaggi', icon: Mail, component: MessaggiTab },
    { id: 'logs', label: 'Diario', icon: ScrollText, component: LogViewer },
    { id: 'transazioni', label: 'Transazioni', icon: ArrowRightLeft, component: TransazioniViewer },
    { id: 'personaggi', label: 'Personaggi', icon: Users, component: PersonaggiTab }, 
];

const DEFAULT_SHORTCUTS = ['inventario', 'abilita', 'messaggi', 'qr'];

const MainPage = ({ token, onLogout, isStaff, onSwitchToMaster }) => {
  const [activeTab, setActiveTab] = useState('game'); 
  const [qrResultData, setQrResultData] = useState(null);
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  
  // STATO SHORTCUTS (Default salvagente)
  const [userShortcuts, setUserShortcuts] = useState(DEFAULT_SHORTCUTS);

  // --- LOGICA PWA ---
  const {
    needRefresh: [needRefresh, setNeedRefresh],
    updateServiceWorker,
  } = useRegisterSW({
    onRegisterError(error) {
      console.log('SW registration error', error);
    },
  });

  // --- COOLDOWN FURTO ---
  const [stealCooldownEnd, setStealCooldownEnd] = useState(0);
  const [cooldownTimer, setCooldownTimer] = useState(0);
  const isStealingOnCooldown = Date.now() < stealCooldownEnd;

  useEffect(() => {
    if (isStealingOnCooldown) {
      const updateTimer = () => {
        const secondsLeft = Math.ceil((stealCooldownEnd - Date.now()) / 1000);
        setCooldownTimer(secondsLeft > 0 ? secondsLeft : 0);
      };
      updateTimer();
      const interval = setInterval(updateTimer, 1000);
      return () => clearInterval(interval);
    } else {
      setCooldownTimer(0);
    }
  }, [stealCooldownEnd, isStealingOnCooldown]);

  const handleStealSuccess = () => {
    setStealCooldownEnd(Date.now() + 30000);
    closeQrModal();
  };

  // --- CONTEXT ---
  const {
    personaggiList,
    selectedCharacterId,
    selectedCharacterData,
    refreshCharacterData,
    activeTimers,      
    removeTimerState,  
    selectCharacter,
    fetchPersonaggi,
    isLoading,
    isAdmin,
    viewAll,
    toggleViewAll,
    adminPendingCount,
    unreadCount, 
  } = useCharacter();

  // CARICAMENTO INIZIALE
  useEffect(() => {
    if (token) fetchPersonaggi();
  }, [token, fetchPersonaggi]);

  // --- EFFETTO REINDIRIZZAMENTO ---
  useEffect(() => {
      if (!selectedCharacterId && activeTab !== 'personaggi') {
          setActiveTab('personaggi');
      }
  }, [selectedCharacterId, activeTab]);

  // CARICAMENTO PREFERENZE UI DAL DB
  useEffect(() => {
      if (selectedCharacterData) {
          if (selectedCharacterData.impostazioni_ui?.shortcuts) {
              setUserShortcuts(selectedCharacterData.impostazioni_ui.shortcuts);
          } else {
              setUserShortcuts(DEFAULT_SHORTCUTS);
          }
      }
  }, [selectedCharacterData]);

  // SALVATAGGIO PREFERENZE
  const toggleShortcut = async (tabId) => {
      if (!selectedCharacterId) return;

      const oldShortcuts = [...userShortcuts];
      let newShortcuts;

      if (userShortcuts.includes(tabId)) {
          newShortcuts = userShortcuts.filter(id => id !== tabId);
      } else {
          if (userShortcuts.length >= 4) {
              alert("Puoi fissare al massimo 4 schede nella barra inferiore.");
              return;
          }
          newShortcuts = [...userShortcuts, tabId];
      }

      setUserShortcuts(newShortcuts);

      try {
          await fetchAuthenticated(`/personaggi/api/personaggi/${selectedCharacterId}/`, 
            {
              method: 'PATCH',
              headers: {
                  'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                  impostazioni_ui: { 
                      ...(selectedCharacterData.impostazioni_ui || {}),
                      shortcuts: newShortcuts 
                  }
              })
            }, 
            onLogout
          );
      } catch (error) {
          console.error("Errore salvataggio shortcuts", error);
          setUserShortcuts(oldShortcuts);
          alert("Impossibile salvare le preferenze sul server.");
      }
  };

  const handleScanSuccess = (jsonData) => setQrResultData(jsonData);
  const closeQrModal = () => setQrResultData(null);
  
  const handleMenuNavigation = (tabName) => {
    setActiveTab(tabName);
    setIsMenuOpen(false);
  };

  // --- NOTIFICHE ---
  const hasAdminNotif = isAdmin && adminPendingCount > 0;
  const hasMsgNotif = unreadCount > 0;
  const jobsCount = selectedCharacterData?.lavori_pendenti_count || 0; 
  const hasJobNotif = jobsCount > 0; 

  const renderTabContent = () => {
    if (activeTab === 'home') return <HomeTab />;
    if (activeTab === 'game') return <GameTab onNavigate={handleMenuNavigation} />;
    if (activeTab === 'admin_msg') return <AdminMessageTab onLogout={onLogout} />;

    const tabDef = AVAILABLE_TABS.find(t => t.id === activeTab);
    if (tabDef) {
        const Component = tabDef.component;
        if (tabDef.id === 'personaggi') {
            return <PersonaggiTab onLogout={onLogout} onSelectChar={() => setActiveTab('home')} />;
        }
        
        if (!selectedCharacterId && tabDef.id !== 'personaggi') {
            return (
                <div className="h-full flex flex-col items-center justify-center text-gray-500 gap-4">
                    <Users size={64} className="opacity-20"/>
                    <p className="text-lg font-bold">Nessun Personaggio Selezionato</p>
                    <button 
                        onClick={() => setActiveTab('personaggi')}
                        className="px-6 py-2 bg-indigo-600 text-white rounded-lg font-bold uppercase text-xs"
                    >
                        Vai alla selezione
                    </button>
                </div>
            );
        }
        if (tabDef.id === 'qr') return <QrTab onScanSuccess={handleScanSuccess} onLogout={onLogout} isStealingOnCooldown={isStealingOnCooldown} cooldownTimer={cooldownTimer} />;
        if (tabDef.id === 'logs' || tabDef.id === 'transazioni') return <div className="p-4 h-full overflow-y-auto"><Component charId={selectedCharacterId} /></div>;
        
        return <Component onLogout={onLogout} />;
    }
    return <HomeTab />;
  };

  // --- COMPONENTE INTERNO PER IL CONTENUTO DEL MENU (RIUTILIZZABILE) ---
  const MenuContent = () => (
    <div className="flex flex-col h-full overflow-hidden">
        {/* SELETTORE PERSONAGGIO E TAB */}
        <div className="flex-1 overflow-y-auto p-3 space-y-4 custom-scrollbar">
            
            {/* 1. SELETTORE PERSONAGGIO */}
            <div className="bg-gray-700/30 p-3 rounded-lg border border-gray-700">
                <label className="block text-xs font-bold text-gray-400 uppercase mb-2">Cambia Personaggio</label>
                <select 
                    className="w-full bg-gray-900 text-white p-2 rounded border border-gray-600 focus:border-indigo-500 outline-none text-sm"
                    value={selectedCharacterId || ''}
                    onChange={(e) => {
                        selectCharacter(e.target.value);
                        setIsMenuOpen(false); 
                    }}
                >
                    {personaggiList.map(p => (
                        <option key={p.id} value={p.id}>
                            {p.nome} {p.is_main ? '(Main)' : ''}
                        </option>
                    ))}
                </select>

                {/* 2. ADMIN VIEW ALL TOGGLE */}
                {isAdmin && (
                    <div className="mt-3 flex items-center justify-between pt-3 border-t border-gray-700">
                        <span className="text-sm text-gray-300 flex items-center gap-2">
                            <Filter size={16} /> Vedi tutti i PG
                        </span>
                        <button 
                            onClick={() => { toggleViewAll(); setIsMenuOpen(false); }}
                            className={`w-10 h-5 rounded-full relative transition-colors ${viewAll ? 'bg-green-600' : 'bg-gray-600'}`}
                        >
                            <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all ${viewAll ? 'left-6' : 'left-1'}`}></div>
                        </button>
                    </div>
                )}
            </div>

            {/* 3. LISTA TAB DI NAVIGAZIONE */}
            <div className="space-y-1">
                <p className="text-xs text-gray-500 uppercase font-bold px-1 mb-2 mt-2 flex justify-between items-center">
                    Menu Rapido 
                    <span className="text-[10px] font-normal normal-case opacity-70"><Pin size={10} className="inline"/> fissa in basso</span>
                </p>
                
                {AVAILABLE_TABS.map(tab => {
                    const isPinned = userShortcuts.includes(tab.id);
                    const isActive = activeTab === tab.id;
                    let badgeCount = 0;
                    let badgeColor = 'bg-gray-600';
                    if (tab.id === 'messaggi') { badgeCount = unreadCount; badgeColor = 'bg-purple-600'; }

                    return (
                        <div key={tab.id} className={`flex items-center justify-between p-2 rounded-lg transition-colors group ${isActive ? 'bg-indigo-900/40 border border-indigo-500/30' : 'hover:bg-gray-700/50 border border-transparent'}`}>
                            <button 
                                className="flex items-center gap-3 flex-1 text-left py-1"
                                onClick={() => handleMenuNavigation(tab.id)}
                            >
                                <tab.icon size={20} className={isActive ? "text-indigo-400" : "text-gray-400 group-hover:text-gray-200"} />
                                <span className={`${isActive ? "text-indigo-100 font-bold" : "text-gray-300 group-hover:text-white"}`}>
                                    {tab.label}
                                </span>
                                {badgeCount > 0 && (
                                    <span className={`ml-2 px-1.5 py-0.5 text-[10px] font-bold text-white rounded-full ${badgeColor}`}>
                                        {badgeCount}
                                    </span>
                                )}
                            </button>
                            
                            <button 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    toggleShortcut(tab.id);
                                }}
                                className={`p-2 rounded-full transition-colors ${isPinned ? 'text-amber-400 hover:bg-amber-400/10' : 'text-gray-600 hover:text-gray-400'}`}
                            >
                                {isPinned ? <Pin size={16} fill="currentColor" /> : <PinOff size={16} />}
                            </button>
                        </div>
                    );
                })}

                {/* LINK WIKI PUBBLICA (Style Uniformato) */}
                <div className="h-px bg-gray-700 my-2 mx-1"></div>
                <Link 
                    to="/" 
                    className="flex items-center gap-3 p-3 rounded-lg hover:bg-gray-700/50 text-gray-300 hover:text-white transition-colors border border-transparent hover:border-gray-600"
                    title="Torna al sito pubblico"
                >
                    <Globe size={20} className="text-gray-400"/>
                    <span className="font-bold">Wiki Pubblica</span>
                    <ChevronRight size={14} className="ml-auto opacity-50"/>
                </Link>
            </div>
        </div>

        {/* FOOTER (VERSIONE & UPDATE) */}
        <div className="p-4 border-t border-gray-700 bg-gray-900/80 shrink-0">
            <div className="flex justify-between items-center mb-3">
                <span className="text-xs text-gray-500 font-mono">v{APP_VERSION}</span>
                <button 
                    onClick={() => updateServiceWorker(true)} 
                    className={`flex items-center gap-2 px-3 py-1.5 rounded text-xs font-bold transition-all ${needRefresh ? 'bg-blue-600 text-white animate-pulse shadow-lg shadow-blue-500/20' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}
                >
                    <RefreshCw size={14} className={needRefresh ? "animate-spin" : ""} />
                    {needRefresh ? "AGGIORNA ORA" : "Verifica Agg."}
                </button>
            </div>
            
            {/* PULSANTE PROPOSTE PENDENTI (STAFF) */}
            {isStaff && adminPendingCount > 0 && (
                    <button
                    onClick={() => {
                        onSwitchToMaster('proposte'); 
                        setIsMenuOpen(false);
                    }}
                    className="w-full flex items-center gap-3 px-4 py-3 mb-2 text-orange-400 hover:bg-gray-700 transition-colors border border-orange-500/30 bg-orange-500/10 rounded-lg animate-pulse"
                >
                    <ClipboardCheck size={20} />
                    <span className="font-bold">PROPOSTE DA APPROVARE</span>
                    <span className="ml-auto bg-red-600 text-white text-xs px-2 py-0.5 rounded-full shadow-sm">
                        {adminPendingCount}
                    </span>
                </button>
            )}

            {/* PULSANTE VAI A STAFF DASHBOARD */}
            {isStaff && (
                <button
                    onClick={() => {
                        onSwitchToMaster(); 
                        setIsMenuOpen(false);
                    }}
                    className="w-full flex items-center gap-3 px-4 py-3 text-emerald-400 hover:bg-gray-700 transition-colors border-b border-gray-700 mb-2"
                >
                    <UserCog size={20} />
                    <span className="font-bold">DASHBOARD STAFF</span>
                </button>
            )}

            <button 
                onClick={onLogout} 
                className="w-full flex items-center justify-center gap-2 p-2 rounded bg-red-900/20 text-red-400 hover:bg-red-900/40 border border-red-900/50 transition-colors text-sm font-bold"
            >
                <LogOut size={16} /> Logout
            </button>
        </div>
    </div>
  );

  return (
    <div className="flex h-screen bg-gray-900 text-white overflow-hidden">
      
      {/* --- TIMER OVERLAY --- */}
      <TimerOverlay activeTimers={activeTimers} onRemove={removeTimerState} />
      
      {/* --- SIDEBAR DESKTOP (FISSA A SINISTRA) --- */}
      <aside className="hidden md:flex flex-col w-72 bg-gray-950 border-r border-gray-800 shadow-2xl z-20">
            <div className="p-4 border-b border-gray-900 flex items-center gap-3 h-16">
                 <div className="bg-indigo-900/50 p-1.5 rounded-lg border border-indigo-500/30">
                    <UserCog size={20} className="text-indigo-400"/>
                 </div>
                 <span className="font-black text-gray-200 italic tracking-widest uppercase text-sm">MENU UTENTE</span>
            </div>
            {/* Riutilizza il contenuto del menu */}
            <MenuContent />
      </aside>

      {/* --- WRAPPER CONTENUTO PRINCIPALE --- */}
      <div className="flex-1 flex flex-col min-w-0 relative">
          
          {/* --- HEADER --- */}
          <header className="relative flex justify-between items-center p-3 bg-gray-800 shadow-md shrink-0 border-b border-gray-700 z-10 h-16">
              <div className="flex items-center gap-3 z-20">
                  <img src="/pwa-512x512.png" alt="Logo" className="w-9 h-9 object-contain drop-shadow-lg" />
                  <h1 className="text-xl font-black italic hidden sm:block text-blue-400">KOR-35</h1>
              </div>

              <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-full text-center pointer-events-none z-10">
                {selectedCharacterData ? (
                    <div className="flex flex-col items-center justify-center">
                        <span className="text-xs text-gray-500 uppercase tracking-widest leading-none mb-0.5">Operativo</span>
                        <span className="font-bold text-white text-base tracking-wide drop-shadow-md">{selectedCharacterData.nome}</span>
                    </div>
                ) : <span className="text-gray-500 italic text-sm">Seleziona Personaggio</span>}
              </div>

              <div className="flex items-center gap-3 z-20">
                  {isLoading && <Loader2 size={20} className="text-indigo-400 animate-spin" />}
                  
                  {/* HAMBURGER VISIBILE SOLO SU MOBILE */}
                  <button onClick={() => setIsMenuOpen(true)} className="md:hidden relative p-2 rounded-full hover:bg-gray-700 transition-colors text-gray-200">
                    <Menu size={28} />
                    
                    {/* PALLINI NOTIFICHE HEADER */}
                    <div className="absolute top-1 right-1 flex flex-col gap-0.5 pointer-events-none">
                        {hasAdminNotif && <span className="block h-2.5 w-2.5 rounded-full ring-1 ring-gray-900 bg-red-600 animate-pulse shadow-sm" title="Admin Pending" />}
                        {hasMsgNotif && <span className="block h-2.5 w-2.5 rounded-full ring-1 ring-gray-900 bg-purple-500 shadow-sm" title="Messaggi" />}
                        {hasJobNotif && <span className="block h-2.5 w-2.5 rounded-full ring-1 ring-gray-900 bg-amber-500 shadow-sm" title="Lavori" />}
                        {needRefresh && <span className="block h-2.5 w-2.5 rounded-full ring-1 ring-gray-900 bg-blue-500 animate-bounce shadow-sm" title="Update" />}
                    </div>
                  </button>
              </div>
          </header>

          {/* --- DRAWER MENU MOBILE (OVERLAY A DESTRA) --- */}
          {/* Renderizzato condizionalmente o via CSS. Qui condizionale per semplicità React */}
          {isMenuOpen && (
            <div className="md:hidden fixed inset-0 z-50 flex justify-end">
                <div className="absolute inset-0 bg-black/60 backdrop-blur-sm transition-opacity" onClick={() => setIsMenuOpen(false)}></div>
                
                <div className="relative w-85 max-w-sm bg-gray-800 h-full shadow-2xl flex flex-col border-l border-gray-700 animate-slide-in-right overflow-hidden">
                    <div className="flex justify-between items-center p-4 border-b border-gray-700 bg-gray-900/50 shrink-0 h-16">
                        <h2 className="text-lg font-bold text-gray-100 uppercase tracking-wider flex items-center gap-2">
                            <UserCog size={20} className="text-indigo-400"/> Opzioni
                        </h2>
                        <button onClick={() => setIsMenuOpen(false)} className="text-gray-400 hover:text-white"><X size={24} /></button>
                    </div>
                    {/* Riutilizza il contenuto del menu */}
                    <MenuContent />
                </div>
            </div>
          )}

          {/* --- CONTENT --- */}
          <main className="flex-1 overflow-y-auto relative bg-gray-900 scrollbar-hide">
            {renderTabContent()}
          </main>

          {/* --- BOTTOM NAV --- */}
          <nav className="flex justify-around items-center bg-gray-800 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.3)] shrink-0 border-t border-gray-700 z-10 h-[60px] pb-safe">
            <TabButton icon={<Gamepad2 size={24} />} label="Game" isActive={activeTab === 'game'} onClick={() => setActiveTab('game')} />
            <TabButton icon={<Home size={24} />} label="Scheda" isActive={activeTab === 'home'} onClick={() => setActiveTab('home')} />
            
            <div className="w-px h-8 bg-gray-700 mx-1 opacity-50"></div>

            {userShortcuts.map(tabId => {
                const tab = AVAILABLE_TABS.find(t => t.id === tabId);
                if (!tab) return null;
                
                let showDot = false;
                let dotColor = 'bg-red-500';
                if (tab.id === 'messaggi' && hasMsgNotif) { showDot = true; dotColor = 'bg-purple-500'; }
                
                return (
                    <TabButton 
                        key={tabId}
                        icon={<tab.icon size={24} />} 
                        label={tab.label} 
                        isActive={activeTab === tabId} 
                        onClick={() => setActiveTab(tabId)} 
                        notificationDot={showDot}
                        dotColor={dotColor}
                    />
                );
            })}
          </nav>
      </div>

      {qrResultData && (
        <QrResultModal data={qrResultData} onClose={closeQrModal} onLogout={onLogout} onStealSuccess={handleStealSuccess} />
      )}
    </div>
  );
};

// Componente TabButton (Invariato)
const TabButton = ({ icon, label, isActive, onClick, notificationDot, dotColor }) => (
  <button onClick={onClick} className={`flex flex-col items-center justify-center p-1 min-w-14 h-full transition-all duration-200 ${isActive ? 'text-indigo-400' : 'text-gray-500 hover:text-gray-300'} focus:outline-none relative group`}>
    
    <div className={`transition-transform duration-200 ${isActive ? '-translate-y-1 scale-110' : 'group-active:scale-95'}`}>
        {icon}
        {notificationDot && (
            <span className={`absolute -top-1 -right-1 w-2.5 h-2.5 rounded-full border border-gray-800 ${dotColor}`}></span>
        )}
    </div>
    
    <span className={`text-[10px] font-medium tracking-tight mt-0.5 truncate max-w-16 ${isActive ? 'text-indigo-400' : 'text-gray-500'}`}>{label}</span>
    
    {isActive && (
        <div className="absolute bottom-0 w-8 h-0.5 bg-indigo-400 rounded-t-full shadow-[0_0_8px_rgba(99,102,241,0.6)]"></div>
    )}
  </button>
);

export default MainPage;

==================================================
FILE: src\components\MessaggiTab.jsx
==================================================
import React, { Fragment, useEffect } from 'react';
import { Tab } from '@headlessui/react';
import { useCharacter } from './CharacterContext';
import PlayerMessageTab from './PlayerMessageTab';
import AdminMessageTab from './AdminMessageTab';
import JobRequestsWidget from './JobRequestsWidget'; // <--- 1. Importa il Widget

function classNames(...classes) {
  return classes.filter(Boolean).join(' ');
}

const MessaggiTab = ({ onLogout }) => {
  const { selectedCharacterData: char, viewAll, unreadCount, fetchUserMessages, selectedCharacterId } = useCharacter();

  // Refresh messaggi quando si apre la tab
  useEffect(() => {
    if (selectedCharacterId) fetchUserMessages(selectedCharacterId);
  }, [selectedCharacterId, fetchUserMessages]);

  if (!char) return <div className="p-4 text-gray-400">Caricamento...</div>;

  // Mostra tab Admin solo se staff e non in view-all
  const showAdminTab = char.is_staff && !viewAll;

  return (
    <div className="w-full p-2 sm:p-4 pb-20">
      
      {/* --- 2. INSERISCI QUI IL WIDGET LAVORI --- */}
      {/* Apparirà sopra le tab, visibile subito se ci sono richieste */}
      <JobRequestsWidget characterId={char.id} />

      <Tab.Group>
        <Tab.List className="flex space-x-1 rounded-xl bg-gray-800 p-1 mb-4">
          <Tab as={Fragment}>
            {({ selected }) => (
              <button className={classNames(
                  'w-full rounded-lg py-2.5 text-sm font-medium leading-5 relative transition-all',
                  'focus:outline-none focus:ring-2 ring-offset-2 ring-offset-gray-800 ring-white ring-opacity-60',
                  selected ? 'bg-indigo-600 text-white shadow' : 'text-gray-400 hover:bg-gray-700 hover:text-white'
              )}>
                Ricevuti
                {unreadCount > 0 && (
                    <span className="absolute top-1 right-2 inline-flex items-center justify-center px-2 py-0.5 text-xs font-bold leading-none text-white bg-red-600 rounded-full shadow-sm animate-pulse">
                        {unreadCount > 99 ? '99+' : unreadCount}
                    </span>
                )}
              </button>
            )}
          </Tab>
          
          {showAdminTab && (
            <Tab as={Fragment}>
              {({ selected }) => (
                <button className={classNames(
                    'w-full rounded-lg py-2.5 text-sm font-medium leading-5 transition-all',
                    'focus:outline-none focus:ring-2 ring-offset-2 ring-offset-gray-800 ring-white ring-opacity-60',
                    selected ? 'bg-red-700 text-white shadow' : 'text-gray-400 hover:bg-gray-700 hover:text-white'
                )}>
                  Admin Area
                </button>
              )}
            </Tab>
          )}
        </Tab.List>

        <Tab.Panels>
          <Tab.Panel className="focus:outline-none animate-fadeIn">
            {/* Passiamo le props necessarie al componente figlio esistente */}
            <PlayerMessageTab onLogout={onLogout} />
          </Tab.Panel>
          
          {showAdminTab && (
            <Tab.Panel className="focus:outline-none animate-fadeIn">
              <AdminMessageTab onLogout={onLogout} />
            </Tab.Panel>
          )}
        </Tab.Panels>
      </Tab.Group>
    </div>
  );
};

export default MessaggiTab;

==================================================
FILE: src\components\ModelloAuraSelectionModal.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { X, Lock, AlertTriangle, CheckCircle, Info } from 'lucide-react';
import { getModelliAura, selezionaModelloAura } from '../api';
import { useCharacter } from './CharacterContext';
import IconaPunteggio from './IconaPunteggio';

const ModelloAuraSelectionModal = ({ aura, onClose }) => {
  const { selectedCharacterId, refreshCharacterData, onLogout } = useCharacter();
  const [modelli, setModelli] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selecting, setSelecting] = useState(null);

  useEffect(() => {
    const fetchModels = async () => {
      try {
        const data = await getModelliAura(aura.id);
        setModelli(data);
      } catch (err) {
        console.error(err);
        alert("Errore nel caricamento dei modelli");
        onClose();
      } finally {
        setLoading(false);
      }
    };
    if (aura?.id) {
        fetchModels();
    }
  }, [aura, onClose]);

  const handleSelect = async (modello) => {
    if (!window.confirm(`Sei sicuro di voler scegliere il modello "${modello.nome}"? Questa scelta NON può essere cambiata.`)) return;

    setSelecting(modello.id);
    try {
      await selezionaModelloAura(selectedCharacterId, modello.id, onLogout);
      await refreshCharacterData(); // Ricarica il PG per aggiornare la UI
      onClose();
    } catch (err) {
      alert("Errore durante la selezione: " + err.message);
      setSelecting(null);
    }
  };

  // Componente helper per renderizzare le liste di mattoni (proibiti o obbligatori)
  const RenderMattoniList = ({ title, items, icon: Icon, colorClass, titleClass }) => {
    if (!items || items.length === 0) return null;
    return (
      <div className="mb-2">
        <span className={`text-xs uppercase font-bold mb-1 flex items-center gap-1 ${titleClass}`}>
           <Icon size={10} /> {title}:
        </span>
        <div className="flex flex-wrap gap-2">
            {items.map(m => (
                <div key={m.id} title={m.nome} className={`flex items-center gap-1 bg-black/40 px-2 py-1 rounded border ${colorClass}`}>
                    {/* Assicurati che il serializer backend invii 'icona_url' o gestisci il path qui */}
                    <IconaPunteggio url={m.icona_url || m.icona} color={m.colore || 'white'} size="xs" mode="mask" />
                    <span className="text-xs text-gray-300">{m.nome}</span>
                </div>
            ))}
        </div>
      </div>
    );
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-80 p-4 backdrop-blur-sm">
      <div className="bg-gray-800 rounded-xl shadow-2xl border border-gray-700 w-full max-w-2xl max-h-[90vh] flex flex-col">
        
        {/* HEADER */}
        <div className="p-6 border-b border-gray-700 flex justify-between items-center shrink-0">
          <div>
              <h2 className="text-xl font-bold text-white flex items-center gap-2">
                  <div className="w-6 h-6" style={{ backgroundColor: aura.colore, maskImage: `url(${aura.icona_url})`, WebkitMaskImage: `url(${aura.icona_url})` }} />
                  Scegli Modello per {aura.nome}
              </h2>
              <p className="text-xs text-yellow-400 mt-1 flex items-center gap-1">
                  <AlertTriangle size={12} /> Attenzione: La scelta è definitiva!
              </p>
          </div>
          <button onClick={onClose} className="text-gray-400 hover:text-white"><X size={24} /></button>
        </div>

        {/* CONTENT */}
        <div className="p-6 overflow-y-auto custom-scrollbar">
          {loading ? (
             <p className="text-center text-gray-400">Caricamento modelli...</p>
          ) : (
             <>
             {modelli.length === 0 ? (
                <p className="text-center text-gray-400 py-4">Nessun modello disponibile per questa Aura.</p>
             ) : (
                 <div className="grid grid-cols-1 gap-4">
                    {modelli.map(mod => {
                        const hasObbligatori = mod.mattoni_obbligatori && mod.mattoni_obbligatori.length > 0;
                        const hasProibiti = mod.mattoni_proibiti && mod.mattoni_proibiti.length > 0;

                        return (
                            <div 
                                key={mod.id} 
                                onClick={() => !selecting && handleSelect(mod)}
                                className={`border border-gray-700 bg-gray-900 rounded-lg p-4 hover:border-kor-accent hover:bg-gray-800 cursor-pointer transition-all relative group ${selecting === mod.id ? 'opacity-50' : ''}`}
                            >
                                <div className="flex justify-between items-start mb-2">
                                    <h3 className="font-bold text-lg text-white group-hover:text-kor-accent transition-colors">{mod.nome}</h3>
                                    <div className="opacity-0 group-hover:opacity-100 transition-opacity">
                                        <span className="bg-kor-main text-white text-xs px-2 py-1 rounded shadow font-bold">Seleziona</span>
                                    </div>
                                </div>
                                
                                {/* DESCRIZIONE */}
                                {mod.descrizione && (
                                    <div className="text-sm text-gray-400 italic mb-4 border-l-2 border-gray-600 pl-2">
                                        {mod.descrizione}
                                    </div>
                                )}

                                {/* MATTONI OBBLIGATORI */}
                                <RenderMattoniList 
                                    title="Mattoni Obbligatori" 
                                    items={mod.mattoni_obbligatori} 
                                    icon={CheckCircle} 
                                    colorClass="border-green-800/50"
                                    titleClass="text-green-400"
                                />

                                {/* MATTONI PROIBITI */}
                                <RenderMattoniList 
                                    title="Mattoni Bloccati" 
                                    items={mod.mattoni_proibiti} 
                                    icon={Lock} 
                                    colorClass="border-red-800/50"
                                    titleClass="text-red-400"
                                />

                                {/* NESSUNA RESTRIZIONE */}
                                {!hasObbligatori && !hasProibiti && (
                                    <p className="text-xs text-green-400 italic mt-2 flex items-center gap-1">
                                        <CheckCircle size={10} /> Nessuna restrizione sui mattoni.
                                    </p>
                                )}
                            </div>
                        );
                    })}
                 </div>
             )}
             </>
          )}
        </div>
      </div>
    </div>
  );
};

export default ModelloAuraSelectionModal;

==================================================
FILE: src\components\NotificationPopup.jsx
==================================================
import React, { useEffect } from 'react';

const NotificationPopup = ({ notification, onClose }) => {
  if (!notification) return null;

  // Chiudi automaticamente dopo 10 secondi (10000 ms)
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose();
    }, 10000); // <--- MODIFICATO: Durata più lunga
    return () => clearTimeout(timer);
  }, [notification, onClose]);

  return (
    <div className="fixed top-5 right-5 z-50 max-w-sm w-full bg-white shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden animate-slide-in-right">
      <div className="p-4">
        <div className="flex items-start">
          <div className="shrink-0">
            <svg className="h-6 w-6 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
            </svg>
          </div>
          <div className="ml-3 w-0 flex-1 pt-0.5">
            <p className="text-sm font-medium text-gray-900">
              {notification.titolo}
            </p>
            
            {/* MODIFICA QUI: Renderizza HTML invece di testo puro */}
            <div 
                className="mt-1 text-sm text-gray-500"
                dangerouslySetInnerHTML={{ __html: notification.testo }}
            />
            
            <p className="mt-1 text-xs text-gray-400">
                Da: {notification.mittente}
            </p>
          </div>
          <div className="ml-4 shrink-0 flex">
            <button
              className="bg-white rounded-md inline-flex text-gray-400 hover:text-gray-500 focus:outline-none"
              onClick={onClose}
            >
              <span className="sr-only">Chiudi</span>
              <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NotificationPopup;

==================================================
FILE: src\components\PersonaggiTab.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { 
    createPersonaggio, 
    updatePersonaggio, 
    getTipologiePersonaggio,
    staffAddResources 
} from '../api';
import { useCharacter } from './CharacterContext';
import { 
    User, Users, Plus, Edit, X, ShieldAlert, Coins, Zap 
} from 'lucide-react';
import RichTextEditor from './RichTextEditor';

const PersonaggiTab = ({ onLogout, onSelectChar }) => {
    // Rimosso setPersonaggiList dal destructuring perché non esposto dal context
    const { 
        personaggiList, 
        fetchPersonaggi, 
        refreshCharacterData, 
        isStaff, 
        isAdmin, 
        viewAll, 
        toggleViewAll, 
        selectCharacter,
        selectedCharacterId 
    } = useCharacter();

    const queryClient = useQueryClient();

    // Stati Modale Edit/Create
    const [showModal, setShowModal] = useState(false);
    const [editMode, setEditMode] = useState(false);
    const [formData, setFormData] = useState({});
    const [tipologie, setTipologie] = useState([]);
    
    // Stati Modale Staff Risorse
    const [showResourceModal, setShowResourceModal] = useState(false);
    const [resourceData, setResourceData] = useState({ charId: null, charName: '', tipo: 'crediti', amount: 0, reason: '' });

    useEffect(() => {
        // Carica tipologie, gestendo eventuali errori silenziosamente
        getTipologiePersonaggio(onLogout).then(data => {
            if (Array.isArray(data)) setTipologie(data);
        });
        fetchPersonaggi();
    }, []);

    // --- GESTIONE MODALE CREATE/EDIT ---

    const handleOpenCreate = () => {
        setEditMode(false);
        setFormData({ 
            nome: '', 
            tipologia: 1, 
            testo: '', 
            costume: '' 
        });
        setShowModal(true);
    };

    const handleOpenEdit = (char, e) => {
        e.stopPropagation(); 
        setEditMode(true);
        
        // Logica robusta per estrarre l'ID della tipologia
        let tipoId = 1;
        if (char.tipologia) {
            if (typeof char.tipologia === 'number') {
                tipoId = char.tipologia;
            } else if (typeof char.tipologia === 'object' && char.tipologia.id) {
                tipoId = char.tipologia.id;
            } else if (typeof char.tipologia === 'string') {
                // Tenta di trovare l'ID dal nome o parse
                const found = tipologie.find(t => t.nome === char.tipologia);
                tipoId = found ? found.id : (parseInt(char.tipologia) || 1);
            }
        }

        setFormData({
            id: char.id,
            nome: char.nome,
            tipologia: tipoId,
            testo: char.testo || '',
            costume: char.costume || ''
        });
        setShowModal(true);
    };

    const handleSaveOptimistic = async () => {
        const payload = { ...formData };
        
        // Pulizia e validazione ID Tipologia per il backend
        if (payload.tipologia !== undefined) {
            const parsed = parseInt(payload.tipologia, 10);
            if (!isNaN(parsed)) {
                payload.tipologia = parsed;
            } else {
                delete payload.tipologia; // Evita errore 400 se invalido
            }
        }

        const queryKey = ['personaggi_list', viewAll];
        const previousData = queryClient.getQueryData(queryKey);

        // Update Ottimistico
        queryClient.setQueryData(queryKey, (oldList = []) => {
            // Assicuriamoci che oldList sia un array (fix per il bug della paginazione)
            const list = Array.isArray(oldList) ? oldList : []; 
            
            if (editMode) {
                return list.map(p => p.id === payload.id ? { ...p, ...payload } : p);
            } else {
                const tempId = 'temp-' + Date.now();
                return [...list, { 
                    ...payload, 
                    id: tempId, 
                    rango_label: '...', 
                    crediti: 0,
                    punti_caratteristica: 0,
                    tipologia: tipologie.find(t => t.id === payload.tipologia)?.nome || payload.tipologia 
                }];
            }
        });

        setShowModal(false);

        try {
            if (editMode) {
                await updatePersonaggio(payload.id, payload, onLogout);
                // Aggiorna dettagli se è il PG selezionato
                if (String(payload.id) === String(selectedCharacterId)) {
                    refreshCharacterData();
                }
            } else {
                await createPersonaggio(payload, onLogout);
            }
            // Sincronizzazione reale
            await fetchPersonaggi();

        } catch (error) {
            console.error("Errore salvataggio:", error);
            alert("Errore salvataggio: " + error.message);
            // Rollback
            if (previousData) queryClient.setQueryData(queryKey, previousData);
        }
    };

    // --- GESTIONE RISORSE STAFF ---

    const handleOpenResourceModal = (char, e) => {
        e.stopPropagation();
        setResourceData({ 
            charId: char.id, 
            charName: char.nome, 
            tipo: 'crediti', 
            amount: 0, 
            reason: 'Bonus Staff' 
        });
        setShowResourceModal(true);
    };

    const handleGiveResources = async () => {
        try {
            const resp = await staffAddResources(
                resourceData.charId, 
                resourceData.tipo, 
                parseInt(resourceData.amount), 
                resourceData.reason, 
                onLogout
            );
            alert(resp.msg || "Operazione completata");
            setShowResourceModal(false);
            fetchPersonaggi();
        } catch (error) {
            alert("Errore: " + error.message);
        }
    };

    const handleSelect = (charId) => {
        if (String(charId).startsWith('temp-')) return;
        selectCharacter(charId);
        if (onSelectChar) onSelectChar();
    };

    return (
        <div className="h-full flex flex-col bg-gray-900 text-white p-4 overflow-hidden">
            <div className="flex justify-between items-center mb-6 shrink-0">
                <h2 className="text-2xl font-black uppercase italic tracking-wider text-indigo-500">
                    Seleziona Personaggio
                </h2>
                
                <div className="flex gap-2">
                    {(isAdmin || isStaff) && (
                        <button 
                            onClick={toggleViewAll} 
                            className={`p-2 rounded-lg border ${viewAll ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-transparent border-gray-600 text-gray-400'}`}
                            title="Filtro Staff"
                        >
                            {viewAll ? <Users size={20}/> : <User size={20}/>}
                        </button>
                    )}
                    
                    <button 
                        onClick={handleOpenCreate} 
                        className="flex items-center gap-2 px-4 py-2 bg-emerald-600 rounded-lg font-bold uppercase text-xs tracking-widest hover:bg-emerald-500 transition-colors shadow-lg"
                    >
                        <Plus size={16}/> Nuovo PG
                    </button>
                </div>
            </div>

            <div className="flex-1 overflow-y-auto space-y-4 pb-20 custom-scrollbar">
                {/* Controllo di sicurezza: mappa solo se è un array */}
                {Array.isArray(personaggiList) && personaggiList.map(char => (
                    <div 
                        key={char.id} 
                        onClick={() => handleSelect(char.id)}
                        className={`relative group p-4 rounded-xl border transition-all cursor-pointer flex items-center justify-between
                            ${selectedCharacterId === String(char.id) 
                                ? 'bg-indigo-900/30 border-indigo-500 shadow-[0_0_15px_rgba(99,102,241,0.3)]' 
                                : 'bg-gray-800 border-gray-700 hover:border-gray-500 hover:bg-gray-750'
                            }`}
                    >
                        <div className="flex items-center gap-4">
                            <div className={`w-12 h-12 rounded-full flex items-center justify-center font-bold text-xl uppercase bg-gray-700 text-gray-300`}>
                                {char.nome ? char.nome.charAt(0) : '?'}
                            </div>
                            
                            <div>
                                <h3 className="font-bold text-lg leading-none">{char.nome}</h3>
                                {isStaff && (
                                    <div className="text-[10px] text-gray-400 mt-1 font-mono">
                                        CR: {char.crediti} | PC: {char.punti_caratteristica}
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="flex gap-2 opacity-50 group-hover:opacity-100 transition-opacity">
                            {(isStaff || isAdmin) && (
                                <>
                                    <button 
                                        onClick={(e) => handleOpenResourceModal(char, e)}
                                        className="p-2 bg-amber-900/50 border border-amber-700 rounded-full text-amber-400 hover:bg-amber-800 transition-colors"
                                    >
                                        <Coins size={16}/>
                                    </button>
                                    <button 
                                        onClick={(e) => handleOpenEdit(char, e)}
                                        className="p-2 bg-gray-900 rounded-full text-gray-400 hover:text-white hover:bg-indigo-600 transition-colors"
                                    >
                                        <Edit size={16}/>
                                    </button>
                                </>
                            )}
                        </div>
                    </div>
                ))}
            </div>

            {/* MODALE CREATE/EDIT */}
            {showModal && (
                <div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4 backdrop-blur-sm">
                    <div className="bg-gray-800 w-full max-w-3xl rounded-2xl border border-gray-700 shadow-2xl flex flex-col max-h-[95vh]">
                        <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                            <h3 className="font-black text-xl italic uppercase text-indigo-400">
                                {editMode ? 'Modifica Personaggio' : 'Nuovo Personaggio'}
                            </h3>
                            <button onClick={() => setShowModal(false)}><X className="text-gray-400 hover:text-white"/></button>
                        </div>
                        <div className="p-6 overflow-y-auto space-y-4">
                            <input 
                                className="w-full bg-gray-900 border border-gray-700 rounded p-3 text-xl font-bold text-white placeholder-gray-600"
                                value={formData.nome}
                                onChange={e => setFormData({...formData, nome: e.target.value})}
                                placeholder="Nome Personaggio"
                            />
                            
                            <RichTextEditor 
                                label="Background" 
                                value={formData.testo} 
                                onChange={val => setFormData({...formData, testo: val})}
                            />

                            {isStaff && (
                                <div className="p-4 bg-gray-900/50 rounded-xl border border-gray-700 space-y-4 mt-4">
                                    <div className="flex items-center gap-2 text-amber-500 font-bold text-xs uppercase tracking-widest">
                                        <ShieldAlert size={14}/> Area Staff
                                    </div>
                                    <div>
                                        <label className="block text-xs text-gray-500 mb-1">Tipologia</label>
                                        <select 
                                            className="w-full bg-gray-800 border border-gray-600 rounded p-2 text-white"
                                            value={formData.tipologia}
                                            onChange={e => setFormData({...formData, tipologia: parseInt(e.target.value)})}
                                        >
                                            {tipologie.map(t => <option key={t.id} value={t.id}>{t.nome}</option>)}
                                        </select>
                                    </div>
                                    <RichTextEditor 
                                        label="Note Costume" 
                                        value={formData.costume} 
                                        onChange={val => setFormData({...formData, costume: val})}
                                    />
                                </div>
                            )}
                        </div>
                        <div className="p-4 border-t border-gray-700">
                            <button 
                                onClick={handleSaveOptimistic}
                                className="w-full py-3 bg-indigo-600 hover:bg-indigo-500 rounded-xl font-bold uppercase transition-colors"
                            >
                                Salva
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* MODALE STAFF RISORSE */}
            {showResourceModal && (
                <div className="fixed inset-0 z-50 bg-black/90 flex items-center justify-center p-4">
                    <div className="bg-gray-800 w-full max-w-md rounded-2xl border border-amber-600 shadow-2xl p-6">
                        <h3 className="text-amber-500 font-bold text-lg uppercase mb-4 flex items-center gap-2">
                            <ShieldAlert size={20}/> Gestione Risorse: {resourceData.charName}
                        </h3>
                        
                        <div className="space-y-4">
                            <div className="grid grid-cols-2 gap-2">
                                <button 
                                    onClick={() => setResourceData({...resourceData, tipo: 'crediti'})}
                                    className={`p-3 rounded-lg border font-bold transition-all ${resourceData.tipo === 'crediti' ? 'bg-amber-600 border-amber-500 text-white' : 'border-gray-600 text-gray-400 hover:bg-gray-700'}`}
                                >
                                    <div className="flex flex-col items-center justify-center gap-1">
                                        <Coins size={20}/> Crediti
                                    </div>
                                </button>
                                <button 
                                    onClick={() => setResourceData({...resourceData, tipo: 'pc'})}
                                    className={`p-3 rounded-lg border font-bold transition-all ${resourceData.tipo === 'pc' ? 'bg-cyan-600 border-cyan-500 text-white' : 'border-gray-600 text-gray-400 hover:bg-gray-700'}`}
                                >
                                    <div className="flex flex-col items-center justify-center gap-1">
                                        <Zap size={20}/> Punti Caratt.
                                    </div>
                                </button>
                            </div>
                            <div>
                                <label className="block text-xs uppercase text-gray-500 mb-1">Quantità (+/-)</label>
                                <input 
                                    type="number"
                                    className="w-full bg-gray-900 border border-gray-700 rounded p-2 text-white font-mono text-xl text-center"
                                    value={resourceData.amount}
                                    onChange={e => setResourceData({...resourceData, amount: e.target.value})}
                                />
                            </div>
                            <div>
                                <label className="block text-xs uppercase text-gray-500 mb-1">Motivazione (Log)</label>
                                <input 
                                    type="text"
                                    className="w-full bg-gray-900 border border-gray-700 rounded p-2 text-white"
                                    placeholder="Es: Ricompensa Quest"
                                    value={resourceData.reason}
                                    onChange={e => setResourceData({...resourceData, reason: e.target.value})}
                                />
                            </div>
                        </div>

                        <div className="mt-6 flex gap-2">
                            <button onClick={() => setShowResourceModal(false)} className="flex-1 py-2 bg-gray-700 rounded hover:bg-gray-600">Annulla</button>
                            <button onClick={handleGiveResources} className="flex-1 py-2 bg-emerald-600 rounded font-bold hover:bg-emerald-500">Conferma</button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

export default PersonaggiTab;

==================================================
FILE: src\components\PlaceholderTab.jsx
==================================================
import React from 'react';

const PlaceholderTab = ({ tabName }) => (
  <div className="p-4 text-center text-gray-400">
    <h2 className="text-2xl font-bold mb-4">{tabName}</h2>
    <p>Questa scheda è in fase di sviluppo. Grazie.</p>
  </div>
);

export default PlaceholderTab;



==================================================
FILE: src\components\PlayerHeader.jsx
==================================================
import React, { useState } from 'react';
import GenericHeader from './GenericHeader';
import Sidebar from './Sidebar';
import { User, Shield, Package, Zap, MessageCircle, Lock } from 'lucide-react';

const PlayerHeader = ({ activeTab, onTabChange, onLogout, charName, charRank, isStaff, onSwitchToMaster }) => {
    const [isMenuOpen, setIsMenuOpen] = useState(false);

    const playerMenuItems = [
        { label: 'Personaggio', icon: <User size={18}/>, active: activeTab === 'home', action: () => onTabChange('home') },
        { label: 'Abilità', icon: <Shield size={18}/>, active: activeTab === 'abilita', action: () => onTabChange('abilita') },
        { label: 'Inventario', icon: <Package size={18}/>, active: activeTab === 'inventory', action: () => onTabChange('inventory') },
        { label: 'Tessiture', icon: <Zap size={18}/>, active: activeTab === 'tessiture', action: () => onTabChange('tessiture') },
        { label: 'Messaggi', icon: <MessageCircle size={18}/>, active: activeTab === 'messaggi', action: () => onTabChange('messaggi') },
    ];

    // Se è staff, aggiungi la voce al menu
    if (isStaff) {
        playerMenuItems.push({ label: '------------', icon: null, action: () => {} });
        playerMenuItems.push({ 
            label: 'Admin Dashboard', 
            icon: <Lock size={18} className="text-red-500"/>, 
            action: onSwitchToMaster 
        });
    }

    return (
        <>
            <GenericHeader 
                subtitle="Area Operativa" 
                onMenuClick={() => setIsMenuOpen(true)}
                rightSlot={
                    <div className="flex items-center gap-3">
                        {isStaff && (
                            <button onClick={onSwitchToMaster} className="hidden md:flex bg-red-900/30 hover:bg-red-900/50 text-red-400 px-3 py-1 rounded-lg text-xs font-bold uppercase tracking-wider border border-red-900/50 transition-colors">
                                Master Mode
                            </button>
                        )}
                        <div className="flex flex-col items-end text-[10px] font-bold uppercase tracking-tight">
                            <span className="text-indigo-400">{charName}</span>
                            <span className="text-gray-500">{charRank}</span>
                        </div>
                    </div>
                }
            />
            <Sidebar 
                isOpen={isMenuOpen} 
                onClose={() => setIsMenuOpen(false)} 
                title="Menu Personaggio"
                items={playerMenuItems} 
                onLogout={onLogout} 
            />
        </>
    );
};
export default PlayerHeader;

==================================================
FILE: src\components\PlayerMessageTab.jsx
==================================================
import React, { useState } from 'react';
import { useCharacter } from './CharacterContext';
import { Trash2, MailOpen, Mail } from 'lucide-react';
import DOMPurify from 'dompurify';
import ComposeMessageModal from './ComposeMessageModal';

// Icone SVG semplici (o puoi usare lucide-react se preferisci coerenza)
const TrashIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
    </svg>
);

const EnvelopeOpenIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 19v-8.93a2 2 0 01.89-1.664l7-4.666a2 2 0 012.22 0l7 4.666A2 2 0 0121 10.07V19M3 19a2 2 0 002 2h14a2 2 0 002-2M3 19l6.75-4.5M21 19l-6.75-4.5M3 10l6.75 4.5M21 10l-6.75 4.5m0 0l-1.14.76a2 2 0 01-2.22 0l-1.14-.76" />
    </svg>
);

const PlayerMessageTab = ({ onLogout }) => {
    // --- 1. DELEGA: Prendiamo dati e funzioni dal Context ---
    const { 
        selectedCharacterId,
        userMessages,       // La lista messaggi centralizzata
        fetchUserMessages,  // Funzione per ricaricare (usata dopo l'invio)
        handleMarkAsRead,   // Azione centralizzata (aggiorna anche il badge)
        handleDeleteMessage,// Azione centralizzata
        isLoading           // Loading globale
    } = useCharacter();

    const [isComposeOpen, setIsComposeOpen] = useState(false);
    // Stato locale solo per l'espansione UI, non per i dati
    const [expandedMsgId, setExpandedMsgId] = useState(null);

    const handleRead = (msgId, isAlreadyRead) => {
        // Gestione espansione locale
        if (expandedMsgId === msgId) {
            setExpandedMsgId(null);
            return;
        }
        setExpandedMsgId(msgId);

        // Se non letto, notifica il Context
        if (!isAlreadyRead) {
            handleMarkAsRead(msgId);
        }
    };

    // --- 2. RENDERING: Usiamo userMessages dal Context ---

    if (isLoading && (!userMessages || userMessages.length === 0)) {
        return <div className="p-4 text-center text-gray-400">Caricamento messaggi...</div>;
    }

    return (
        <div className="space-y-4 pb-4">
            {/* Header */}
            <div className="flex justify-between items-center mb-4">
                <div className="flex items-center gap-2">
                    <Mail className="text-indigo-400" size={24} />
                    <h2 className="text-xl font-bold text-white">Posta in Arrivo</h2>
                </div>
                <button 
                    onClick={() => setIsComposeOpen(true)}
                    className="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-lg text-sm font-bold shadow transition-all flex items-center gap-2"
                >
                    <EnvelopeOpenIcon /> Scrivi
                </button>
            </div>

            {/* Lista Messaggi */}
            {!userMessages || userMessages.length === 0 ? (
                <div className="flex flex-col items-center justify-center h-32 text-gray-500 border border-dashed border-gray-700 rounded-lg">
                    <MailOpen size={32} className="mb-2 opacity-20" />
                    <p>Nessun messaggio ricevuto.</p>
                </div>
            ) : (
                <div className="space-y-3">
                    {userMessages.map((msg) => {
                        // Nota: msg.letto arriva già corretto dal Context grazie alla modifica che abbiamo fatto prima
                        const isRead = msg.letto; 
                        const isExpanded = expandedMsgId === msg.id;
                        
                        // --- 3. CORREZIONE: Campo 'testo' e sicurezza ---
                        const testoSicuro = msg.testo || "";

                        return (
                            <div 
                                key={msg.id} 
                                onClick={() => handleRead(msg.id, isRead)}
                                className={`
                                    relative border rounded-lg p-4 cursor-pointer transition-all duration-200
                                    ${isRead ? 'bg-gray-800 border-gray-700 text-gray-300' : 'bg-gray-700 border-indigo-500/50 text-white shadow-md'}
                                    hover:bg-gray-750
                                `}
                            >
                                {/* Indicatore Non Letto */}
                                {!isRead && (
                                    <div className="absolute top-0 right-0 w-0 h-0 border-t-20 border-l-20 border-t-indigo-500 border-l-transparent z-10 shadow-sm" />
                                )}

                                <div className="flex justify-between items-start">
                                    <div className="flex-1 pr-8">
                                        {/* Titolo e Stato */}
                                        <div className="flex items-center gap-2 mb-1">
                                            {!isRead && <span className="w-2 h-2 rounded-full bg-indigo-500 animate-pulse"></span>}
                                            <h3 className={`font-bold text-base ${!isRead ? 'text-indigo-300' : ''}`}>
                                                {msg.titolo}
                                            </h3>
                                        </div>
                                        
                                        {/* Meta Info */}
                                        <div className="text-xs text-gray-400 mb-2 flex items-center gap-2">
                                            <span>Da: <span className="text-gray-200 font-semibold">{msg.mittente}</span></span>
                                            <span>•</span>
                                            <span>{new Date(msg.data_invio).toLocaleDateString('it-IT', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' })}</span>
                                            {msg.tipo_messaggio === 'BROAD' && (
                                                <span className="text-indigo-400 font-bold uppercase text-[10px] border border-indigo-500/30 px-1 rounded">Broadcast</span>
                                            )}
                                        </div>
                                        
                                        {/* Contenuto Messaggio (HTML Sicuro + Troncamento) */}
                                        <div className={`text-sm prose prose-invert max-w-none ${isRead ? 'text-gray-400' : 'text-gray-200'}`}>
                                            <div dangerouslySetInnerHTML={{ 
                                                __html: DOMPurify.sanitize(
                                                    isExpanded 
                                                        ? testoSicuro 
                                                        : testoSicuro.slice(0, 100) + (testoSicuro.length > 100 ? '...' : '')
                                                ) 
                                            }} />
                                        </div>
                                    </div>

                                    {/* Azioni */}
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); handleDeleteMessage(msg.id); }}
                                        className="text-gray-500 hover:text-red-400 p-2 rounded-full hover:bg-gray-600/50 transition-colors z-10"
                                        title="Cancella"
                                    >
                                        <TrashIcon />
                                    </button>
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}

            {/* Modale invio (delega il refresh al context) */}
            <ComposeMessageModal 
                isOpen={isComposeOpen} 
                onClose={() => setIsComposeOpen(false)}
                currentCharacterId={selectedCharacterId}
                onMessageSent={() => fetchUserMessages(selectedCharacterId)}
                onLogout={onLogout}
            />
        </div>
    );
};

export default PlayerMessageTab;

==================================================
FILE: src\components\PlotTab.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { 
    getEventi, associaQrAVista, getRisorseEditor,
    createEvento, updateEvento, deleteEvento,
    createGiorno, updateGiorno, deleteGiorno,
    createQuest, updateQuest, deleteQuest,
    addPngToQuest, addMostroToQuest, addVistaToQuest,
    removePngFromQuest, removeMostroFromQuest, removeVistaFromQuest,
    addFaseToQuest, removeFaseFromQuest,updateFase,
    addTaskToFase, removeTaskFromFase,
    // AGGIUNTI GLI IMPORT MANCANTI PER LO STAFF:
    staffCreateOffGame, staffDeleteOffGame,
    fetchAuthenticated 
} from '../api';
import { useCharacter } from './CharacterContext';
import { Plus, X, Save, Printer } from 'lucide-react';
import EventoSection from './EventoSection';
import GiornoSection from './GiornoSection';
import QrTab from './QrTab'; 
import RichTextEditor from './RichTextEditor';

const PlotTab = ({ onLogout }) => {
    const { isMaster } = useCharacter();
    const [eventi, setEventi] = useState([]);
    const [selectedEvento, setSelectedEvento] = useState(null);
    const [loading, setLoading] = useState(true);
    const [risorse, setRisorse] = useState({ png: [], templates: [], manifesti: [], inventari: [], staff: [] });
    
    const [editMode, setEditMode] = useState(null); 
    const [formData, setFormData] = useState({});
    const [scanningForVista, setScanningForVista] = useState(null);

    useEffect(() => { loadInitialData(); }, []);

    const loadInitialData = async () => {
        try {
            const [evData, risData] = await Promise.all([getEventi(onLogout), getRisorseEditor(onLogout)]);
            
            // Ordina eventi per data e trova il primo futuro
            const sortedEvents = evData.sort((a, b) => new Date(a.data_inizio) - new Date(b.data_inizio));
            const today = new Date().setHours(0,0,0,0);
            const nextEvent = sortedEvents.find(ev => new Date(ev.data_inizio) >= today) || sortedEvents[0];
            
            setEventi(sortedEvents);
            setRisorse(risData);
            if (nextEvent) setSelectedEvento(nextEvent);
        } catch (e) { console.error("Errore caricamento plot:", e); } finally { setLoading(false); }
    };

    const refreshData = async () => {
        const data = await getEventi(onLogout);
        const sorted = data.sort((a, b) => new Date(a.data_inizio) - new Date(b.data_inizio));
        setEventi(sorted);
        if (selectedEvento) {
            const updated = sorted.find(e => e.id === selectedEvento.id);
            setSelectedEvento(updated || sorted[0]);
        }
    };

    const formatDateForInput = (iso) => iso ? iso.split('T')[0] : '';
    const formatDateTimeForInput = (iso) => iso ? iso.slice(0, 16) : '';
    const formatTimeForInput = (time) => time ? time.slice(0, 5) : '';

    const startEdit = (tipo, oggetto = {}) => {
        setEditMode(tipo);
        setFormData({ ...oggetto });
    };

    const handleSaveMain = async () => {
        try {
            if (editMode === 'evento') {
                if (formData.id) await updateEvento(formData.id, formData, onLogout);
                else await createEvento(formData, onLogout);
            } else if (editMode === 'giorno') {
                const data = { ...formData, evento: selectedEvento.id };
                if (formData.id) await updateGiorno(formData.id, data, onLogout);
                else await createGiorno(data, onLogout);
            } else if (editMode === 'quest') {
                if (formData.id) await updateQuest(formData.id, formData, onLogout);
                else await createQuest(formData, onLogout);
            } else if (editMode === 'fase') { // <--- NUOVO BLOCCO
                if (formData.id) {
                    await updateFase(formData.id, formData, onLogout);
                }
             } 
            setEditMode(null);
            refreshData();
        } catch (e) { alert("Errore durante il salvataggio."); console.error(e); }
    };

    const handleDeleteEvento = async (id) => { if(window.confirm("Eliminare intero evento?")) { await deleteEvento(id, onLogout); refreshData(); } };
    const handleDeleteGiorno = async (id) => { if(window.confirm("Eliminare giorno?")) { await deleteGiorno(id, onLogout); refreshData(); } };

    const questHandlers = {
    onAddSub: async (tipo, payload) => {
        try {
            if (tipo === 'fase') await addFaseToQuest(payload, onLogout);
            if (tipo === 'task') await addTaskToFase(payload, onLogout);
            if (tipo === 'vista') {
                const vistaPayload = { 
                    quest: parseInt(payload.quest), 
                    tipo: payload.tipo, 
                    manifesto: payload.tipo === 'MAN' ? parseInt(payload.contentId) : null, 
                    inventario: payload.tipo === 'INV' ? parseInt(payload.contentId) : null 
                };
                await addVistaToQuest(payload.quest, vistaPayload, onLogout);
            }
            refreshData();
        } catch (error) {
            console.error("Errore aggiunta:", error);
            alert("Errore nell'operazione: " + error.message);
        }
    },
    onRemoveSub: async (tipo, id) => {
        if (tipo === 'fase') await removeFaseFromQuest(id, onLogout);
        if (tipo === 'task') await removeTaskFromFase(id, onLogout);
        if (tipo === 'vista') await removeVistaFromQuest(id, onLogout);
        if (tipo === 'quest') { if (window.confirm("Eliminare quest?")) await deleteQuest(id, onLogout); }
        refreshData();
    },
    onStatChange: async (id, field, delta) => {
        // Cerchiamo il task nell'albero dei dati per avere il valore attuale
        const allTasks = selectedEvento.giorni
            .flatMap(g => g.quests)
            .flatMap(q => q.fasi || [])
            .flatMap(f => f.tasks || []);
        
        const task = allTasks.find(t => t.id === id);
        if (!task) return;

        await fetchAuthenticated(`/plot/api/tasks/${id}/`, { 
            method: 'PATCH', 
            body: JSON.stringify({ [field]: (task[field] || 0) + delta }) 
        }, onLogout);
        refreshData();
    },
    onScanQr: (id) => setScanningForVista(id)
};

    if (loading) return <div className="h-full flex items-center justify-center bg-gray-900"><div className="animate-spin rounded-full h-12 w-12 border-t-2 border-indigo-500"></div></div>;

    const handlePrintEvent = () => {
        if (!selectedEvento || !selectedEvento.giorni) return;

        const printWindow = window.open('', '_blank');
        
        // --- FUNZIONI DI FORMATTAZIONE PER LA STAMPA ---
        const formatFullDate = (iso) => iso ? new Date(iso).toLocaleDateString('it-IT', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }) : 'Data da definire';
        const formatTime = (iso) => iso ? new Date(iso).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }) : '--:--';
        const formatTimeSimple = (timeStr) => timeStr ? timeStr.slice(0, 5) : 'N/D';

        // --- STILI CSS AVANZATI PER STAMPA ---
        const styles = `
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700;900&family=Merriweather:ital,wght@0,300;0,700;1,400&display=swap');
                
                @page { margin: 1.5cm; size: A4; }
                
                body { 
                    font-family: 'Roboto', sans-serif; 
                    color: #1a1a1a; 
                    line-height: 1.5; 
                    font-size: 10pt;
                    -webkit-print-color-adjust: exact; 
                }

                h1 { font-size: 26pt; text-transform: uppercase; border-bottom: 4px solid #000; margin-bottom: 5px; padding-bottom: 10px; font-weight: 900; }
                h2 { font-size: 18pt; margin-top: 0; background: #222; color: #fff; padding: 8px 15px; font-weight: 700; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
                h3 { font-size: 14pt; margin: 20px 0 10px 0; border-bottom: 2px solid #666; padding-bottom: 5px; color: #444; font-weight: 800; display: flex; justify-content: space-between; }
                h4 { font-size: 12pt; margin: 15px 0 5px 0; color: #2563eb; font-weight: 700; text-transform: uppercase; border-left: 4px solid #2563eb; padding-left: 10px; }

                .meta { font-size: 11pt; color: #666; margin-bottom: 20px; font-style: italic; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
                
                /* Box Informativi */
                .box-synopsis { background-color: #f3f4f6; padding: 15px; border-left: 5px solid #000; margin-bottom: 30px; font-family: 'Merriweather', serif; text-align: justify; }
                .box-master { background-color: #e0e7ff; padding: 10px; border: 1px solid #c7d2fe; margin-bottom: 15px; font-size: 9pt; }
                .box-props { background-color: #fff7ed; padding: 10px; border: 1px solid #ffedd5; margin: 10px 0; font-size: 9pt; page-break-inside: avoid; }

                /* Struttura Giorni */
                .day-container { margin-bottom: 40px; page-break-before: always; }
                .day-container:first-of-type { page-break-before: auto; }
                .day-meta { font-size: 12pt; font-weight: bold; margin-bottom: 15px; color: #444; }

                /* Struttura Quest */
                .quest-block { margin-bottom: 30px; }
                .quest-desc { font-family: 'Merriweather', serif; margin-bottom: 15px; }

                /* Task Grid */
                .task-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
                .task-card { border: 1px solid #ccc; padding: 8px; font-size: 9pt; background: #fff; page-break-inside: avoid; box-shadow: 2px 2px 0px #eee; }
                .task-header { font-weight: 900; border-bottom: 1px solid #eee; padding-bottom: 4px; margin-bottom: 4px; display: flex; justify-content: space-between; align-items: center; }
                .task-role { font-size: 7pt; color: #fff; padding: 2px 5px; border-radius: 3px; font-weight: bold; text-transform: uppercase; }
                .bg-png { background-color: #4f46e5; }
                .bg-mostro { background-color: #dc2626; }
                .bg-off { background-color: #4b5563; }
                .stats { font-family: monospace; font-weight: bold; margin-top: 5px; font-size: 8pt; color: #666; background: #f9f9f9; padding: 2px; text-align: center; }

                /* Rich Text Reset per stampa */
                .rich-text p { margin-bottom: 8px; margin-top: 0; }
                .rich-text ul, .rich-text ol { padding-left: 20px; margin: 5px 0; }
                .rich-text li { margin-bottom: 2px; }
                strong { font-weight: 900; }
            </style>
        `;

        // --- BODY HTML ---
        let content = `
            <html>
            <head><title>Report Plot: ${selectedEvento.titolo}</title>${styles}</head>
            <body>
                <h1>${selectedEvento.titolo}</h1>
                <div class="meta">
                    <strong>Periodo:</strong> ${formatFullDate(selectedEvento.data_inizio)} - ${formatFullDate(selectedEvento.data_fine)} <br/>
                    <strong>Luogo:</strong> ${selectedEvento.luogo || 'Non specificato'} | 
                    <strong>PC Globali:</strong> ${selectedEvento.pc_guadagnati || 0}
                </div>
                
                ${selectedEvento.sinossi ? `
                    <div class="box-synopsis">
                        <div style="font-weight:bold; text-transform:uppercase; font-size:9pt; color:#666; margin-bottom:5px;">Sinossi Evento</div>
                        <div class="rich-text">${selectedEvento.sinossi}</div>
                    </div>
                ` : ''}
        `;

        // Loop Giorni
        selectedEvento.giorni.forEach((giorno, idx) => {
            content += `
                <div class="day-container">
                    <h2>GIORNO ${idx + 1}: ${giorno.titolo || 'Senza Titolo'}</h2>
                    <div class="day-meta">
                        Data: ${formatFullDate(giorno.data_ora_inizio)} | 
                        Orario: ${formatTime(giorno.data_ora_inizio)} - ${formatTime(giorno.data_ora_fine)}
                    </div>

                    ${giorno.sinossi_breve ? `<p class="rich-text"><strong>Sinossi Breve:</strong> ${giorno.sinossi_breve}</p>` : ''}
                    
                    ${giorno.descrizione_completa ? `
                        <div class="box-master">
                            <strong>Note Master / Descrizione Completa:</strong><br/>
                            <div class="rich-text">${giorno.descrizione_completa}</div>
                        </div>
                    ` : ''}
            `;

            // Loop Quest (Ordinate per orario)
            if (giorno.quests && giorno.quests.length > 0) {
                // Ordina quest per orario
                const questsOrdinate = [...giorno.quests].sort((a, b) => 
                    (a.orario_indicativo || '00:00').localeCompare(b.orario_indicativo || '00:00')
                );

                questsOrdinate.forEach(quest => {
                    content += `
                        <div class="quest-block">
                            <h3>
                                <span>${quest.titolo}</span>
                                <span>${formatTimeSimple(quest.orario_indicativo)}</span>
                            </h3>
                            
                            <div class="quest-desc rich-text">
                                ${quest.descrizione_ampia || quest.descrizione || '<em style="color:#999">Nessuna descrizione disponibile.</em>'}
                            </div>

                            ${quest.props ? `
                                <div class="box-props">
                                    <strong>OGGETTI DI SCENA (PROPS):</strong>
                                    <div class="rich-text">${quest.props}</div>
                                </div>
                            ` : ''}
                    `;

                    // Loop Fasi
                    if (quest.fasi && quest.fasi.length > 0) {
                        const fasiOrdinate = [...quest.fasi].sort((a,b) => a.ordine - b.ordine);
                        
                        fasiOrdinate.forEach(fase => {
                            content += `
                                <div>
                                    <h4>FASE ${fase.ordine}: ${fase.titolo}</h4>
                                    ${fase.descrizione ? `<div class="rich-text" style="font-size:9pt; margin-bottom:5px; padding-left:10px; color:#555;">${fase.descrizione}</div>` : ''}
                            `;

                            // Loop Tasks
                            if (fase.tasks && fase.tasks.length > 0) {
                                content += `<div class="task-grid">`;
                                fase.tasks.forEach(task => {
                                    const nomeTarget = task.personaggio_details?.nome 
                                        || task.mostro_details?.nome 
                                        || (task.compito_offgame === 'REG' ? 'Gestione Regole' : task.compito_offgame === 'AIU' ? 'Aiuto Master' : 'Allestimento');
                                    
                                    let ruoloClass = 'bg-off';
                                    if(task.ruolo === 'PNG') ruoloClass = 'bg-png';
                                    if(task.ruolo === 'MOSTRO') ruoloClass = 'bg-mostro';
                                    
                                    content += `
                                        <div class="task-card">
                                            <div class="task-header">
                                                <span>${nomeTarget}</span>
                                                <span class="task-role ${ruoloClass}">${task.ruolo}</span>
                                            </div>
                                            <div style="margin-bottom:4px; font-size:8pt; color:#666;">
                                                <strong>Staff:</strong> @${task.staffer_details?.username || 'N/D'}
                                                ${task.ruolo === 'PNG' ? `(PnG di ${task.personaggio_details?.proprietario || 'N/D'})` : ''}
                                            </div>
                                            
                                            ${task.istruzioni ? `<div class="rich-text">${task.istruzioni}</div>` : ''}
                                            
                                            ${task.ruolo === 'MOSTRO' ? `
                                                <div class="stats">
                                                    PV: ${task.punti_vita} | SC: ${task.schermo || task.guscio || 0} | ARM: ${task.armatura}
                                                </div>
                                                ${task.mostro_details?.costume ? `<div style="margin-top:4px; font-size:8pt;"><strong>Costume:</strong> ${task.mostro_details.costume}</div>` : ''}
                                            ` : ''}
                                        </div>
                                    `;
                                });
                                content += `</div>`; // close grid
                            } else {
                                content += `<div style="font-style:italic; font-size:9pt; color:#aaa; margin-left:10px;">Nessun incarico assegnato.</div>`;
                            }
                            content += `</div>`; // close fase div
                        });
                    } else {
                        content += `<p style="margin-left:10px;">Nessuna fase operativa definita.</p>`;
                    }
                    content += `</div>`; // close quest-block
                });
            } else {
                content += `<p>Nessuna quest pianificata per questo giorno.</p>`;
            }
            content += `</div>`; // close day-container
        });

        content += `
            <script>
                window.onload = function() { window.print(); }
            </script>
            </body></html>
        `;

        printWindow.document.write(content);
        printWindow.document.close();
    };

    return (
        <div className="flex flex-col h-full bg-gray-900 text-white pb-20 overflow-hidden">
            <div className="p-4 bg-gray-950 border-b border-gray-800 flex gap-2 z-40 shadow-xl">
                <select className="flex-1 bg-gray-900 p-3 rounded-xl border border-gray-800 font-black text-indigo-400 outline-none cursor-pointer"
                    value={selectedEvento?.id || ''} onChange={(e) => setSelectedEvento(eventi.find(ev => ev.id === parseInt(e.target.value)))}>
                    {eventi.map(ev => <option key={ev.id} value={ev.id}>{ev.titolo.toUpperCase()}</option>)}
                </select>
                {isMaster && (
                    <button onClick={() => startEdit('evento')} className="p-3 bg-indigo-600 rounded-xl hover:bg-indigo-500 transition-colors shadow-lg"><Plus size={24}/></button>
                )}
                <button 
                    onClick={handlePrintEvent}
                    className="p-2 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg transition-colors shadow-lg shadow-indigo-900/20 flex items-center gap-2"
                    title="Stampa Report Completo"
                >
                    <Printer size={20} />
                    <span className="hidden md:inline font-bold text-xs uppercase">Stampa Report</span>
                </button>
            </div>

            {editMode && (
                <div className="fixed inset-0 z-100 bg-black/90 flex items-center justify-center p-4 backdrop-blur-sm">
                    <div className="bg-gray-800 p-6 rounded-2xl w-full max-w-3xl border-t-4 border-indigo-500 shadow-2xl overflow-y-auto max-h-[90vh]">
                        <div className="flex justify-between items-center mb-6">
                            <h3 className="text-xl font-black uppercase text-indigo-400 italic tracking-widest">Editor {editMode}</h3>
                            <button onClick={() => setEditMode(null)} className="p-2 hover:bg-gray-700 rounded-full transition-colors"><X/></button>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {/* ... Codice form invariato ... */}
                            {editMode === 'evento' && (
                                <>
                                    <div className="md:col-span-2">
                                        <label className="text-[10px] font-bold text-gray-500 uppercase px-1">Titolo</label>
                                        <input className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700 focus:border-indigo-500 outline-none" value={formData.titolo || ''} onChange={e => setFormData({...formData, titolo: e.target.value})} />
                                    </div>
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase px-1">Inizio</label><input type="date" className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formatDateForInput(formData.data_inizio)} onChange={e => setFormData({...formData, data_inizio: e.target.value})} /></div>
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase px-1">Fine</label><input type="date" className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formatDateForInput(formData.data_fine)} onChange={e => setFormData({...formData, data_fine: e.target.value})} /></div>
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase px-1">Luogo</label><input className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formData.luogo || ''} onChange={e => setFormData({...formData, luogo: e.target.value})} /></div>
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase px-1">PC Guadagnati</label><input type="number" className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formData.pc_guadagnati || 0} onChange={e => setFormData({...formData, pc_guadagnati: e.target.value})} /></div>
                                    <div className="md:col-span-2">
                                        <RichTextEditor label="Sinossi" value={formData.sinossi} onChange={val => setFormData({...formData, sinossi: val})} />
                                    </div>
                                </>
                            )}
                            {editMode === 'giorno' && (
                                <>
                                    <div className="md:col-span-2">
                                        <label className="text-[10px] font-bold text-gray-500 uppercase px-1">Titolo Giorno</label>
                                        <input className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700 focus:border-indigo-500 outline-none" value={formData.titolo || ''} onChange={e => setFormData({...formData, titolo: e.target.value})} />
                                    </div>
                                    <div className="md:col-span-2">
                                        <RichTextEditor label="Sinossi Breve (Sottotitolo)" value={formData.sinossi_breve} onChange={val => setFormData({...formData, sinossi_breve: val})} />
                                    </div>
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-500 uppercase px-1">Inizio (Data/Ora)</label>
                                        <input type="datetime-local" className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formatDateTimeForInput(formData.data_ora_inizio)} onChange={e => setFormData({...formData, data_ora_inizio: e.target.value})} />
                                    </div>
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-500 uppercase px-1">Fine (Data/Ora)</label>
                                        <input type="datetime-local" className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formatDateTimeForInput(formData.data_ora_fine)} onChange={e => setFormData({...formData, data_ora_fine: e.target.value})} />
                                    </div>
                                    <div className="md:col-span-2">
                                        <RichTextEditor label="Descrizione Plot Completa (Info Master)" value={formData.descrizione_completa} onChange={val => setFormData({...formData, descrizione_completa: val})} />
                                    </div>
                                </>
                            )}
                            {editMode === 'quest' && (
                                <>
                                    <div className="md:col-span-2"><label className="text-[10px] font-bold text-gray-500 uppercase px-1">Titolo Quest</label><input className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formData.titolo || ''} onChange={e => setFormData({...formData, titolo: e.target.value})} /></div>
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase px-1">Orario</label><input type="time" className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" value={formatTimeForInput(formData.orario_indicativo)} onChange={e => setFormData({...formData, orario_indicativo: e.target.value})} /></div>
                                    <div className="md:col-span-2">
                                        <RichTextEditor label="Descrizione Ampia" value={formData.descrizione_ampia} onChange={val => setFormData({...formData, descrizione_ampia: val})} />
                                    </div>
                                    <div className="md:col-span-2">
                                        <RichTextEditor label="Props (Materiale di scena)" value={formData.props} onChange={val => setFormData({...formData, props: val})} />
                                    </div>
                                </>
                            )}
                            {editMode === 'fase' && (
                                <>
                                    <div className="md:col-span-2">
                                        <label className="text-[10px] font-bold text-gray-500 uppercase px-1">Titolo Fase</label>
                                        <input className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" 
                                            value={formData.titolo || ''} 
                                            onChange={e => setFormData({...formData, titolo: e.target.value})} />
                                    </div>
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-500 uppercase px-1">Ordine</label>
                                        <input type="number" className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700" 
                                            value={formData.ordine || 0} 
                                            onChange={e => setFormData({...formData, ordine: parseInt(e.target.value)})} />
                                    </div>
                                    <div className="md:col-span-2">
                                        <label className="text-[10px] font-bold text-gray-500 uppercase px-1">Descrizione (Opzionale)</label>
                                        <textarea className="w-full bg-gray-900 p-3 rounded-lg border border-gray-700 h-24 resize-none" 
                                            value={formData.descrizione || ''} 
                                            onChange={e => setFormData({...formData, descrizione: e.target.value})} />
                                    </div>
                                </>
                            )}
                        </div>
                        <button onClick={handleSaveMain} className="w-full mt-6 bg-indigo-600 py-4 rounded-xl font-black uppercase tracking-widest hover:bg-indigo-500 transition-all flex items-center justify-center gap-2">
                            <Save size={20}/> Salva {editMode}
                        </button>
                    </div>
                </div>
            )}

            <div className="flex-1 overflow-y-auto custom-scrollbar">
                {selectedEvento && (
                    <EventoSection 
                        evento={selectedEvento} 
                        isMaster={isMaster} 
                        risorse={risorse}
                        onEdit={startEdit} 
                        onDelete={handleDeleteEvento}
                        onUpdateEvento={(id, data) => { updateEvento(id, data, onLogout); refreshData(); }}
                        onAddGiorno={() => startEdit('giorno')}
                    />
                )}
                <div className="p-4 space-y-16">
                    {selectedEvento?.giorni.map((giorno, gIdx) => (
                        <GiornoSection key={giorno.id} giorno={giorno} gIdx={gIdx} isMaster={isMaster} risorse={risorse}
                            onEdit={startEdit} onDelete={handleDeleteGiorno} 
                            onAddQuest={(gid) => startEdit('quest', { giorno: gid })}
                            questHandlers={questHandlers} />
                    ))}
                </div>
            </div>

            {scanningForVista && (
                <div className="fixed inset-0 z-110 bg-black flex flex-col">
                    <div className="p-4 flex justify-between items-center bg-gray-900 border-b border-gray-800 shadow-xl">
                        <span className="font-black text-white uppercase italic tracking-widest">Associa QR Fisico</span>
                        <button onClick={() => setScanningForVista(null)} className="px-4 py-2 bg-red-600 rounded-lg text-xs font-black shadow-lg">X ANNULLA</button>
                    </div>
                    <div className="flex-1">
                        <QrTab onScanSuccess={async (qr_id) => {
                            await associaQrAVista(scanningForVista, qr_id, onLogout);
                            setScanningForVista(null); refreshData();
                        }} onLogout={onLogout} />
                    </div>
                </div>
            )}
        </div>
    );
};

export default PlotTab;

==================================================
FILE: src\components\ProposalEditorModal.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { Loader2, Save, Send, Trash2, AlertTriangle, Plus, Minus, Info, Box, Activity, Settings, Zap, Users, Scroll } from 'lucide-react';
import { useCharacter } from './CharacterContext';
import { 
    createProposta, 
    updateProposta, 
    sendProposta, 
    deleteProposta, 
    getAllPunteggi, 
    getMattoniAura, 
    getClassiOggetto 
} from '../api';
import IconaPunteggio from './IconaPunteggio';

// Costanti Slot Corporei (Invariate)
const BODY_SLOTS = [
    { id: 'HD1', label: 'Testa (Cervello/Sensi)' },
    { id: 'HD2', label: 'Testa (Volto/Esterno)' },
    { id: 'TR1', label: 'Tronco (Organi Vitali)' },
    { id: 'TR2', label: 'Tronco (Struttura/Pelle)' },
    { id: 'RA', label: 'Braccio Destro' },
    { id: 'LA', label: 'Braccio Sinistro' },
    { id: 'RL', label: 'Gamba Destra' },
    { id: 'LL', label: 'Gamba Sinistra' },
];

// Mappa Tipi Oggetto per UI
const ITEM_TYPES = {
    'MOD': { label: 'Mod (Tecnologico)', icon: Settings, isBound: false },
    'MAT': { label: 'Materia (Soprannaturale)', icon: Zap, isBound: false },
    'INNESTO': { label: 'Innesto (Chirurgico)', icon: Activity, isBound: true },
    'MUTAZIONE': { label: 'Mutazione (Biologico)', icon: Activity, isBound: true }
};

const ProposalEditorModal = ({ proposal, type, onClose, onRefresh }) => {
    const { selectedCharacterData: char, selectedCharacterId } = useCharacter();
    
    // --- STATI DATI PROPOSTA ---
    const [name, setName] = useState(proposal?.nome || '');
    const [description, setDescription] = useState(proposal?.descrizione || '');
    
    // Campi specifici Cerimoniale
    const [prerequisiti, setPrerequisiti] = useState(proposal?.prerequisiti || '');
    const [svolgimento, setSvolgimento] = useState(proposal?.svolgimento || '');
    const [effetto, setEffetto] = useState(proposal?.effetto || '');
    const [livelloCerimoniale, setLivelloCerimoniale] = useState(proposal?.livello || 1);

    const [selectedAuraId, setSelectedAuraId] = useState(proposal?.aura || '');
    const [selectedInfusionAuraId, setSelectedInfusionAuraId] = useState(proposal?.aura_infusione || '');
    
    // --- STATI LOGICA TIPO OGGETTO (Infusioni) ---
    const [selectedItemType, setSelectedItemType] = useState('');
    const [availableItemOptions, setAvailableItemOptions] = useState([]); 
    
    // --- STATI FILTRI E CONFIGURAZIONE ---
    const [selectedClasseId, setSelectedClasseId] = useState(''); 
    const [selectedSlots, setSelectedSlots] = useState([]);
    
    // Init componenti (Mattoni)
    const initialComponents = {};
    if (proposal?.componenti) {
        proposal.componenti.forEach(c => {
            const id = c.caratteristica?.id || c.caratteristica_id || c.caratteristica; 
            if(id) initialComponents[id] = c.valore;
        });
    }
    const [componentsMap, setComponentsMap] = useState(initialComponents);

    // Cache Dati
    const [allPunteggiCache, setAllPunteggiCache] = useState([]);
    const [availableAuras, setAvailableAuras] = useState([]);        
    const [availableInfusionAuras, setAvailableInfusionAuras] = useState([]); 
    const [availableCharacteristics, setAvailableCharacteristics] = useState([]);
    const [availableBricks, setAvailableBricks] = useState([]); 
    const [availableClassi, setAvailableClassi] = useState([]);   
    
    const [isLoadingData, setIsLoadingData] = useState(true);
    const [isSaving, setIsSaving] = useState(false);
    const [error, setError] = useState('');

    const isDraft = !proposal || proposal.stato === 'BOZZA';
    const isEditing = !!proposal;
    const isInfusion = type === 'Infusione';
    const isCerimoniale = type === 'Cerimoniale';

    // Determina l'Aura da cui pescare i nomi dei mattoni
    const auraIdForBricks = useMemo(() => {
        if (isInfusion) return selectedInfusionAuraId || selectedAuraId;
        return selectedAuraId;
    }, [isInfusion, selectedAuraId, selectedInfusionAuraId]);

    // Init Slot se edit
    useEffect(() => {
        if (proposal?.slot_corpo_permessi) {
            setSelectedSlots(proposal.slot_corpo_permessi.split(','));
        }
    }, [proposal]);

    // 1. CARICAMENTO DATI INIZIALI
    useEffect(() => {
        const initData = async () => {
            setIsLoadingData(true);
            try {
                const allData = await getAllPunteggi();
                setAllPunteggiCache(allData);

                if (char && char.punteggi_base) {
                    const validAuras = allData.filter(p => {
                        if (p.tipo !== 'AU') return false;
                        const val = char.punteggi_base[p.nome];
                        if (!val || val < 1) return false;
                        if (isInfusion && !p.permette_infusioni) return false;
                        if (isCerimoniale && p.permette_cerimoniali === false) return false;
                        if (!isInfusion && !isCerimoniale && !p.permette_tessiture) return false;
                        return true;
                    });
                    setAvailableAuras(validAuras);

                    // Filtriamo rigorosamente per tipo 'CA' (Caratteristiche)
                    const validChars = allData.filter(p => p.tipo === 'CA');
                    setAvailableCharacteristics(validChars);
                }

                if (isInfusion) {
                    const classiData = await getClassiOggetto();
                    setAvailableClassi(classiData || []);
                }
            } catch (e) {
                console.error(e);
                setError("Errore caricamento dati dal server.");
            } finally {
                setIsLoadingData(false);
            }
        };
        initData();
    }, [char, type, isInfusion, isCerimoniale]);

    // 2. CARICAMENTO MATTONI SPECIFICI DELL'AURA SELEZIONATA
    useEffect(() => {
        if (!auraIdForBricks) {
            setAvailableBricks([]);
            return;
        }
        getMattoniAura(auraIdForBricks)
            .then(data => setAvailableBricks(data || []))
            .catch(err => console.error("Errore recupero mattoni:", err));
    }, [auraIdForBricks]);

    // 3. LOGICA INFUSIONI (Tipi e Aure Secondarie)
    useEffect(() => {
        if (!selectedAuraId || !isInfusion) return;
        const auraObj = allPunteggiCache.find(p => p.id === parseInt(selectedAuraId));
        if (auraObj) {
            const options = [];
            if (auraObj.produce_mod) options.push('MOD');
            if (auraObj.produce_materia) options.push('MAT');
            if (auraObj.produce_innesti) options.push('INNESTO');
            if (auraObj.produce_mutazioni) options.push('MUTAZIONE');
            setAvailableItemOptions(options);
            if (options.length > 0 && !options.includes(selectedItemType)) setSelectedItemType(options[0]);

            const allowedIds = auraObj.aure_infusione_consentite || [auraObj.id];
            setAvailableInfusionAuras(allPunteggiCache.filter(p => allowedIds.includes(p.id)));
        }
    }, [selectedAuraId, allPunteggiCache, isInfusion, selectedItemType]);

    // --- CALCOLI LIMITI ---
    const currentTotalCount = Object.values(componentsMap).reduce((a, b) => a + b, 0);

    const auraLimit = useMemo(() => {
        if (!selectedAuraId || !char) return 0;
        const auraObj = availableAuras.find(a => a.id == selectedAuraId);
        return auraObj ? (char.punteggi_base[auraObj.nome] || 0) : 0;
    }, [selectedAuraId, char, availableAuras]);

    const maxLivelloCerimoniale = useMemo(() => {
        if (!isCerimoniale || !char) return 0;
        const ccoStat = char.statistiche_primarie?.find(s => s.sigla === 'CCO');
        const ccoVal = ccoStat ? ccoStat.valore_corrente : 0;
        return Math.min(auraLimit, ccoVal);
    }, [isCerimoniale, auraLimit, char]);

    const estimatedCost = currentTotalCount * (isCerimoniale ? 100 : 10);

    // --- HANDLERS ---
    const handleIncrement = (charId, charName) => {
        if (!isDraft) return;
        const currentVal = componentsMap[charId] || 0;

        if (!isCerimoniale) {
            // Vincolo 1: Non superare il punteggio del PG nella Caratteristica
            const pgCharScore = char.punteggi_base[charName] || 0;
            if (currentVal + 1 > pgCharScore) return;

            // Vincolo 2: Non superare il totale permesso dall'Aura
            if (currentTotalCount + 1 > auraLimit) return;
        }

        setComponentsMap(prev => ({ ...prev, [charId]: currentVal + 1 }));
    };

    const handleDecrement = (charId) => {
        if (!isDraft) return;
        const currentVal = componentsMap[charId] || 0;
        if (currentVal <= 1) {
            const newMap = { ...componentsMap };
            delete newMap[charId];
            setComponentsMap(newMap);
        } else {
            setComponentsMap({ ...componentsMap, [charId]: currentVal - 1 });
        }
    };

    const handleTypeChange = (newType) => {
        setSelectedItemType(newType);
        const typeInfo = ITEM_TYPES[newType];
        if (typeInfo?.isBound) setSelectedClasseId('');
        else setSelectedSlots([]);
    };

    const toggleSlot = (slotCode) => {
        if (!isDraft) return;
        setSelectedSlots(prev => prev.includes(slotCode) ? prev.filter(s => s !== slotCode) : [...prev, slotCode]);
    };

    const isCharCompatible = (charId) => {
        if (!isInfusion || isCerimoniale || !selectedClasseId) return true;
        const classeObj = availableClassi.find(c => c.id == selectedClasseId);
        if (!classeObj) return true;
        return selectedItemType === 'MOD' 
            ? (classeObj.mod_allowed_ids || []).includes(parseInt(charId)) 
            : (classeObj.materia_allowed_ids || []).includes(parseInt(charId));
    };

    const getPayload = () => {
        const componentsArray = Object.entries(componentsMap).map(([id, val]) => ({
            caratteristica_id: parseInt(id), 
            valore: val
        }));
        
        let dbType = isInfusion ? 'INF' : isCerimoniale ? 'CER' : 'TES';
        const tipoRisultato = isInfusion ? (['INNESTO', 'MUTAZIONE'].includes(selectedItemType) ? 'AUM' : 'POT') : null;

        return {
            personaggio_id: selectedCharacterId,
            tipo: dbType,
            nome: name,
            descrizione: isCerimoniale ? "Rito Narrativo" : description,
            aura: selectedAuraId,
            aura_infusione: isInfusion ? selectedInfusionAuraId : null,
            tipo_risultato_atteso: tipoRisultato,
            componenti_data: componentsArray, 
            slot_corpo_permessi: isInfusion && ITEM_TYPES[selectedItemType]?.isBound ? selectedSlots.join(',') : '',
            prerequisiti: isCerimoniale ? prerequisiti : null,
            svolgimento: isCerimoniale ? svolgimento : null,
            effetto: isCerimoniale ? effetto : null,
            livello_proposto: isCerimoniale ? livelloCerimoniale : 1,
        };
    };

    const handleSaveAction = async (send = false) => {
        setError(''); 
        if (!name) return setError("Nome della tecnica obbligatorio.");
        if (!selectedAuraId) return setError("Seleziona un'Aura di riferimento.");
        
        if (isCerimoniale) {
            if (!prerequisiti || !svolgimento || !effetto) {
                return setError("Per i cerimoniali, tutti i campi descrittivi sono obbligatori.");
            }
            if (livelloCerimoniale < 1) return setError("Il rito deve avere almeno livello 1.");
        }

        setIsSaving(true);
        try {
            if (send && !window.confirm("Attenzione: l'invio alla valutazione dello staff è definitivo. Confermi?")) {
                setIsSaving(false); return;
            }
            let targetId = proposal?.id;
            const payload = getPayload();
            
            if (!targetId) {
                const newP = await createProposta(payload);
                targetId = newP.id;
            } else {
                await updateProposta(targetId, payload);
            }

            if (send) await sendProposta(targetId);
            onRefresh(); onClose();
        } catch (e) { 
            setError(e.message || "Errore durante il salvataggio."); 
        } finally { 
            setIsSaving(false); 
        }
    };

    const handleDelete = async () => {
        if (!window.confirm("Vuoi davvero eliminare questa bozza? L'azione è irreversibile.")) return;
        try {
            await deleteProposta(proposal.id);
            onRefresh(); onClose();
        } catch (e) { setError(e.message); }
    };

    if (!char) return null;

    // DETERMINA COSA MOSTRARE NELLA GRIGLIA
    const displayItems = availableBricks.length > 0 
        ? availableBricks 
        : availableCharacteristics.filter(c => isCerimoniale || (char.punteggi_base[c.nome] > 0));

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-gray-900 border border-gray-700 rounded-xl w-full max-w-5xl max-h-[90vh] flex flex-col shadow-2xl animate-fadeIn overflow-hidden">
                
                {/* Header */}
                <div className="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-800 rounded-t-xl shrink-0">
                    <div className="flex items-center gap-3">
                        <div className="p-2 bg-gray-900 rounded-lg border border-gray-700">
                            {isInfusion ? <Box className="text-amber-500" size={20}/> : 
                             isCerimoniale ? <Users className="text-purple-400" size={20}/> :
                             <Scroll className="text-indigo-400" size={20}/>}
                        </div>
                        <div>
                            <h2 className="text-lg font-bold text-white">
                                {isEditing ? `Modifica ${type}` : `Crea Nuova Proposta ${type}`}
                            </h2>
                            <p className="text-[10px] text-gray-500 uppercase font-black">
                                {isEditing ? `ID: ${proposal.id} • ${proposal.stato}` : 'Creazione Bozza Personale'}
                            </p>
                        </div>
                    </div>
                    <button onClick={onClose} className="text-gray-400 hover:text-white p-2 hover:bg-gray-700 rounded-full transition-colors">✕</button>
                </div>

                {/* Body */}
                <div className="flex-1 overflow-y-auto p-6 space-y-8 scrollbar-thin scrollbar-thumb-gray-700">
                    {error && <div className="p-3 bg-red-900/30 text-red-200 rounded-lg border border-red-800 flex items-center gap-2 animate-pulse"><AlertTriangle size={16}/> {error}</div>}

                    {/* Identità e Aura */}
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div className="md:col-span-2">
                            <label className="text-[10px] font-black text-gray-500 uppercase tracking-widest block mb-1">Nome della Tecnica</label>
                            <input 
                                type="text" 
                                value={name} 
                                onChange={e => setName(e.target.value)} 
                                disabled={!isDraft} 
                                className="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white focus:border-indigo-500 outline-none transition-all shadow-inner" 
                                placeholder="Esempio: Dardo del Crepuscolo, Scudo di Naniti..." 
                            />
                        </div>
                        <div>
                            <label className="text-[10px] font-black text-gray-500 uppercase tracking-widest block mb-1">Aura Principale</label>
                            <select 
                                value={selectedAuraId} 
                                onChange={e => {setComponentsMap({}); setSelectedAuraId(e.target.value); setLivelloCerimoniale(1);}} 
                                disabled={!isDraft} 
                                className="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white focus:border-indigo-500 outline-none transition-all cursor-pointer"
                            >
                                <option value="">-- Seleziona Aura --</option>
                                {availableAuras.map(a => (
                                    <option key={a.id} value={a.id}>
                                        {a.nome} (Grado {char.punteggi_base[a.nome] || 0})
                                    </option>
                                ))}
                            </select>
                        </div>
                    </div>

                    {/* LOGICA CERIMONIALE */}
                    {isCerimoniale && selectedAuraId && (
                        <div className="space-y-6 animate-in slide-in-from-top-4 duration-500 bg-purple-900/5 p-6 rounded-2xl border border-purple-500/10">
                            <div className="bg-purple-900/10 p-4 rounded-xl border border-purple-500/20">
                                <label className="text-[10px] font-black text-purple-400 uppercase flex justify-between items-center mb-2">
                                    Livello del Rituale
                                    <span className="text-gray-500 italic lowercase tracking-tight font-normal">Limite Min(Aura, CCO): {maxLivelloCerimoniale}</span>
                                </label>
                                <select 
                                    value={livelloCerimoniale} 
                                    onChange={e => setLivelloCerimoniale(parseInt(e.target.value))}
                                    className="w-full bg-gray-800 border border-purple-500/40 rounded-lg p-3 text-white font-bold outline-none shadow-lg shadow-purple-900/10"
                                >
                                    {[...Array(maxLivelloCerimoniale + 1).keys()].slice(1).map(n => (
                                        <option key={n} value={n}>Livello {n}</option>
                                    ))}
                                    {maxLivelloCerimoniale === 0 && <option value="0">Coralità Insufficiente</option>}
                                </select>
                            </div>

                            <div className="grid grid-cols-1 gap-5">
                                <div>
                                    <label className="text-[10px] font-black text-purple-400 uppercase block mb-1.5 ml-1">Prerequisiti Narrativi</label>
                                    <textarea 
                                        value={prerequisiti} 
                                        onChange={e => setPrerequisiti(e.target.value)} 
                                        className="w-full bg-gray-800 border border-gray-600 rounded-xl p-3 text-white text-sm h-24 focus:border-purple-500 outline-none transition-all placeholder:text-gray-600" 
                                        placeholder="Cosa occorre? (es: partecipanti, fase lunare, incenso raro...)" 
                                        disabled={!isDraft} 
                                    />
                                </div>
                                <div>
                                    <label className="text-[10px] font-black text-gray-400 uppercase block mb-1.5 ml-1">Svolgimento del Rito</label>
                                    <textarea 
                                        value={svolgimento} 
                                        onChange={e => setSvolgimento(e.target.value)} 
                                        className="w-full bg-gray-800 border border-gray-600 rounded-xl p-3 text-white text-sm h-40 focus:border-purple-500 outline-none transition-all placeholder:text-gray-600" 
                                        placeholder="Descrivi dettagliatamente le fasi del cerimoniale..." 
                                        disabled={!isDraft} 
                                    />
                                </div>
                                <div>
                                    <label className="text-[10px] font-black text-purple-400 uppercase block mb-1.5 ml-1">Effetto Finale</label>
                                    <textarea 
                                        value={effetto} 
                                        onChange={e => setEffetto(e.target.value)} 
                                        className="w-full bg-gray-800 border border-gray-600 rounded-xl p-3 text-white text-sm h-24 focus:border-purple-500 outline-none transition-all placeholder:text-gray-600" 
                                        placeholder="Qual è il risultato meccanico o narrativo?" 
                                        disabled={!isDraft} 
                                    />
                                </div>
                            </div>
                        </div>
                    )}

                    {/* LOGICA INFUSIONI/TESSITURE */}
                    {!isCerimoniale && (
                        <div className="space-y-6">
                            <div>
                                <label className="text-[10px] font-black text-gray-500 uppercase tracking-widest block mb-1.5">Descrizione e Meccaniche</label>
                                <textarea 
                                    value={description} 
                                    onChange={e => setDescription(e.target.value)} 
                                    disabled={!isDraft} 
                                    className="w-full bg-gray-800 border border-gray-600 rounded-xl p-4 text-white focus:border-indigo-500 outline-none transition-all min-h-[120px] shadow-inner" 
                                    rows={4}
                                    placeholder="Dettaglia gli effetti meccanici, i bonus numerici e le condizioni di attivazione..."
                                />
                            </div>

                            {isInfusion && selectedAuraId && (
                                <div className="p-6 bg-gray-800/40 rounded-2xl border border-gray-700/50 space-y-6 shadow-xl">
                                    <h3 className="text-sm font-bold text-amber-500 flex items-center gap-2 mb-2"><Settings size={18}/> Configurazione Tecnica Oggetto</h3>
                                    <div className="flex flex-wrap gap-2">
                                        {availableItemOptions.map(optKey => (
                                            <button 
                                                key={optKey} 
                                                onClick={() => handleTypeChange(optKey)} 
                                                className={`px-4 py-2.5 rounded-xl text-xs font-bold flex items-center gap-2 transition-all transform active:scale-95 ${selectedItemType === optKey ? 'bg-amber-500 text-black shadow-lg shadow-amber-900/20' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                            >
                                                {ITEM_TYPES[optKey].label}
                                            </button>
                                        ))}
                                    </div>
                                    {selectedItemType && (
                                        <div className="animate-in fade-in duration-300">
                                            {ITEM_TYPES[selectedItemType].isBound ? (
                                                <div className="bg-gray-900/50 p-4 rounded-xl border border-pink-500/20">
                                                    <label className="text-[10px] font-black text-pink-400 uppercase block mb-3 ml-1 tracking-widest">Slot Corporei Necessari</label>
                                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                                                        {BODY_SLOTS.map(slot => (
                                                            <button key={slot.id} onClick={() => toggleSlot(slot.id)} className={`p-2.5 text-[10px] uppercase font-black rounded-lg border transition-all ${selectedSlots.includes(slot.id) ? 'bg-pink-900/40 border-pink-500 text-pink-200' : 'bg-gray-900 border-gray-700 text-gray-500 hover:border-gray-500'}`}>{slot.label}</button>
                                                        ))}
                                                    </div>
                                                </div>
                                            ) : (
                                                <div className="space-y-4">
                                                    <div className="bg-gray-900/50 p-4 rounded-xl border border-indigo-500/20">
                                                        <label className="text-[10px] font-black text-amber-500 uppercase block mb-2 tracking-widest">Aura Sorgente Mattoni (Infusione)</label>
                                                        <select value={selectedInfusionAuraId} onChange={e => {setComponentsMap({}); setSelectedInfusionAuraId(e.target.value);}} className="w-full bg-gray-800 border border-gray-600 rounded-lg p-2.5 text-white text-sm">
                                                            {availableInfusionAuras.map(a => <option key={a.id} value={a.id}>{a.nome}</option>)}
                                                        </select>
                                                    </div>
                                                    <div className="bg-gray-900/50 p-4 rounded-xl border border-indigo-500/20">
                                                        <label className="text-[10px] font-black text-indigo-300 uppercase flex items-center gap-2 mb-2 ml-1 tracking-widest"><Box size={14}/> Compatibilità Classe Oggetto</label>
                                                        <select className="w-full bg-gray-900 border border-indigo-500/30 rounded-xl p-2.5 text-white text-sm" value={selectedClasseId} onChange={e => setSelectedClasseId(e.target.value)}>
                                                            <option value="">-- Mostra Tutte le Caratteristiche --</option>
                                                            {availableClassi.map(c => <option key={c.id} value={c.id}>{c.nome}</option>)}
                                                        </select>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                    )}

                    {/* SEZIONE MATTONI / CARATTERISTICHE (COMUNE) */}
                    {selectedAuraId && (
                        <div className="space-y-4 pt-4 border-t border-gray-800">
                            <div className="flex justify-between items-end px-1">
                                <div>
                                    <label className="text-[10px] font-black text-gray-500 uppercase tracking-widest block">
                                        {availableBricks.length > 0 ? `Mattoni dell'Aura Selezionata` : 'Caratteristiche Base'}
                                    </label>
                                    <p className="text-[10px] text-gray-600 mt-0.5">Componi la struttura del potere selezionando i componenti.</p>
                                </div>
                                <div className="text-right">
                                    {!isCerimoniale && (
                                        <span className={`text-[10px] font-bold block uppercase mb-1 ${currentTotalCount >= auraLimit ? 'text-red-500' : 'text-gray-400'}`}>
                                            Totale: {currentTotalCount} / {auraLimit}
                                        </span>
                                    )}
                                    <span className="text-sm font-black text-yellow-500 font-mono tracking-tighter italic">Costo Invio: {estimatedCost} CR</span>
                                </div>
                            </div>

                            <div className="bg-gray-800/20 p-4 rounded-2xl border border-gray-700/50 max-h-[500px] overflow-y-auto shadow-inner grid grid-cols-1 md:grid-cols-3 gap-3">
                                {displayItems.map(item => {
                                    // Gestione polimorfica: Mattone vs Caratteristica
                                    const characteristic = item.caratteristica_associata || item;
                                    const charId = characteristic.id;
                                    const charSigla = characteristic.sigla; // Sigla Caratteristica (es: MIR, FOR)
                                    const charName = characteristic.nome;
                                    const brickName = item.nome; // Nome Mattone (es: "Dardo")

                                    const count = componentsMap[charId] || 0;
                                    const isCompatible = isCharCompatible(charId);
                                    const pgMaxScore = char.punteggi_base[charName] || 0;

                                    return (
                                        <div key={item.id} className={`flex items-center justify-between bg-gray-900 p-3 rounded-xl border transition-all duration-300 ${count > 0 ? 'border-indigo-500/60 bg-indigo-500/5 shadow-lg shadow-indigo-900/10' : 'border-gray-700'} ${!isCompatible ? 'opacity-20 pointer-events-none grayscale' : ''}`}>
                                            <div className="flex items-center gap-3 overflow-hidden">
                                                <IconaPunteggio punteggio={characteristic} size="32px" />
                                                <div className="flex flex-col overflow-hidden">
                                                    {/* NOME MATTONE IN EVIDENZA */}
                                                    <span className="text-[11px] font-bold truncate text-gray-200" title={brickName}>{brickName}</span>
                                                    {/* SIGLA CARATTERISTICA ASSOCIATA SOTTO */}
                                                    <div className="flex items-center gap-1">
                                                        <span className="text-[8px] uppercase text-gray-500 font-black tracking-tighter">{charSigla}</span>
                                                        {!isCerimoniale && <span className="text-[8px] text-gray-600 font-bold">• Max {pgMaxScore}</span>}
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            {isDraft && (
                                                <div className="flex items-center gap-1.5 bg-gray-800 p-1 rounded-lg border border-gray-700 shadow-inner">
                                                    {count > 0 && (
                                                        <button 
                                                            onClick={() => handleDecrement(charId)} 
                                                            className="w-7 h-7 flex items-center justify-center bg-gray-700 hover:bg-red-900/40 rounded-md text-red-400 transition-colors"
                                                        >
                                                            <Minus size={14}/>
                                                        </button>
                                                    )}
                                                    {count > 0 && <span className="text-xs font-mono w-5 text-center text-white font-bold">{count}</span>}
                                                    <button 
                                                        onClick={() => handleIncrement(charId, charName)} 
                                                        disabled={!isCerimoniale && (count >= pgMaxScore || currentTotalCount >= auraLimit)}
                                                        className="w-7 h-7 flex items-center justify-center bg-gray-700 hover:bg-green-900/40 disabled:bg-gray-800 disabled:text-gray-600 rounded-md text-green-400 transition-colors"
                                                    >
                                                        <Plus size={14}/>
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>

                {/* Footer Chiamate API */}
                <div className="p-4 border-t border-gray-700 bg-gray-800 rounded-b-xl flex justify-between items-center shrink-0">
                    <div className="flex items-center gap-4">
                        {isDraft && isEditing ? (
                            <button onClick={handleDelete} className="text-red-400 text-xs font-bold flex items-center gap-1.5 hover:text-red-300 px-3 py-2 rounded-lg hover:bg-red-900/10"><Trash2 size={15}/> Elimina Bozza</button>
                        ) : <div/>}
                    </div>

                    <div className="flex gap-3">
                        {isDraft && (
                            <>
                                <button onClick={() => handleSaveAction(false)} disabled={isSaving} className="px-5 py-2.5 bg-gray-700 hover:bg-gray-600 text-white rounded-xl text-xs font-black uppercase flex gap-2 items-center transition-all disabled:opacity-50">{isSaving ? <Loader2 className="animate-spin" size={14}/> : <Save size={15}/>} Salva Bozza</button>
                                <button onClick={() => handleSaveAction(true)} disabled={isSaving || (currentTotalCount === 0 && !isCerimoniale)} className="px-6 py-2.5 bg-green-600 hover:bg-green-500 text-white rounded-xl text-xs font-black uppercase flex gap-2 items-center shadow-lg shadow-green-900/30 transform hover:scale-105">{isSaving ? <Loader2 className="animate-spin" size={14}/> : <Send size={15}/>} Invia allo Staff</button>
                            </>
                        )}
                        {!isDraft && (
                            <button onClick={onClose} className="px-8 py-2.5 bg-gray-700 hover:bg-gray-600 text-white rounded-xl text-xs font-black uppercase">Chiudi</button>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default ProposalEditorModal;

==================================================
FILE: src\components\ProposalManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { useCharacter } from './CharacterContext';
import { getProposte } from '../api';
import { FileEdit, Loader2, Plus } from 'lucide-react';
import ProposalEditorModal from './ProposalEditorModal';

const ProposalManager = ({ type, onClose }) => { // type = 'Infusione' | 'Tessitura'
    const { selectedCharacterId } = useCharacter();
    const [proposals, setProposals] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [editorOpen, setEditorOpen] = useState(false);
    const [selectedProposal, setSelectedProposal] = useState(null);

    const filterType = type === 'Infusione' ? 'INF' : type === 'Cerimoniale' ? 'CER' : 'TES';

    const fetchProposals = async () => {
        setIsLoading(true);
        try {
            const all = await getProposte(selectedCharacterId);
            setProposals(all.filter(p => p.tipo === filterType));
        } catch (e) {
            console.error(e);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        if (selectedCharacterId) fetchProposals();
    }, [selectedCharacterId]);

    const handleCreateNew = () => {
        setSelectedProposal(null);
        setEditorOpen(true);
    };

    const handleEdit = (prop) => {
        setSelectedProposal(prop);
        setEditorOpen(true);
    };

    return (
        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-40 p-4">
            <div className="bg-gray-900 w-full max-w-5xl h-[80vh] rounded-xl flex flex-col border border-gray-700 shadow-2xl relative">
                <div className="absolute top-4 right-4">
                     <button onClick={onClose} className="text-gray-400 hover:text-white bg-gray-800 p-2 rounded-full">✕</button>
                </div>
                
                <div className="p-6 border-b border-gray-700 flex justify-between items-center">
                    <div>
                        <h2 className="text-2xl font-bold text-white">Le tue proposte di {type}</h2>
                        <p className="text-gray-400 text-sm mt-1">Gestisci le tue creazioni. Inviare costa 10 CR per livello.</p>
                    </div>
                    <button 
                        onClick={handleCreateNew}
                        className="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-lg flex items-center gap-2 shadow-lg transition-all"
                    >
                        <Plus size={18} /> Nuova Proposta
                    </button>
                </div>

                <div className="flex-1 overflow-y-auto p-6">
                    {isLoading ? (
                        <div className="flex justify-center p-10"><Loader2 className="animate-spin text-indigo-500"/></div>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {proposals.map(p => (
                                <div 
                                    key={p.id} 
                                    onClick={() => handleEdit(p)}
                                    className="bg-gray-800 p-4 rounded-lg border border-gray-700 hover:border-indigo-500 cursor-pointer transition-all hover:bg-gray-750 group"
                                >
                                    <div className="flex justify-between items-start mb-2">
                                        <div className={`text-xs font-bold px-2 py-1 rounded uppercase ${
                                            p.stato === 'BOZZA' ? 'bg-gray-600 text-gray-300' :
                                            p.stato === 'VALUTAZIONE' ? 'bg-yellow-600/20 text-yellow-500 border border-yellow-600/50' :
                                            p.stato === 'APPROVATA' ? 'bg-green-600/20 text-green-500 border border-green-600/50' :
                                            'bg-red-600/20 text-red-500 border border-red-600/50'
                                        }`}>
                                            {p.stato}
                                        </div>
                                        {p.stato === 'BOZZA' && <FileEdit size={16} className="text-gray-500 group-hover:text-indigo-400"/>}
                                    </div>
                                    <h3 className="font-bold text-lg text-white mb-1 truncate">{p.personaggio_nome}</h3>
                                    <div className="text-sm text-gray-400 mb-3 flex items-center gap-2">
                                        <div className="w-2 h-2 rounded-full" style={{backgroundColor: p.aura_details?.colore || '#ccc'}}></div>
                                        {p.aura_details?.nome || 'Aura sconosciuta'}
                                        <span className="ml-auto text-xs bg-gray-900 px-2 py-0.5 rounded">Lv. {p.livello}</span>
                                    </div>
                                    {p.note_staff && (
                                        <div className="mt-2 p-2 bg-gray-900/50 rounded text-xs text-gray-300 border-l-2 border-indigo-500">
                                            <span className="font-bold text-indigo-400 block">Staff:</span>
                                            {p.note_staff}
                                        </div>
                                    )}
                                </div>
                            ))}
                            {proposals.length === 0 && (
                                <div className="col-span-full text-center py-10 text-gray-500 border-2 border-dashed border-gray-700 rounded-xl">
                                    Nessuna proposta trovata. Creane una nuova!
                                </div>
                            )}
                        </div>
                    )}
                </div>
            </div>

            {editorOpen && (
                <ProposalEditorModal 
                    type={type}
                    proposal={selectedProposal}
                    onClose={() => setEditorOpen(false)}
                    onRefresh={fetchProposals}
                />
            )}
        </div>
    );
};

export default ProposalManager;

==================================================
FILE: src\components\PunteggioDisplay.jsx
==================================================
import React, { useState } from 'react';
import IconaPunteggio, { getContrastColor } from './IconaPunteggio';
import { useCharacter } from './CharacterContext';
import ModelloAuraSelectionModal from './ModelloAuraSelectionModal';
import AuraTraitsModal from './AuraTraitsModal'; 
import { AlertTriangle, Crown } from 'lucide-react';

const PunteggioDisplay = ({ 
  punteggio, 
  value, 
  displayText = "abbr", 
  iconType = "inv_circle", 
  size = "m",
  className = "",
  readOnly = false // <--- NUOVA PROP
}) => {
  // Safe destructuring nel caso useCharacter ritorni null (ospiti) o loading
  const context = useCharacter();
  const selectedCharacterData = context?.selectedCharacterData || null;
  const refreshCharacterData = context?.refreshCharacterData || (() => {});

  const [showModal, setShowModal] = useState(false);
  const [showTraitsModal, setShowTraitsModal] = useState(false);
  
  if (!punteggio || !punteggio.colore) {
    // Fallback elegante se mancano i dati (es. backend non manda l'oggetto completo)
    return (
      <div className={`flex items-center gap-1 p-1 bg-gray-200 rounded border border-gray-300 ${className}`}>
        {punteggio?.sigla && <span className="text-[10px] font-bold text-gray-500">{punteggio.sigla}</span>}
        <span className="text-[10px] font-semibold text-gray-400">N/A</span>
      </div>
    );
  }

  const textColor = getContrastColor(punteggio.colore);
  
  let iconMode = 'cerchio_inv';
  if (iconType === 'circle') iconMode = 'cerchio';
  if (iconType === 'raw') iconMode = 'raw'; 
  if (iconType === 'inv_circle') iconMode = 'cerchio_inv'; 
  if (iconType === 'none') iconMode = null;

  let textToShow = "";
  if (displayText === "abbr") {
    textToShow = punteggio.sigla ? punteggio.sigla.toUpperCase() : punteggio.nome;
  } else if (displayText === "name") {
    textToShow = punteggio.nome;
  }

  // Configurazione dimensioni (ho aggiunto 'badge' per uso in tabelle)
  const layoutConfig = {
    badge: { gap: 'gap-1', text: 'text-[9px]', val: 'hidden', p: 'p-0.5 px-1.5' }, // Compatto per badge
    xs: { gap: 'gap-1',    text: 'text-[9px]',     val: 'text-[10px]', p: 'p-0.5' },
    s:  { gap: 'gap-1.5',  text: 'text-[11px]',    val: 'text-xs',     p: 'p-1' },
    m:  { gap: 'gap-2.5',  text: 'text-sm',        val: 'text-lg',     p: 'p-1.5' },
    l:  { gap: 'gap-3.5',  text: 'text-base',      val: 'text-2xl',    p: 'p-2.5' },
    xl: { gap: 'gap-4',    text: 'text-xl',        val: 'text-4xl',    p: 'p-4' },
  };
  
  const layout = layoutConfig[size] || layoutConfig.m;
  const url = punteggio.icona_url || punteggio.icona;

  // --- LOGICA INTERATTIVA (Disabilitata se readOnly) ---
  const isAura = punteggio.tipo === 'AU';
  const hasModelsAvailable = punteggio.has_models;
  const userValue = parseInt(value) || 0;
  
  const selectedModelName = !readOnly && isAura && selectedCharacterData?.modelli_aura
      ? selectedCharacterData.modelli_aura.find(m => m.aura === punteggio.id)?.nome 
      : null;

  const needsSelection = !readOnly && isAura && userValue > 0 && hasModelsAvailable && !selectedModelName;
  const hasTraitsConfig = !readOnly && punteggio.configurazione_livelli && punteggio.configurazione_livelli.length > 0;

  const handleContainerClick = () => {
    if (readOnly) return;
    if (hasTraitsConfig) setShowTraitsModal(true);
  };

  return (
    <>
        <div 
          className={`flex items-center justify-between rounded-lg shadow-sm transition-all ${layout.p} ${className} 
            ${hasTraitsConfig ? 'cursor-pointer hover:brightness-110 relative group' : ''}
            ${readOnly ? 'cursor-default' : ''}`} 
          style={{ backgroundColor: punteggio.colore }}
          onClick={handleContainerClick}
        >
          <div className={`flex items-center ${layout.gap} min-w-0`}> 
            
            <div className="relative">
                {iconMode && url && (
                  <IconaPunteggio 
                    url={url} 
                    color={punteggio.colore} 
                    mode={iconMode} 
                    size={size === 'badge' ? 'xs' : size} // Badge usa icone piccole
                    className="shrink-0" 
                  />
                )}
                {hasTraitsConfig && (
                    <div className="absolute -top-1 -right-1 bg-amber-500 rounded-full p-0.5 border border-black/50 shadow-sm">
                        <Crown size={8} className="text-white" fill="currentColor" />
                    </div>
                )}
            </div>
            
            <div className="flex flex-col min-w-0 justify-center">
                {textToShow && (
                  <span 
                    className={`font-bold uppercase tracking-wider ${layout.text} truncate whitespace-nowrap leading-tight`} 
                    style={{ color: textColor }}
                  >
                    {textToShow}
                  </span>
                )}

                {needsSelection && (
                    <button
                        onClick={(e) => { e.stopPropagation(); setShowModal(true); }}
                        className="mt-0.5 flex items-center gap-1 text-[10px] bg-red-600 text-white px-1.5 py-0.5 rounded animate-pulse hover:bg-red-500 font-bold uppercase tracking-wider border border-white/20 shadow-sm w-max"
                    >
                        <AlertTriangle size={10} /> Scegli!
                    </button>
                )}

                {selectedModelName && (
                    <span 
                        className="text-[10px] opacity-90 font-mono uppercase tracking-tight block leading-none mt-0.5" 
                        style={{ color: textColor }}
                    >
                        {selectedModelName}
                    </span>
                )}
            </div>
          </div>
          
          {/* Valore numerico (nascosto se size='badge' o value è null) */}
          {value !== null && value !== undefined && layout.val !== 'hidden' && (
            <span 
              className={`font-bold font-mono ${layout.val} shrink-0 ml-2 whitespace-nowrap`} 
              style={{ color: textColor }}
            >
              {value}
            </span>
          )}
        </div>

        {showModal && (
            <ModelloAuraSelectionModal 
                aura={punteggio} 
                onClose={() => setShowModal(false)} 
            />
        )}

        {showTraitsModal && (
            <AuraTraitsModal 
                aura={punteggio}
                personaggio={selectedCharacterData}
                currentValue={userValue} 
                onClose={() => setShowTraitsModal(false)}
                onUpdateCharacter={refreshCharacterData} 
            />
        )}
    </>
  );
};

export default PunteggioDisplay;

==================================================
FILE: src\components\QrResultModal.jsx
==================================================
import React, { useState, useEffect, useRef } from 'react';
import { X, Loader, Scan, Eye, Grab, Sparkles, User, FileText, Bot, Timer } from 'lucide-react';
import { richiediTransazione, rubaOggetto, acquisisciItem } from '../api'; 
import { useCharacter } from './CharacterContext';
import { useTimers } from '../hooks/useTimers';

//##################################################################
// ## COMPONENTE HELPER 1: MODALE "VEDI OGGETTO" ##
//##################################################################
const OggettoDetailModal = ({ oggetto, onClose }) => {
  return (
    // Overlay (z-index 60, sopra la modale QR che è z-50)
    <div className="fixed inset-0 z-60 flex items-center justify-center bg-black bg-opacity-80 p-4">
      <div className="flex flex-col w-full max-w-md bg-gray-900 rounded-lg shadow-2xl overflow-hidden border border-indigo-500">
        
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-700">
          <h2 className="text-xl font-bold text-indigo-400">{oggetto.nome}</h2>
          <button
            onClick={onClose}
            className="p-2 text-gray-400 rounded-full hover:bg-gray-700 hover:text-white"
            aria-label="Chiudi"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Contenuto */}
        <div className="p-6 overflow-y-auto text-white space-y-4 max-h-[60vh]">
          <p className="text-gray-300">{oggetto.descrizione || "Nessuna descrizione."}</p>
          
          {/* Mostra tutti i dati grezzi dell'oggetto */}
          <details className="mt-4 bg-gray-950 rounded-lg">
            <summary className="text-sm font-semibold text-gray-500 p-2 cursor-pointer">Mostra Dati Grezzi Oggetto</summary>
            <pre className="p-3 overflow-x-auto text-xs text-yellow-300">
              {JSON.stringify(oggetto, null, 2)}
            </pre>
          </details>
        </div>

      </div>
    </div>
  );
};


//##################################################################
// ## FUNZIONE HELPER 2: LOGICA AURA ##
//##################################################################
const getOggettiVisibili = (oggettiDaFiltrare, personaggioAttivo) => {
  if (!personaggioAttivo || !oggettiDaFiltrare || oggettiDaFiltrare.length === 0) {
    return [];
  }

  // !!! --- ASSUNZIONE AURA 1 --- !!!
  // Assumo che i punteggi di aura del PG ATTIVO (che scansiona) 
  // si trovino in `personaggioAttivo.modificatori_calcolati`.
  const aurePersonaggio = personaggioAttivo.modificatori_calcolati;
  
  if (!aurePersonaggio) {
    console.warn("Dati 'modificatori_calcolati' non trovati nel personaggio attivo. Impossibile filtrare per aura.");
    return [];
  }

  return oggettiDaFiltrare.filter(obj => {
    // !!! --- ASSUNZIONE AURA 2 --- !!!
    // Assumo che ogni OGGETTO scansionato abbia un campo stringa 'aura_richiesta'
    const auraRichiesta = obj.aura_richiesta; 

    if (!auraRichiesta) {
      // Se l'oggetto non ha un'aura_richiesta, è visibile a tutti.
      return true;
    }

    const punteggioAura = aurePersonaggio[auraRichiesta] || 0;
    return punteggioAura >= 1;
  });
};


//##################################################################
// ## VISTE QR: TIPO MANIFESTO / A_VISTA (3a, 3e) - MODIFICATO ##
//##################################################################
const ManifestoView = ({ data }) => {
  
  // Creiamo un template HTML completo da passare all'iframe.
  // Questo ci permette di controllare STILI e COMPORTAMENTO del testo.
  const htmlContent = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        /* Stile pergamena */
        body {
          background-color: #FFFBEB; /* Colore bg-amber-50 */
          font-family: serif;      /* Font pergamena */
          color: #1f2937;         /* Colore text-gray-800 */
          padding: 1rem;
          font-size: 1.125rem;     /* text-lg */
          margin: 0;               /* Rimuove margini default */
          
          /* --- I FIX PER IL WRAPPING (ora applicati DENTRO l'iframe) --- */
          
          /* 1. Rispetta i <br> e \n E fa il wrap del testo */
          white-space: pre-wrap;
          
          /* 2. Forza l'interruzione di parole molto lunghe */
          overflow-wrap: break-word;
          word-break: break-word;
        }
        
        /* Regola "martello" per forzare il wrapping anche
           dentro tag <p> o <pre> che arrivano dal DB.
        */
        * {
          white-space: pre-wrap !important;
          overflow-wrap: break-word !important;
          word-break: break-word !important;
        }
      </style>
    </head>
    <body>
      ${data.testo || '<i>Nessun testo per questo manifesto.</i>'}
    </body>
    </html>
  `;

  return (
    <div>
      {/* Titolo */}
      <h3 className="text-2xl font-bold mb-4 text-amber-200 text-center">
        {data.nome || 'Manifesto'}
      </h3>
      
      {/* Usiamo un iframe per isolare completamente lo stile 
        dell'HTML del manifesto dal resto dell'app.
      */}
      <iframe
        srcDoc={htmlContent}
        title={data.nome || 'Manifesto'}
        // Applichiamo bordo e ombra all'iframe stesso
        className="w-full rounded-md shadow-inner"
        style={{
          height: '60vh', // Altezza fissa per l'area di scroll
          border: '4px solid rgba(120, 53, 15, 0.3)', // Bordo pergamena (amber-900/30)
          backgroundColor: '#FFFBEB' // Sfondo se l'iframe è lento
        }}
        // Sandbox per sicurezza
        sandbox="allow-same-origin" 
      />
    </div>
  );
};

//##################################################################
// ## VISTA QR: TIPO INVENTARIO (3b) ##
//##################################################################
const InventarioView = ({ data, onLogout }) => {
  const [cooldownEnd, setCooldownEnd] = useState(0); 
  const [cooldownTimer, setCooldownTimer] = useState(0);
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [viewingOggetto, setViewingOggetto] = useState(null);
  
  const { selectedCharacterData } = useCharacter();
  const isInCooldown = Date.now() < cooldownEnd;

  useEffect(() => {
    if (isInCooldown) {
      const updateTimer = () => {
        const secondsLeft = Math.ceil((cooldownEnd - Date.now()) / 1000);
        setCooldownTimer(secondsLeft > 0 ? secondsLeft : 0);
      };
      updateTimer();
      const interval = setInterval(updateTimer, 1000);
      return () => clearInterval(interval);
    } else {
      setCooldownTimer(0);
    }
  }, [cooldownEnd, isInCooldown]);

  const handlePrendi = async (oggettoId, oggettoNome) => {
    if (isInCooldown) return;
    
    setMessage('Elaborazione...');
    setError('');
    setCooldownEnd(Date.now() + 10000); // Avvia cooldown 10s

    try {
      const response = await richiediTransazione(oggettoId, data.id, onLogout);
      setMessage(`Richiesta per '${oggettoNome}' inviata! Attendi conferma.`);
    } catch (err) {
      setError(err.message || 'Errore imprevisto.');
      setMessage('');
      setCooldownEnd(0); // Resetta cooldown in caso di errore
    }
  };

  const oggettiVisibili = getOggettiVisibili(data.oggetti, selectedCharacterData);

  return (
    <div>
      {viewingOggetto && (
        <OggettoDetailModal 
          oggetto={viewingOggetto} 
          onClose={() => setViewingOggetto(null)} 
        />
      )}

      <h3 className="text-2xl font-bold mb-4">{data.nome || 'Inventario'}</h3>
      {error && <p className="text-red-400 mb-4 bg-red-900 bg-opacity-30 p-2 rounded">{error}</p>}
      {message && <p className="text-green-400 mb-4 bg-green-900 bg-opacity-30 p-2 rounded">{message}</p>}
      {isInCooldown && (
         <p className="text-yellow-400 mb-4 flex items-center">
           <Timer size={16} className="mr-2" />
           Cooldown "Prendi" attivo: {cooldownTimer}s
         </p>
      )}
      
      {oggettiVisibili.length === 0 && (
        <p className="text-gray-500 italic">Nessun oggetto visibile in questo inventario.</p>
      )}

      <ul className="space-y-3">
        {oggettiVisibili.map(obj => (
          <li key={obj.id} className="flex justify-between items-center p-3 bg-gray-700 rounded-md">
            <span className="font-semibold">{obj.nome}</span>
            <div className="space-x-2">
              <button 
                onClick={() => setViewingOggetto(obj)}
                className="p-2 bg-blue-600 rounded hover:bg-blue-700" 
                title="Vedi Dettagli"
              >
                <Eye size={18} />
              </button>
              <button 
                onClick={() => handlePrendi(obj.id, obj.nome)}
                disabled={isInCooldown}
                className={`p-2 bg-green-600 rounded hover:bg-green-700 ${isInCooldown ? 'opacity-50 cursor-not-allowed' : ''}`}
                title="Prendi"
              >
                <Grab size={18} />
              </button>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
};

//##################################################################
// ## VISTA QR: TIPO PERSONAGGIO (3c) ##
//##################################################################
const PersonaggioView = ({ data, onLogout, onStealSuccess }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [viewingOggetto, setViewingOggetto] = useState(null);

  const { selectedCharacterData } = useCharacter();
  
  const handleRuba = async (oggettoId, oggettoNome) => {
     if (isLoading) return;
     setIsLoading(true);
     setMessage('Tentativo di furto in corso...');
     setError('');

     try {
       const response = await rubaOggetto(oggettoId, data.id, onLogout);
       setMessage(response.success || `Oggetto '${oggettoNome}' rubato!`);
       onStealSuccess(); 
     } catch (err) {
       setError(err.message || 'Errore imprevisto.');
       setMessage('');
     } finally {
       setIsLoading(false);
     }
  }

  const oggettiVisibili = getOggettiVisibili(data.oggetti, selectedCharacterData);

  return (
    <div>
      {viewingOggetto && (
        <OggettoDetailModal 
          oggetto={viewingOggetto} 
          onClose={() => setViewingOggetto(null)} 
        />
      )}

      <h3 className="text-2xl font-bold mb-4 flex items-center"><User className="mr-2"/> {data.nome || 'Personaggio'}</h3>
      {error && <p className="text-red-400 mb-4 bg-red-900 bg-opacity-30 p-2 rounded">{error}</p>}
      {message && <p className="text-green-400 mb-4 bg-green-900 bg-opacity-30 p-2 rounded">{message}</p>}
      
      {oggettiVisibili.length === 0 && (
        <p className="text-gray-500 italic">Nessun oggetto visibile su questo personaggio.</p>
      )}

      <ul className="space-y-3">
        {oggettiVisibili.map(obj => (
          <li key={obj.id} className="flex justify-between items-center p-3 bg-gray-700 rounded-md">
            <span className="font-semibold">{obj.nome}</span>
            <div className="space-x-2">
              <button 
                onClick={() => setViewingOggetto(obj)}
                className="p-2 bg-blue-600 rounded hover:bg-blue-700" 
                title="Vedi Dettagli"
              >
                <Eye size={18} />
              </button>
              <button 
                onClick={() => handleRuba(obj.id, obj.nome)}
                disabled={isLoading}
                className={`p-2 bg-red-600 rounded hover:bg-red-700 ${isLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
                title="Ruba"
              >
                {isLoading ? <Loader size={18} className="animate-spin" /> : <Bot size={18} />}
              </button>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
};

//##################################################################
// ## VISTA QR: TIPO OGGETTO / ATTIVATA (3d) ##
//##################################################################
const AcquisizioneView = ({ qrId, data, tipo, onLogout, onClose }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');

  const handleAcquisisci = async () => {
    if (!qrId) {
        setError("Errore: ID del QrCode non trovato per l'acquisizione.");
        return;
    }
    setIsLoading(true);
    setError('');
    try {
      const response = await acquisisciItem(qrId, onLogout);
      setMessage(response.success || "Oggetto acquisito!");
      setTimeout(() => {
        onClose();
      }, 2000);
    } catch (err) {
      setError(err.message || 'Errore imprevisto.');
      setIsLoading(false);
    }
  };

  return (
    <div>
      <h3 className="text-2xl font-bold mb-4 flex items-center">
        {tipo === 'oggetto' ? <Shield className="mr-2" /> : <Sparkles className="mr-2" />}
        {data.nome || 'Oggetto Raro'}
      </h3>
      {error && <p className="text-red-400 mb-4 bg-red-900 bg-opacity-30 p-2 rounded">{error}</p>}
      {message && <p className="text-green-400 mb-4 bg-green-900 bg-opacity-30 p-2 rounded">{message}</p>}
      
      <p className="text-gray-300 mb-4">{data.descrizione || 'Nessuna descrizione.'}</p>
      
      <details className="mt-4 bg-gray-900 rounded-lg">
        <summary className="text-sm font-semibold text-gray-500 p-2 cursor-pointer">Mostra Dati Grezzi</summary>
        <pre className="p-3 overflow-x-auto text-xs text-yellow-300">
          {JSON.stringify(data, null, 2)}
        </pre>
      </details>
      
      {!message && ( // Nascondi il pulsante dopo l'acquisizione
        <button 
          onClick={handleAcquisisci}
          disabled={isLoading}
          className="w-full mt-6 px-4 py-3 bg-purple-600 text-white text-lg font-bold rounded-md shadow-lg hover:bg-purple-700 disabled:opacity-50"
        >
          {isLoading ? <Loader className="animate-spin mx-auto" /> : 'Acquisisci'}
        </button>
      )}
    </div>
  );
};


//##################################################################
// ## COMPONENTE MODALE PRINCIPALE (EXPORT) ##
//##################################################################
const QrResultModal = ({ data, onClose, onLogout, onStealSuccess }) => {
  
  const { addTimer } = useTimers(); // <--- Accediamo alla logica dei timer
  const lastProcessedQr = useRef(null); // Per evitare che il timer scatti multipli in caso di re-render

  useEffect(() => {
    if (!data) return;

    // Identifichiamo i dati del timer in base alla struttura del backend
    let timerToActivate = null;

    // CASO A: Il QR è di tipo timer puro (tipo_modello: "timer_attivato")
    if (data.tipo_modello === 'timer_attivato' && data.dati) {
      timerToActivate = {
        nome: data.dati.nome,
        endsAt: data.dati.scadenza, // Backend manda "scadenza" ISO
        alert_suono: true, // Fallback se non definiti
        notifica_push: true,
        messaggio_in_app: true
      };
    } 
    // CASO B: Il QR ha un timer associato come extra (es. Manifesto + Timer)
    else if (data.timer || data.dati?.timer_config) {
      const config = data.timer || data.dati.timer_config;
      timerToActivate = {
        nome: config.nome,
        duration: config.durata_secondi, // Qui il backend usa durata_secondi
        alert_suono: config.alert_suono,
        notifica_push: config.notifica_push,
        messaggio_in_app: config.messaggio_in_app
      };
    }

    const qrId = data.qrcode_id || data.dati?.qr_code_id || (data.tipo_modello === 'timer_attivato' ? data.dati?.nome : null);

    if (timerToActivate && qrId && lastProcessedQr.current !== qrId) {
      try {
        addTimer(timerToActivate);
        lastProcessedQr.current = qrId;
        console.log("⏱️ Timer innescato con successo");
      } catch (e) {
        console.error("Errore nell'innesco del timer:", e);
      }
    }
  }, [data, addTimer]);

  const renderContent = () => {
    if (!data) {
      return (
        <div className="flex justify-center items-center h-full">
          <Loader className="animate-spin text-indigo-400" size={48} />
        </div>
      );
    }
    
    const qrId = data.dati?.qr_code_id || data.qrcode_id; 

    switch (data.tipo_modello) {
      case 'manifesto':
      case 'a_vista':
        return <ManifestoView data={data.dati} />;
      
      case 'inventario':
        return <InventarioView data={data.dati} onLogout={onLogout} />;
        
      case 'personaggio':
        return <PersonaggioView data={data.dati} onLogout={onLogout} onStealSuccess={onStealSuccess} />;

      case 'oggetto':
        if (!qrId) { 
            return <p className="text-red-400">Errore: Manca l'ID del QrCode per l'acquisizione.</p>
        }
        return <AcquisizioneView qrId={qrId} data={data.dati} tipo="oggetto" onLogout={onLogout} onClose={onClose} />;
      
      case 'attivata':
        if (!qrId) { 
            return <p className="text-red-400">Errore: Manca l'ID del QrCode per l'acquisizione.</p>
        }
        return <AcquisizioneView qrId={qrId} data={data.dati} tipo="attivata" onLogout={onLogout} onClose={onClose} />;

      // AGGIUNTO IL CASO MANCANTE PER IL TIMER PURO
      case 'timer_attivato':
        return (
          <div className="text-center py-10">
            <Timer size={80} className="mx-auto text-amber-500 mb-6 animate-pulse" />
            <h3 className="text-3xl font-black text-amber-400 uppercase tracking-tighter mb-4">{data.dati?.nome}</h3>
            <p className="text-gray-300 text-lg italic">{data.messaggio}</p>
            <div className="mt-8 pt-6 border-t border-white/10 text-[10px] text-gray-500 uppercase font-bold tracking-widest">
                Sincronizzazione Cronometro Eseguita
            </div>
          </div>
        );

      case 'qrcode_scollegato':
        return (
          <div className="text-center">
            <Scan size={48} className="mx-auto text-yellow-400 mb-4" />
            <h3 className="text-2xl font-bold mb-2">QR Code non collegato</h3>
            <p className="text-gray-300">{data.messaggio}</p>
            <p className="text-xs text-gray-500 mt-2">ID: {data.qrcode_id}</p>
          </div>
        );

      default:
        return (
          <div className="text-center">
            <h3 className="text-2xl font-bold mb-2 text-red-400">Errore</h3>
            <p className="text-gray-300">Tipo di QR Code non riconosciuto: {data.tipo_modello}</p>
            <pre className="text-xs text-left bg-gray-900 p-2 rounded-md mt-4 overflow-auto">
              {JSON.stringify(data, null, 2)}
            </pre>
          </div>
        );
    }
  };

  return (
    // Overlay (z-index 50)
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 p-4">
      <div className="flex flex-col w-full h-full max-w-lg max-h-[90dvh] bg-gray-800 rounded-lg shadow-2xl overflow-hidden">
        
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-700">
          <h2 className="text-xl font-bold text-white">Risultato Scansione</h2>
          <button
            onClick={onClose}
            className="p-2 text-gray-400 rounded-full hover:bg-gray-700 hover:text-white"
            aria-label="Chiudi"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Contenuto Dinamico */}
        <div className="grow p-6 overflow-y-auto text-white">
          {renderContent()}
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-gray-700 text-center shrink-0">
           <button
            onClick={onClose}
            className="px-6 py-2 font-bold text-white bg-indigo-600 rounded-md shadow-lg hover:bg-indigo-700"
          >
            Chiudi
          </button>
        </div>
      </div>
    </div>
  );
};

export default QrResultModal;

==================================================
FILE: src\components\QrTab.jsx
==================================================
import React, { useState, useRef, useEffect } from 'react';
import { Html5Qrcode } from 'html5-qrcode';
import { getQrCodeData } from '../api'; // IMPORTA LA NUOVA FUNZIONE API
import { useCharacter } from './CharacterContext'; // Importa per sapere chi sta scansionando
import { Timer } from 'lucide-react'; // Icona Timer

const QrTab = ({ onScanSuccess, onLogout, isStealingOnCooldown, cooldownTimer, onStealSuccess }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [isScanning, setIsScanning] = useState(false);
  
  const html5QrCodeRef = useRef(null);
  const qrReaderId = "qr-reader-element";
  
  // Prendi il personaggio attivo dal context
  const { selectedCharacterId } = useCharacter();

  const handleScanData = async (decodedText) => {
    // Controlla se un personaggio è selezionato
    if (!selectedCharacterId) {
      setError("Per favore, seleziona un personaggio prima di scansionare.");
      stopWebcamScan(); // Ferma lo scanner
      return;
    }

    // Controllo cooldown globale
    if (isStealingOnCooldown) {
        setError(`Devi attendere la fine del cooldown (furto) prima di scansionare.`);
        stopWebcamScan();
        return;
    }

    setIsScanning(false);
    setIsLoading(true);
    setError('');

    try {
      await stopWebcamScan();

      // USA LA NUOVA FUNZIONE API
      const jsonData = await getQrCodeData(decodedText, onLogout);
      
      onScanSuccess(jsonData); // Passa il JSON alla modale
      
    } catch (err) {
      setError(err.message || 'Impossibile caricare i dati QR.');
    } finally {
      setIsLoading(false);
    }
  };

  /*
    CORREZIONE 2: Problema "Quadrato Grigio"
    Dobbiamo assicurarci che il div #qr-reader-element sia VISIBILE
    nel DOM *prima* di provare ad avviare Html5Qrcode.
    Usiamo un setTimeout per ritardare l'avvio dello scanner
    di un attimo, dando a React il tempo di aggiornare il DOM.
  */
  const startWebcamScan = () => {
    setError('');
    setIsScanning(true); // 1. Dice a React di mostrare il div

    // 2. Aspetta un attimo che il DOM si aggiorni
    setTimeout(() => {
      // Controlla se l'istanza esiste già e se è in scansione
      if (html5QrCodeRef.current && html5QrCodeRef.current.isScanning) {
        console.log("Scanner già attivo.");
        return;
      }

      try {
        // 3. Ora il div #qr-reader-element è visibile
        if (!html5QrCodeRef.current) {
          html5QrCodeRef.current = new Html5Qrcode(qrReaderId);
        }
        
        const config = { fps: 10, qrbox: { width: 250, height: 250 } };
        
        html5QrCodeRef.current.start(
          { facingMode: "environment" }, // Prova prima la fotocamera posteriore
          config,
          (decodedText, decodedResult) => {
            // Successo
            handleScanData(decodedText);
          },
          (errorMessage) => {
            // Errore durante la scansione (es. non trova QR), non fatale
            // console.warn(`Errore scansione QR: ${errorMessage}`);
          }
        ).catch((err) => {
          // Errore grave (es. permessi negati)
          console.error("Errore avvio webcam:", err);
          setError("Impossibile avviare la webcam. Assicurati di aver dato i permessi.");
          setIsScanning(false);
        });

      } catch (e) {
        console.error("Eccezione Html5Qrcode:", e);
        setError("Errore inizializzazione scanner.");
        setIsScanning(false);
      }
    }, 100); // 100ms di ritardo dovrebbero bastare
  };


  const stopWebcamScan = async () => {
    if (html5QrCodeRef.current && html5QrCodeRef.current.isScanning) {
      try {
        await html5QrCodeRef.current.stop();
        console.log("Scanner fermato.");
      } catch (err) {
        console.error("Errore nel fermare lo scanner:", err);
      }
    }
    setIsScanning(false);
  };

  const handleFileScan = async (event) => {
    const file = event.target.files[0];
    if (!file) {
      return;
    }

    setIsLoading(true);
    setError('');

    try {
      // Crea un'istanza "usa e getta" per la scansione file
      const fileScanner = new Html5Qrcode(qrReaderId, /* verbose= */ false);
      const decodedText = await fileScanner.scanFile(file, /* showImage= */ false);
      handleScanData(decodedText);
    } catch (err) {
      console.error("Errore scansione file:", err);
      setError("Impossibile leggere il QR code dal file. Prova un'altra immagine.");
    } finally {
      setIsLoading(false);
      // Pulisce il valore dell'input file per permettere di ricaricare lo stesso file
      event.target.value = null; 
    }
  };

  // Cleanup effect per fermare lo scanner quando il componente viene smontato
  useEffect(() => {
    // Ritorna una funzione di cleanup
    return () => {
      stopWebcamScan();
    };
  }, []); // Esegui solo al mount e unmount

  return (
    <div className="flex flex-col items-center p-4">
      <h2 className="text-2xl font-bold mb-6 text-indigo-400">Scansione QR Code</h2>

      {/* --- NUOVO BLOCCO COOLDOWN --- */}
      {isStealingOnCooldown && (
        <div className="w-full max-w-md p-4 mb-6 text-center bg-red-900 bg-opacity-70 rounded-lg shadow-lg">
          <div className="flex items-center justify-center">
             <Timer className="text-red-300 mr-2" />
             <h3 className="text-lg font-bold text-red-200">Cooldown Furto Attivo</h3>
          </div>
          <p className="text-2xl font-bold text-white mt-2">{cooldownTimer}s</p>
          <p className="text-red-300">Non puoi scansionare personaggi in questo stato.</p>
        </div>
      )}
    
      {isLoading && (
        <div className="text-center text-lg text-gray-300">
          <p>Caricamento dati...</p>
        </div>
      )}

      {error && (
        <div className="text-center text-red-400 bg-red-900 bg-opacity-50 p-3 rounded-md">
          <p>{error}</p>
        </div>
      )}

      <div className="w-full max-w-md mt-4 space-y-4">
        {!isScanning && !isLoading && (
          <>
            <button
              onClick={startWebcamScan}
              className="w-full px-4 py-3 bg-indigo-600 text-white text-lg font-bold rounded-md shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500"
            >
              Avvia Scansione Webcam
            </button>
            
           <label className={`block w-full px-4 py-3 bg-gray-700 text-white text-lg text-center font-bold rounded-md shadow-lg hover:bg-gray-600 cursor-pointer
              ${isStealingOnCooldown ? 'opacity-50 cursor-not-allowed' : ''}`}>
              <span>Carica Immagine QR</span>
              <input
                type="file"
                accept="image/*"
                onChange={handleFileScan}
                className="hidden"
                disabled={isLoading || isStealingOnCooldown} // Disabilitato durante il caricamento o cooldown} 
              />
            </label>
          </>
        )}
      </div>

      {/* Questo è il riquadro dove apparirà lo scanner */}
      {isScanning && (
        <div className="mt-4 flex flex-col items-center w-full">
          {/* L'altezza h-80 è corretta */}
          <div 
            id={qrReaderId} 
            className="w-full max-w-sm h-80 rounded-lg overflow-hidden shadow-lg bg-gray-700"
          >
            {/* Il video della webcam verrà iniettato qui dalla libreria */}
          </div>
          
          <button
            onClick={stopWebcamScan}
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded-md shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500"
          >
            Ferma Scansione
          </button>
        </div>
      )}

      {/* Questo div è necessario per la scansione da file, 
        ma non deve essere visibile. Lo nascondiamo.
      */}
      {!isScanning && <div id={qrReaderId} className="hidden"></div>}

    </div>
  );
};

export default QrTab;



==================================================
FILE: src\components\QuestFaseSection.jsx
==================================================
import React, { useState, useMemo, useEffect } from 'react';
import { Swords, Users, Monitor, Trash, Heart, Shield, Edit2, Plus, ChevronDown, ChevronUp, UserCheck, Shirt, ScrollText, Zap, SquareActivity } from 'lucide-react';
import RichTextEditor from './RichTextEditor';
import RichTextDisplay from './RichTextDisplay';

// --- SOTTO-COMPONENTE PER LA CARD DEL TASK ---
const TaskCard = ({ task, isMaster, currentUserId, onRemove, onStatChange }) => {
    
    // 1. LOGICA "IS MINE" ROBUSTA
    const isMine = useMemo(() => {
        if (!currentUserId || !task.staffer) return false;
        
        // Gestisce sia il caso in cui staffer è un ID (int/string) sia un Oggetto {id: 1, ...}
        const taskStafferId = typeof task.staffer === 'object' && 'id' in task.staffer 
            ? task.staffer.id 
            : task.staffer;

        return String(taskStafferId) === String(currentUserId);
    }, [task.staffer, currentUserId]);

    // Stato apertura: aperto di default se è mio, altrimenti chiuso
    const [expanded, setExpanded] = useState(false);

    useEffect(() => {
        if (isMine) setExpanded(true);
    }, [isMine]);

    // 2. COLORI SFONDO DIFFERENZIATI
    const getRoleStyles = () => {
        switch (task.ruolo) {
            case 'MOSTRO': return 'bg-gradient-to-br from-red-950/60 to-black border-red-900/50 hover:border-red-500/50';
            case 'PNG': return 'bg-gradient-to-br from-indigo-950/60 to-black border-indigo-900/50 hover:border-indigo-500/50';
            default: return 'bg-gradient-to-br from-slate-800/60 to-black border-slate-600/50 hover:border-slate-400/50';
        }
    };

    // Stile Bordo ed Evidenziazione (AMBER se mio)
    const baseClasses = getRoleStyles();
    const highlightClasses = isMine 
        ? "border-amber-500 shadow-[0_0_15px_-3px_rgba(245,158,11,0.3)] ring-1 ring-amber-500/50" 
        : "";

    const nomeTarget = task.personaggio_details?.nome 
        || task.mostro_details?.nome 
        || (task.compito_offgame === 'REG' ? 'Gestione Regole' : task.compito_offgame === 'AIU' ? 'Aiuto Master' : 'Allestimento');

    // 3. FIX CRASH ATTACCHI: Renderizza array o stringa
    const renderAttacchi = (attacchi) => {
        if (!attacchi) return <span className="text-gray-500 italic">Nessun attacco specificato</span>;
        
        // Se è un array di oggetti (dal backend Django)
        if (Array.isArray(attacchi)) {
            if (attacchi.length === 0) return <span className="text-gray-500 italic">Nessun attacco specificato</span>;
            return (
                <div className="space-y-1.5 mt-1">
                    {attacchi.map((att, idx) => (
                        <div key={att.id || idx} className="flex flex-col sm:flex-row sm:justify-between sm:items-baseline border-b border-white/10 last:border-0 pb-1">
                            <span className="font-bold text-red-300 text-[11px] whitespace-nowrap mr-2">• {att.nome_attacco}</span>
                            <span className="text-gray-400 text-[10px] italic">{att.descrizione_danno}</span>
                        </div>
                    ))}
                </div>
            );
        }
        // Se è una stringa (vecchi dati o HTML)
        return <RichTextDisplay content={attacchi} />;
    };

    return (
        <div className={`rounded-xl border p-3 transition-all duration-300 ${baseClasses} ${highlightClasses}`}>
            {/* --- HEADER (Sempre Visibile) --- */}
            <div className="flex flex-col gap-2">
                <div className="flex justify-between items-start gap-2 cursor-pointer select-none" onClick={() => setExpanded(!expanded)}>
                    <div className="flex items-center gap-3 overflow-hidden">
                        {/* Icona Ruolo */}
                        <div className={`p-2 rounded-lg shrink-0 shadow-inner ${task.ruolo === 'MOSTRO' ? 'bg-red-500/20 text-red-400' : task.ruolo === 'PNG' ? 'bg-indigo-500/20 text-indigo-400' : 'bg-slate-500/20 text-slate-400'}`}>
                            {task.ruolo === 'MOSTRO' ? <Swords size={20}/> : task.ruolo === 'PNG' ? <Users size={20}/> : <Monitor size={20}/>}
                        </div>
                        
                        {/* Info Principali */}
                        <div className="flex flex-col min-w-0">
                            <div className="flex items-center gap-2 flex-wrap">
                                <span className={`text-sm font-black uppercase tracking-tight ${isMine ? 'text-amber-100' : 'text-gray-100'}`}>
                                    {nomeTarget}
                                </span>
                                {isMine && (
                                    <span className="text-[9px] bg-amber-500 text-black px-1.5 py-0.5 rounded font-black flex items-center shadow-lg shadow-amber-500/20 animate-pulse">
                                        <UserCheck size={10} className="mr-1"/> TU
                                    </span>
                                )}
                            </div>
                            <div className={`text-[10px] font-bold truncate ${isMine ? 'text-amber-400' : 'text-gray-400'}`}>
                                @{task.staffer_details?.username}
                            </div>
                        </div>
                    </div>

                    <div className="flex items-center gap-1">
                        <div className={`transition-transform duration-300 ${expanded ? 'rotate-180' : ''} text-gray-500`}>
                            <ChevronDown size={20}/>
                        </div>
                        {isMaster && (
                            <button onClick={(e) => { e.stopPropagation(); onRemove(task.id); }} className="p-1.5 hover:bg-red-900/50 text-gray-500 hover:text-red-400 rounded transition-colors ml-2">
                                <Trash size={16}/>
                            </button>
                        )}
                    </div>
                </div>

                {/* Counters Mostri (Visibili sempre) - FIX: aggiunto flex-wrap e Schermo */}
                {task.ruolo === 'MOSTRO' && (
                    <div className="flex flex-wrap gap-2 mt-2 justify-start bg-black/40 p-2 rounded-lg border border-white/5 shadow-inner">
                        <StatMini icon={<Heart size={12}/>} label="PV" value={task.punti_vita} onUp={() => onStatChange(task.id, 'punti_vita', 1)} onDown={() => onStatChange(task.id, 'punti_vita', -1)} color="text-red-500" />
                        
                        {/* 4. CAMPO GUSCIO (SCHERMO) AGGIUNTO */}
                        <StatMini icon={<SquareActivity size={12}/>} label="SC" value={task.guscio || 0} onUp={() => onStatChange(task.id, 'guscio', 1)} onDown={() => onStatChange(task.id, 'guscio', -1)} color="text-cyan-400" />
                        
                        <StatMini icon={<Shield size={12}/>} label="ARM" value={task.armatura} onUp={() => onStatChange(task.id, 'armatura', 1)} onDown={() => onStatChange(task.id, 'armatura', -1)} color="text-gray-300" />
                    </div>
                )}
            </div>

            {/* --- BODY (Collapsible) --- */}
            {expanded && (
                <div className="mt-3 pt-3 border-t border-white/10 space-y-3 animation-fade-in-down origin-top">
                    
                    {/* Istruzioni */}
                    {task.istruzioni && (
                        <div className="bg-black/30 p-3 rounded-lg border border-white/5 text-gray-300 shadow-sm">
                            <div className="text-[9px] font-bold text-gray-500 uppercase mb-1 flex items-center gap-1"><Edit2 size={10}/> Istruzioni Operative</div>
                            <div className="scale-100 origin-top-left">
                                <RichTextDisplay content={task.istruzioni} />
                            </div>
                        </div>
                    )}

                    {/* Dettagli Extra per Mostri */}
                    {task.ruolo === 'MOSTRO' && task.mostro_details && (
                        <div className="grid grid-cols-1 gap-2 text-xs">
                            {/* Costume */}
                            {(task.mostro_details.costume || task.costume) && (
                                <div className="flex items-start gap-2 bg-black/30 p-2 rounded text-gray-300 border border-purple-500/20">
                                    <Shirt size={14} className="mt-0.5 text-purple-400 shrink-0"/>
                                    <div className="w-full">
                                        <span className="font-bold text-purple-400 text-[9px] uppercase block mb-0.5">Costume & Props</span>
                                        <div className="whitespace-pre-wrap leading-relaxed">{task.costume || task.mostro_details.costume}</div>
                                    </div>
                                </div>
                            )}
                            
                            {/* Note Generali */}
                            {task.mostro_details.note_generali && (
                                <div className="flex items-start gap-2 bg-black/30 p-2 rounded text-gray-300 border border-yellow-500/20">
                                    <ScrollText size={14} className="mt-0.5 text-yellow-500 shrink-0"/>
                                    <div className="w-full">
                                        <span className="font-bold text-yellow-500 text-[9px] uppercase block mb-0.5">Comportamento & Note</span>
                                        <div className="whitespace-pre-wrap leading-relaxed">{task.mostro_details.note_generali}</div>
                                    </div>
                                </div>
                            )}

                            {/* Attacchi - FIX CRASH APPLICATO */}
                            <div className="bg-red-950/20 border border-red-900/30 p-2.5 rounded">
                                <div className="flex items-center gap-1 font-bold text-red-400 text-[9px] uppercase mb-1 border-b border-red-900/30 pb-1">
                                    <Zap size={10}/> Elenco Attacchi & Capacità
                                </div>
                                <div className="text-[11px]">
                                    {renderAttacchi(task.mostro_details.attacchi)}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            )}
        </div>
    );
};

// --- COMPONENTE PRINCIPALE ---
const QuestFaseSection = ({ fase, isMaster, risorse, onAddTask, onRemoveTask, onStatChange, onEdit, onDelete }) => {
    const [formOpen, setFormOpen] = useState(false);
    const [form, setForm] = useState({ ruolo: 'PNG', staffer: '', personaggio: '', mostro_template: '', compito_offgame: 'REG', istruzioni: '' });

    // Recupera ID utente corrente
    const currentUserId = useMemo(() => {
        try {
            const userParams = JSON.parse(localStorage.getItem('user'));
            return userParams ? userParams.id : null;
        } catch (e) { return null; }
    }, []);

    const pngFiltrati = useMemo(() => {
        if (!form.staffer) return [];
        const stafferId = parseInt(form.staffer);
        const stafferObj = risorse.staff?.find(s => s.id === stafferId);
        const stafferName = stafferObj ? stafferObj.username : "";

        return risorse.png?.filter(p => {
            let isMio = false;
            if (p.proprietario_id !== undefined) isMio = (p.proprietario_id === stafferId);
            else if (typeof p.proprietario === 'object' && p.proprietario !== null) isMio = (p.proprietario.id === stafferId);
            else if (typeof p.proprietario === 'string') isMio = (p.proprietario === stafferName);
            else isMio = (p.proprietario == stafferId);
            
            const isPnG = (p.giocante === false || p.giocante === undefined);
            return isMio && isPnG;
        }) || [];
    }, [form.staffer, risorse.png, risorse.staff]);

    const tasks = fase.tasks || [];
    const groupedTasks = {
        PNG: tasks.filter(t => t.ruolo === 'PNG'),
        MOSTRO: tasks.filter(t => t.ruolo === 'MOSTRO'),
        OFF: tasks.filter(t => !['PNG', 'MOSTRO'].includes(t.ruolo))
    };

    return (
        <div className="bg-gray-900/60 rounded-xl border border-gray-700/50 overflow-hidden mb-6 shadow-lg">
            <div className="bg-gray-800/80 px-4 py-3 flex justify-between items-center border-b border-gray-700 backdrop-blur-sm sticky top-0 z-10">
                <div className="flex items-center gap-3 overflow-hidden">
                    <span className="bg-indigo-600 text-white text-[10px] font-black px-2 py-1 rounded shadow-lg shrink-0">FASE {fase.ordine}</span>
                    <span className="text-sm font-bold text-gray-200 uppercase tracking-wide truncate">{fase.titolo}</span>
                </div>
                
                {isMaster && (
                    <div className="flex items-center gap-1 bg-black/30 rounded-lg p-1 shrink-0">
                        <button onClick={onEdit} className="text-gray-400 hover:text-white p-2 rounded hover:bg-gray-700 transition-colors"><Edit2 size={16}/></button>
                        <div className="w-px h-4 bg-gray-700 mx-0.5"></div>
                        <button onClick={() => { if(window.confirm("Eliminare questa fase e tutti i suoi task?")) onDelete(); }} className="text-gray-400 hover:text-red-500 p-2 rounded hover:bg-gray-700 transition-colors"><Trash size={16}/></button>
                    </div>
                )}
            </div>

            <div className="p-3 space-y-6">
                
                {/* Gruppo PNG */}
                {groupedTasks.PNG.length > 0 && (
                    <div>
                        <div className="text-[10px] font-black text-indigo-400 uppercase mb-2 flex items-center gap-2 ml-1">
                            <Users size={12}/> Personaggi Non Giocanti
                            <div className="h-px bg-indigo-500/20 flex-1"></div>
                        </div>
                        {/* 5. LAYOUT RESPONSIVE: 1 col (mobile) -> 2 col (md+) */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                            {groupedTasks.PNG.map(task => (
                                <TaskCard key={task.id} task={task} isMaster={isMaster} currentUserId={currentUserId} onRemove={onRemoveTask} onStatChange={onStatChange} />
                            ))}
                        </div>
                    </div>
                )}

                {/* Gruppo MOSTRI */}
                {groupedTasks.MOSTRO.length > 0 && (
                    <div>
                        <div className="text-[10px] font-black text-red-400 uppercase mb-2 flex items-center gap-2 mt-4 ml-1">
                            <Swords size={12}/> Minacce & Mostri
                            <div className="h-px bg-red-500/20 flex-1"></div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                            {groupedTasks.MOSTRO.map(task => (
                                <TaskCard key={task.id} task={task} isMaster={isMaster} currentUserId={currentUserId} onRemove={onRemoveTask} onStatChange={onStatChange} />
                            ))}
                        </div>
                    </div>
                )}

                {/* Gruppo OFF-GAME */}
                {groupedTasks.OFF.length > 0 && (
                    <div>
                        <div className="text-[10px] font-black text-gray-400 uppercase mb-2 flex items-center gap-2 mt-4 ml-1">
                            <Monitor size={12}/> Gestione Off-Game
                            <div className="h-px bg-gray-600/30 flex-1"></div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                            {groupedTasks.OFF.map(task => (
                                <TaskCard key={task.id} task={task} isMaster={isMaster} currentUserId={currentUserId} onRemove={onRemoveTask} onStatChange={onStatChange} />
                            ))}
                        </div>
                    </div>
                )}

                {tasks.length === 0 && (
                    <div className="text-center py-8 text-gray-600 text-xs italic border-2 border-dashed border-gray-800 rounded-xl bg-black/20">
                        Nessun incarico assegnato in questa fase.
                    </div>
                )}

                {/* Form Inserimento */}
                {isMaster && (
                    <div className="mt-6">
                        {!formOpen ? (
                            <button onClick={() => setFormOpen(true)} className="w-full py-3 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded-xl text-[11px] font-black text-gray-400 uppercase tracking-widest flex items-center justify-center gap-2 transition-all shadow-md">
                                <Plus size={16}/> Nuovo Incarico Staff
                            </button>
                        ) : (
                            <div className="bg-gray-950/50 rounded-xl border border-indigo-500/30 overflow-hidden animation-fade-in shadow-xl">
                                <div className="bg-indigo-900/20 px-4 py-3 border-b border-indigo-500/20 flex justify-between items-center">
                                    <span className="text-[11px] font-black text-indigo-400 uppercase tracking-wider">Configura Nuovo Task</span>
                                    <button onClick={() => setFormOpen(false)} className="text-indigo-400 hover:text-white"><ChevronUp size={16}/></button>
                                </div>
                                <div className="p-4 space-y-4">
                                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                        <div className="space-y-1">
                                            <label className="text-[9px] font-bold text-gray-500 uppercase px-1">Membro Staff</label>
                                            <select className="w-full bg-gray-900 p-2.5 rounded-lg text-xs text-white border border-gray-700 focus:border-indigo-500 outline-none shadow-inner" 
                                                value={form.staffer} onChange={e => setForm({...form, staffer: e.target.value, personaggio: ''})}>
                                                <option value="">Seleziona Staffer...</option>
                                                {risorse.staff?.map(s => <option key={s.id} value={s.id}>{s.username}</option>)}
                                            </select>
                                        </div>
                                        <div className="space-y-1">
                                            <label className="text-[9px] font-bold text-gray-500 uppercase px-1">Ruolo / Tipo</label>
                                            <select className="w-full bg-gray-900 p-2.5 rounded-lg text-xs text-indigo-400 border border-gray-700 font-black focus:border-indigo-500 outline-none shadow-inner" 
                                                value={form.ruolo} onChange={e => setForm({...form, ruolo: e.target.value})}>
                                                <option value="PNG">RUOLO: PnG</option>
                                                <option value="MOSTRO">RUOLO: Mostro</option>
                                                <option value="OFF">RUOLO: Off-Game</option>
                                            </select>
                                        </div>
                                    </div>

                                    {form.ruolo === 'PNG' && (
                                        <div className="space-y-1">
                                            <label className="text-[9px] font-bold text-gray-500 uppercase px-1">Personaggio PnG</label>
                                            <select className="w-full bg-gray-900 p-2.5 rounded-lg text-xs text-white border border-gray-700 focus:border-indigo-500 outline-none shadow-inner" 
                                                value={form.personaggio} onChange={e => setForm({...form, personaggio: e.target.value})} disabled={!form.staffer}>
                                                <option value="">{form.staffer ? "Seleziona PnG dello Staffer..." : "Prima seleziona un membro dello Staff"}</option>
                                                {pngFiltrati.map(p => <option key={p.id} value={p.id}>{p.nome}</option>)}
                                            </select>
                                        </div>
                                    )}
                                    {form.ruolo === 'MOSTRO' && (
                                        <div className="space-y-1">
                                            <label className="text-[9px] font-bold text-gray-500 uppercase px-1">Template Mostro</label>
                                            <select className="w-full bg-gray-900 p-2.5 rounded-lg text-xs text-white border border-gray-700 focus:border-indigo-500 outline-none shadow-inner" 
                                                value={form.mostro_template} onChange={e => setForm({...form, mostro_template: e.target.value})}>
                                                <option value="">Seleziona Template Mostro...</option>
                                                {risorse.templates?.map(t => <option key={t.id} value={t.id}>{t.nome}</option>)}
                                            </select>
                                        </div>
                                    )}
                                    {form.ruolo === 'OFF' && (
                                        <div className="flex gap-2 justify-center bg-gray-900 p-1 rounded-lg border border-gray-700">
                                            {[ ['REG', 'Regole'], ['AIU', 'Aiuto'], ['ALL', 'Allestimento'] ].map(([v, l]) => (
                                                <label key={v} className={`flex-1 text-center py-2 rounded-md cursor-pointer text-[10px] font-bold transition-all ${form.compito_offgame === v ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-gray-800 text-gray-500'}`}>
                                                    <input type="radio" className="hidden" value={v} checked={form.compito_offgame === v} onChange={e => setForm({...form, compito_offgame: e.target.value})} /> {l}
                                                </label>
                                            ))}
                                        </div>
                                    )}

                                    <div className="h-64 border border-gray-700 rounded-lg overflow-hidden bg-gray-900 shadow-inner">
                                        <RichTextEditor value={form.istruzioni} onChange={(val) => setForm({...form, istruzioni: val})} placeholder="Istruzioni dettagliate per lo staffer..." />
                                    </div>
                                    
                                    <div className="flex gap-3 pt-2">
                                        <button onClick={() => setFormOpen(false)} className="flex-1 py-3 rounded-lg border border-gray-700 text-gray-400 text-[10px] font-bold hover:bg-gray-800 transition-colors uppercase">Annulla</button>
                                        <button onClick={() => { onAddTask({ fase: fase.id, ...form }); setForm({...form, personaggio: '', mostro_template: '', istruzioni: ''}); setFormOpen(false); }} className="flex-2 bg-indigo-600 hover:bg-indigo-500 py-3 rounded-lg font-black text-[10px] uppercase text-white shadow-lg shadow-indigo-900/30 transition-all transform active:scale-95">Conferma Incarico</button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
};

const StatMini = ({ icon, label, value, onUp, onDown, color }) => (
    <div className={`flex items-center gap-2 bg-black/60 px-2 py-1.5 rounded-lg border border-gray-800 ${color} shadow-sm min-w-[75px] justify-between`}>
        <div className="flex items-center gap-1.5">
            {icon} 
            <div className="flex flex-col leading-none">
                <span className="text-[7px] font-bold opacity-60 uppercase">{label}</span>
                <span className="text-xs font-black text-white">{value}</span>
            </div>
        </div>
        <div className="flex flex-col ml-1 gap-px">
            <button onClick={onUp} className="text-[8px] leading-none text-gray-500 hover:text-white hover:bg-gray-700 px-1 py-px rounded transition-colors">▲</button>
            <button onClick={onDown} className="text-[8px] leading-none text-gray-500 hover:text-white hover:bg-gray-700 px-1 py-px rounded transition-colors">▼</button>
        </div>
    </div>
);

export default QuestFaseSection;

==================================================
FILE: src\components\QuestItem.jsx
==================================================
// src/components/QuestItem.jsx
import React, { useState, useMemo } from 'react';
import { Edit2, Trash, Plus, Package, List, User as UserIcon, QrCode as QrIcon, X } from 'lucide-react';
import RichTextDisplay from './RichTextDisplay';
import QuestFaseSection from './QuestFaseSection';

const QuestItem = ({ quest, isMaster, risorse, onAddSub, onRemoveSub, onStatChange, onEdit, onScanQr }) => {
    const [viewMode, setViewMode] = useState('FASI'); // 'FASI' o 'STAFF'
    const [newVista, setNewVista] = useState({ tipo: 'MAN', contentId: '' });

    const tasksByStaff = useMemo(() => {
        const map = {};
        quest.fasi?.forEach(fase => {
            fase.tasks?.forEach(task => {
                if (!map[task.staffer]) map[task.staffer] = { details: task.staffer_details, items: [] };
                map[task.staffer].items.push({ ...task, fase_titolo: fase.titolo });
            });
        });
        return Object.values(map);
    }, [quest.fasi]);

    return (
        <div className="bg-gray-800/40 border border-gray-700/50 rounded-2xl overflow-hidden shadow-2xl border-l-4 border-l-indigo-500 w-full mb-8">
            {/* 1. Header (Titolo/Orario) */}
            <div className="bg-gray-800/80 px-5 py-3 flex justify-between items-center border-b border-gray-700">
                <div className="flex items-center gap-4">
                    <div className="bg-indigo-600 text-white px-3 py-1 rounded-lg font-black text-xs shadow-lg">{quest.orario_indicativo?.slice(0, 5)}</div>
                    <h3 className="font-black text-lg text-white uppercase tracking-tight truncate">{quest.titolo}</h3>
                </div>
                <div className="flex items-center gap-4">
                    <div className="flex bg-black/40 rounded-lg p-1 border border-gray-700">
                        <button onClick={() => setViewMode('FASI')} className={`p-1.5 rounded transition-colors ${viewMode === 'FASI' ? 'bg-indigo-600 text-white' : 'text-gray-500 hover:text-gray-300'}`}><List size={18}/></button>
                        <button onClick={() => setViewMode('STAFF')} className={`p-1.5 rounded transition-colors ${viewMode === 'STAFF' ? 'bg-indigo-600 text-white' : 'text-gray-500 hover:text-gray-300'}`}><UserIcon size={18}/></button>
                    </div>
                    {isMaster && (
                        <div className="flex gap-2 border-l border-gray-700 pl-4">
                            <button onClick={() => onEdit('quest', quest)} className="text-gray-400 hover:text-white"><Edit2 size={18}/></button>
                            <button onClick={() => onRemoveSub('quest', quest.id)} className="text-red-900 hover:text-red-500"><Trash size={18}/></button>
                        </div>
                    )}
                </div>
            </div>

            <div className="p-6 space-y-8">
                {/* 2. Info Quest (Descrizione e Props) */}
                <div className="space-y-4">
                    {quest.descrizione_ampia && <div className="bg-black/20 p-4 rounded-xl border border-gray-800 italic text-gray-300 leading-relaxed"><RichTextDisplay content={quest.descrizione_ampia} /></div>}
                    {quest.props && (
                        <div className="flex items-start gap-3 bg-amber-900/10 border border-amber-900/20 p-4 rounded-xl">
                            <Package size={20} className="text-amber-500 shrink-0 mt-0.5" />
                            <div><span className="text-[10px] font-black text-amber-500 uppercase block mb-1 tracking-widest">Materiale di Scena:</span><div className="text-amber-100/80 text-sm"><RichTextDisplay content={quest.props} /></div></div>
                        </div>
                    )}
                </div>

                {/* 3. Gestione Fasi o Staff */}
                <div className="min-h-[200px]">
                    {viewMode === 'FASI' ? (
                        <div className="space-y-4">
                            {quest.fasi?.map(fase => (
                                <QuestFaseSection 
                                    key={fase.id} 
                                    fase={fase} 
                                    isMaster={isMaster} 
                                    risorse={risorse}
                                    onAddTask={(p) => onAddSub('task', p)} 
                                    onRemoveTask={(id) => onRemoveSub('task', id)}
                                    onStatChange={onStatChange} 
                                    onEdit={() => onEdit('fase', fase)}
                                    onDelete={() => onRemoveSub('fase', fase.id)}
                                />
                            ))}
                            {isMaster && (
                                <button onClick={() => onAddSub('fase', { quest: quest.id, titolo: 'Nuova Fase', ordine: (quest.fasi?.length || 0) + 1 })}
                                    className="w-full py-3 border-2 border-dashed border-gray-700 rounded-xl text-gray-500 hover:border-indigo-500 hover:text-indigo-400 transition-all font-black text-xs uppercase tracking-widest">
                                    + Aggiungi Fase Operativa
                                </button>
                            )}
                        </div>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {tasksByStaff.map(staff => (
                                <div key={staff.details.id} className="bg-gray-900/40 p-4 rounded-xl border border-gray-800 shadow-inner">
                                    <div className="text-xs font-black text-indigo-400 uppercase mb-3 flex items-center gap-2">
                                        <div className="w-6 h-6 rounded-full bg-indigo-900/50 flex items-center justify-center text-[10px]">{staff.details.username[0]}</div>
                                        {staff.details.username}
                                    </div>
                                    <div className="space-y-2">
                                        {staff.items.map(t => (
                                            <div key={t.id} className="text-[10px] text-gray-400 border-t border-gray-800/50 pt-2 flex justify-between">
                                                <span><span className="text-white font-bold">{t.fase_titolo}:</span> {t.personaggio_details?.nome || t.mostro_details?.nome || t.compito_offgame}</span>
                                                <span className="text-[8px] font-black uppercase text-gray-600">{t.ruolo}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>

                {/* 4. Viste & QR (Spostato in fondo e reso più visibile) */}
                <div className="pt-6 border-t border-gray-700/50">
                    <span className="text-[10px] font-black text-emerald-500 uppercase flex items-center gap-2 mb-4 tracking-widest"><QrIcon size={14}/> Elementi di Gioco & QR Code</span>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                        {quest.viste_previste.map(v => (
                            <div key={v.id} className="flex items-center gap-3 bg-gray-950 border border-gray-800 p-2.5 rounded-xl shadow-sm">
                                <div className={`p-2 rounded-lg ${v.qr_code ? 'bg-emerald-500/10 text-emerald-500' : 'bg-gray-800 text-gray-600'}`}><QrIcon size={18} /></div>
                                <div className="flex-1 min-w-0">
                                    <div className="text-[11px] font-bold text-gray-200 truncate">{v.manifesto_details?.nome || v.manifesto_details?.titolo || v.inventario_details?.nome || 'OGGETTO'}</div>
                                    <div className="text-[8px] text-gray-500 uppercase font-black">{v.tipo}</div>
                                </div>
                                <div className="flex gap-1 shrink-0">
                                    <button onClick={() => onScanQr(v.id)} className="text-indigo-400 p-1.5 hover:bg-gray-800 rounded transition-colors" title="Associa QR"><QrIcon size={14}/></button>
                                    {isMaster && <button onClick={() => onRemoveSub('vista', v.id)} className="text-red-900 hover:text-red-500 p-1.5 hover:bg-gray-800 rounded transition-colors"><X size={14}/></button>}
                                </div>
                            </div>
                        ))}
                        {isMaster && (
                            <div className="flex items-center gap-2 bg-emerald-950/20 border border-dashed border-emerald-900/50 p-2 rounded-xl">
                                <select className="bg-transparent text-[10px] font-black text-emerald-500 outline-none" value={newVista.tipo} onChange={(e) => setNewVista({tipo: e.target.value, contentId: ''})}>
                                    <option value="MAN">MAN</option><option value="INV">INV</option>
                                </select>
                                <select className="bg-transparent text-[10px] text-gray-400 outline-none flex-1 min-w-0" value={newVista.contentId} onChange={(e) => setNewVista({...newVista, contentId: e.target.value})}>
                                    <option value="">Seleziona...</option>
                                    {newVista.tipo === 'INV' ? risorse.inventari.map(i => <option key={i.id} value={i.id}>{i.nome}</option>) : risorse.manifesti.map(m => <option key={m.id} value={m.id}>{m.nome || m.titolo}</option>)}
                                </select>
                                <button onClick={() => { if(!newVista.contentId) return alert("Seleziona contenuto"); onAddSub('vista', { quest: quest.id, ...newVista }); setNewVista({...newVista, contentId: ''}); }} className="text-emerald-500 hover:scale-110 p-1 transition-transform"><Plus size={18}/></button>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default QuestItem;

==================================================
FILE: src\components\RichTextDisplay.jsx
==================================================
import React, { useMemo } from 'react';
import { sanitizeHtml } from '../utils/htmlSanitizer';

const RichTextDisplay = ({ content }) => {
    // Pulisce il contenuto ogni volta che cambia
    const cleanContent = useMemo(() => sanitizeHtml(content), [content]);

    if (!cleanContent) return null;

    return (
        <div 
            className="ql-editor-view w-full"
            style={{
                // Reset CSS locale per garantire leggibilità
                fontSize: '0.875rem',
                lineHeight: '1.6',
                color: '#d1d5db', // gray-300
                
                // Regole di wrapping blindate
                whiteSpace: 'normal',       
                overflowWrap: 'anywhere',   
                wordBreak: 'normal',        
                
                maxWidth: '100%',
                minWidth: '0'
            }}
            dangerouslySetInnerHTML={{ __html: cleanContent }}
        />
    );
};

export default RichTextDisplay;

==================================================
FILE: src\components\RichTextEditor.jsx
==================================================
import React, { useRef, useEffect } from 'react';
import { Bold, Italic, List, ListOrdered, AlignLeft, AlignCenter, AlignRight } from 'lucide-react';

const RichTextEditor = ({ value, onChange, placeholder, label }) => {
    const editorRef = useRef(null);

    // Sincronizza il contenuto solo se diverso per evitare loop o reset del cursore
    useEffect(() => {
        if (editorRef.current && editorRef.current.innerHTML !== value) {
            // Se il valore è vuoto o null, pulisci l'editor
            if (!value) {
                editorRef.current.innerHTML = '';
            } else {
                // Attenzione: qui potresti voler gestire la posizione del cursore se necessario,
                // ma per aggiornamenti esterni semplici questo va bene.
                editorRef.current.innerHTML = value;
            }
        }
    }, [value]);

    const handleInput = (e) => {
        const html = e.currentTarget.innerHTML;
        onChange(html); 
    };

    // --- FIX CRASH COPIA/INCOLLA ---
    const handlePaste = (e) => {
        e.preventDefault(); // Impedisce al browser di incollare l'HTML sporco
        
        // Recupera solo il testo semplice dagli appunti
        const text = e.clipboardData.getData('text/plain');
        
        // Inserisce il testo pulito nella posizione del cursore
        // execCommand è deprecato ma è ancora l'unico modo affidabile per contentEditable 
        // per inserire testo mantenendo la history (undo/redo) funzionante.
        document.execCommand("insertText", false, text);
    };
    // -------------------------------

    const execCommand = (command, value = null) => {
        document.execCommand(command, false, value);
        if (editorRef.current) {
            onChange(editorRef.current.innerHTML);
            editorRef.current.focus();
        }
    };

    const ToolbarButton = ({ icon: Icon, command, arg, title }) => (
        <button
            type="button" // Importante: impedisce il submit del form se dentro un form
            onClick={(e) => { e.preventDefault(); execCommand(command, arg); }}
            className="p-1.5 text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors"
            title={title}
        >
            <Icon size={14} />
        </button>
    );

    return (
        <>
            <label className="block text-xs text-gray-500 mb-1">{label}</label>
            <div className="flex flex-col h-full bg-gray-900 border border-gray-700 rounded-lg overflow-hidden focus-within:border-indigo-500 focus-within:ring-1 focus-within:ring-indigo-500/50 transition-all">
                {/* Toolbar */}
                <div className="flex items-center gap-1 bg-gray-800/50 p-1 border-b border-gray-700">
                    <ToolbarButton icon={Bold} command="bold" title="Grassetto" />
                    <ToolbarButton icon={Italic} command="italic" title="Corsivo" />
                    <div className="w-px h-4 bg-gray-700 mx-1"></div>
                    <ToolbarButton icon={List} command="insertUnorderedList" title="Elenco Puntato" />
                    <ToolbarButton icon={ListOrdered} command="insertOrderedList" title="Elenco Numerato" />
                    <div className="w-px h-4 bg-gray-700 mx-1"></div>
                    <ToolbarButton icon={AlignLeft} command="justifyLeft" title="Allinea Sinistra" />
                    <ToolbarButton icon={AlignCenter} command="justifyCenter" title="Allinea Centro" />
                    {/* <ToolbarButton icon={AlignRight} command="justifyRight" title="Allinea Destra" /> */}
                </div>

                {/* Editor Area */}
                <div
                    ref={editorRef}
                    contentEditable
                    onInput={handleInput}
                    onPaste={handlePaste} // <--- AGGIUNTO L'HANDLER QUI
                    className="flex-1 p-3 text-[11px] text-gray-200 outline-none overflow-y-auto custom-scrollbar leading-relaxed"
                    style={{ minHeight: '100px' }}
                    data-placeholder={placeholder}
                />
                
                {/* Placeholder visivo simulato con CSS se vuoto */}
                <style jsx>{`
                    [contenteditable]:empty:before {
                        content: attr(data-placeholder);
                        color: #6b7280;
                        font-style: italic;
                        pointer-events: none;
                        display: block; /* For Firefox */
                    }
                `}</style>
            </div>
        </>
    );
};

export default RichTextEditor;

==================================================
FILE: src\components\ShopModal.jsx
==================================================
import React, { useState } from 'react';
import { Dialog } from '@headlessui/react';
import { X, ShoppingBag, Loader2, Info } from 'lucide-react';
import { useShopItems } from '../hooks/useGameData';
import { buyShopItem } from '../api';
import { useCharacter } from './CharacterContext';

const ShopModal = ({ onClose }) => {
  const { data: items, isLoading } = useShopItems();
  const { selectedCharacterData: char, refreshCharacterData } = useCharacter();
  const [buyingId, setBuyingId] = useState(null);

  const handleBuy = async (item) => {
    // Nota: OggettoBase usa 'costo', non 'costo_acquisto'
    if (char.crediti < item.costo) {
        alert("Crediti insufficienti!");
        return;
    }
    if (!window.confirm(`Acquistare ${item.nome} per ${item.costo} CR?`)) return;

    setBuyingId(item.id);
    try {
        // L'API si aspetta 'oggetto_id' che qui è l'ID del template OggettoBase
        await buyShopItem(item.id, char.id);
        await refreshCharacterData(); // Ricarica inventario e crediti
        // Non chiudiamo il modale per permettere acquisti multipli
    } catch (error) {
        alert("Errore acquisto: " + error.message);
    } finally {
        setBuyingId(null);
    }
  };

  return (
    <Dialog open={true} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/70 backdrop-blur-sm" aria-hidden="true" />
      
      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="w-full max-w-2xl bg-gray-900 border border-gray-700 rounded-xl shadow-2xl max-h-[90vh] flex flex-col animate-fadeIn">
            {/* Header */}
            <div className="flex justify-between items-center p-4 border-b border-gray-700 bg-gray-800/50 rounded-t-xl">
                <Dialog.Title className="text-xl font-bold text-white flex items-center gap-2">
                    <ShoppingBag className="text-yellow-500" />
                    Negozio Base
                </Dialog.Title>
                <div className="flex items-center gap-4">
                    <div className="text-sm font-mono text-yellow-400 bg-yellow-900/20 px-3 py-1 rounded-full border border-yellow-700/30">
                        {char?.crediti || 0} CR
                    </div>
                    <button onClick={onClose} className="text-gray-400 hover:text-white transition-colors">
                        <X size={24} />
                    </button>
                </div>
            </div>

            {/* Content */}
            <div className="p-4 overflow-y-auto grow custom-scrollbar">
                {isLoading ? (
                    <div className="flex justify-center p-8"><Loader2 className="animate-spin text-indigo-500" size={32} /></div>
                ) : (
                    <div className="grid gap-3 sm:grid-cols-2">
                        {items?.map((item) => (
                            <div key={item.id} className="bg-gray-800 p-3 rounded-lg border border-gray-700 flex flex-col justify-between hover:border-gray-600 transition-colors group">
                                <div>
                                    <div className="flex justify-between items-start mb-1">
                                        <h4 className="font-bold text-gray-200">{item.nome}</h4>
                                        <span className="text-[10px] uppercase bg-gray-900 px-2 py-0.5 rounded text-gray-400 border border-gray-700 font-bold tracking-wider">
                                            {item.classe_oggetto_nome || "Oggetto"}
                                        </span>
                                    </div>
                                    
                                    {/* Descrizione e Stats */}
                                    <div className="text-xs text-gray-400 mb-2 line-clamp-2">
                                        {item.descrizione || <i>Nessuna descrizione</i>}
                                    </div>
                                    
                                    {/* Statistiche Tecniche (es. Danni, Bonus) */}
                                    {item.stats_text && (
                                        <div className="mb-3 text-[10px] text-indigo-300 bg-indigo-900/20 px-2 py-1 rounded border border-indigo-500/20 flex items-start gap-1">
                                            <Info size={12} className="shrink-0 mt-0.5" />
                                            <span>{item.stats_text}</span>
                                        </div>
                                    )}
                                </div>
                                
                                <div className="flex justify-between items-center mt-auto pt-3 border-t border-gray-700/50">
                                    <span className="font-mono font-bold text-yellow-500">{item.costo} CR</span>
                                    <button
                                        onClick={() => handleBuy(item)}
                                        disabled={buyingId === item.id || char.crediti < item.costo}
                                        className={`px-3 py-1.5 rounded text-sm font-bold flex items-center gap-2 transition-all ${
                                            char.crediti >= item.costo
                                            ? 'bg-indigo-600 hover:bg-indigo-500 text-white shadow-lg shadow-indigo-500/20'
                                            : 'bg-gray-700 text-gray-500 cursor-not-allowed opacity-50'
                                        }`}
                                    >
                                        {buyingId === item.id ? <Loader2 className="animate-spin" size={16} /> : "Compra"}
                                    </button>
                                </div>
                            </div>
                        ))}
                        {(!items || items.length === 0) && (
                            <div className="col-span-full text-center text-gray-500 py-12 border border-dashed border-gray-700 rounded-xl">
                                Nessun oggetto attualmente in vendita.
                            </div>
                        )}
                    </div>
                )}
            </div>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

export default ShopModal;

==================================================
FILE: src\components\Sidebar.jsx
==================================================
import React, { useState } from 'react';
import { X, LogOut, ChevronDown, ChevronRight } from 'lucide-react';
import versionData from '../../package.json'; 

const Sidebar = ({ isOpen, onClose, title, items, onLogout }) => {
    const [expandedItems, setExpandedItems] = useState({});

    // Se non è aperto, non renderizzare nulla (evita overlay invisibili)
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex justify-end font-sans">
            {/* Overlay Sfondo Scuro */}
            <div 
                className="absolute inset-0 bg-black/60 backdrop-blur-sm transition-opacity" 
                onClick={onClose}
            ></div>
            
            {/* Pannello Laterale (Ancorato a DESTRA) */}
            <div className="relative w-72 bg-gray-950 h-full border-l border-gray-800 flex flex-col shadow-2xl animate-in slide-in-from-right duration-200 z-50">
                
                {/* Header Sidebar */}
                <div className="p-6 flex justify-between items-center border-b border-gray-900">
                    <span className="font-black text-indigo-400 italic tracking-widest uppercase text-sm">{title}</span>
                    <button onClick={onClose} className="p-1 hover:bg-gray-800 rounded-full text-gray-400 hover:text-white transition-colors">
                        <X size={20}/>
                    </button>
                </div>

                {/* Lista Voci */}
                <nav className="flex-1 overflow-y-auto p-4 space-y-2 custom-scrollbar">
                    {items.map((item, idx) => {
                        const hasSubItems = item.subItems && item.subItems.length > 0;
                        const isExpanded = expandedItems[item.label];
                        
                        // Separatore
                        if (item.label.includes('---')) return <div key={idx} className="h-px bg-gray-800 my-2 mx-4"></div>;

                        return (
                            <div key={idx} className="flex flex-col">
                                <button 
                                    onClick={() => {
                                        if (hasSubItems) {
                                            setExpandedItems(prev => ({ ...prev, [item.label]: !prev[item.label] }));
                                        } else { 
                                            item.action(); 
                                            onClose(); 
                                        }
                                    }}
                                    className={`w-full flex items-center justify-between p-4 rounded-xl font-bold transition-all ${
                                        item.active 
                                        ? 'bg-indigo-600 text-white shadow-lg' 
                                        : 'text-gray-400 hover:bg-gray-900 hover:text-white'
                                    }`}
                                >
                                    <div className="flex items-center gap-3">
                                        {item.icon}
                                        <span className="text-sm uppercase tracking-wide truncate">{item.label}</span>
                                    </div>
                                    {hasSubItems && (
                                        isExpanded ? <ChevronDown size={16}/> : <ChevronRight size={16}/>
                                    )}
                                </button>

                                {/* Sottovoci (Tools) */}
                                {hasSubItems && isExpanded && (
                                    <div className="ml-8 pl-4 border-l-2 border-gray-800 mt-1 space-y-1 animate-in slide-in-from-top-2 duration-200">
                                        {item.subItems.map((sub, sIdx) => (
                                            <button 
                                                key={sIdx}
                                                onClick={() => { sub.action(); onClose(); }}
                                                className={`w-full text-left p-2 rounded-lg text-xs font-bold uppercase tracking-wider transition-colors ${
                                                    sub.active ? 'text-indigo-400 bg-indigo-500/10' : 'text-gray-500 hover:text-gray-300'
                                                }`}
                                            >
                                                {sub.label}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </nav>

                {/* Footer */}
                <div className="p-4 border-t border-gray-900 bg-gray-950">
                    <button onClick={onLogout} className="w-full flex items-center gap-3 p-4 rounded-xl font-bold text-red-500 hover:bg-red-500/10 transition-all mb-4">
                        <LogOut size={20} /><span className="text-sm uppercase tracking-wide">Logout</span>
                    </button>
                    <div className="text-center">
                        <span className="text-[10px] text-gray-600 font-mono tracking-widest">v{versionData?.version || '1.0'}</span>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default Sidebar;

==================================================
FILE: src\components\StaffDashboard.jsx
==================================================
import React, { useState } from 'react';
import GenericHeader from './GenericHeader';
import Sidebar from './Sidebar';
import versionData from '../../package.json'; 
import { 
    Map, Scroll, FlaskConical, Gavel, 
    Feather, Shield, MessageSquare, Users, 
    LayoutGrid, LogOut, ClipboardCheck,
    Skull, BookOpen, Menu, ChevronRight, Globe, // Aggiunto Globe
    Layers, Globe2,
} from 'lucide-react';
import { Link } from 'react-router-dom';

// Importazione dei Sotto-Componenti (Tools)
import PlotTab from './PlotTab';
import AdminMessageTab from './AdminMessageTab';
import CerimonialeManager from './editors/CerimonialeManager'; 
import InfusioneManager from './editors/InfusioneManager';
import TessituraManager from './editors/TessituraManager';
import OggettoBaseManager from './editors/OggettoBaseManager';
import OggettoManager from './editors/OggettoManager';
import StaffProposalTab from './editors/StaffProposalTab';
import MostroManager from './editors/MostroManager'; 
import AbilitaManager from './editors/AbilitaManager';
import TabellaManager from './editors/TabellaManager';

const StaffDashboard = ({ onLogout, onSwitchToPlayer, initialTool = 'home' }) => {
    const [activeTool, setActiveTool] = useState(initialTool); 
    const [isMenuOpen, setIsMenuOpen] = useState(false);

    // Configurazione dei Tools disponibili
    const toolsConfig = [
        { id: 'plot', label: 'Gestione Plot', icon: <Map size={24} />, color: 'bg-indigo-600', component: <PlotTab onLogout={onLogout} /> },
        { id: 'mostri', label: 'Database Mostri', icon: <Skull size={24} />, color: 'bg-red-700', component: <MostroManager onLogout={onLogout} /> }, 
        { id: 'abilita', label: 'Database Abilità', icon: <BookOpen size={24} />, color: 'bg-blue-700', component: <AbilitaManager onLogout={onLogout} /> },
        { id: 'cerimoniali', label: 'Cerimoniali', icon: <Scroll size={24} />, color: 'bg-amber-700', component: <CerimonialeManager onLogout={onLogout} /> },
        { id: 'tessiture', label: 'Tessiture', icon: <Feather size={24} />, color: 'bg-cyan-700', component: <TessituraManager onLogout={onLogout} /> },
        { id: 'infusioni', label: 'Infusioni', icon: <FlaskConical size={24} />, color: 'bg-purple-700', component: <InfusioneManager onLogout={onLogout} /> },
        { id: 'proposte', label: 'Valutazione Proposte', icon: <ClipboardCheck size={24} />, color: 'bg-orange-600', component: <StaffProposalTab onLogout={onLogout} /> },
        { id: 'oggetti', label: 'Database Oggetti', icon: <Gavel size={24} />, color: 'bg-stone-600', component: <OggettoManager onLogout={onLogout} /> },
        { id: 'oggetti-base', label: 'Oggetti Base', icon: <Shield size={24} />, color: 'bg-stone-800', component: <OggettoBaseManager onLogout={onLogout} /> },
        { id: 'tabelle', label: 'Gestione Tabelle', icon: <Layers size={24} />, color: 'bg-pink-700', component: <TabellaManager onLogout={onLogout} /> },
        { id: 'messaggi', label: 'Messaggi Staff', icon: <MessageSquare size={24} />, color: 'bg-emerald-600', component: <AdminMessageTab onLogout={onLogout} /> },        
    ];

    const handleToolSelect = (id) => {
        setActiveTool(id);
        setIsMenuOpen(false);
    };

    // Configurazione unificata degli elementi della sidebar
    const sidebarItems = [
        { label: 'Master Hub', icon: <LayoutGrid size={18}/>, active: activeTool === 'home', action: () => handleToolSelect('home') },
        ...toolsConfig.map(t => ({
            label: t.label,
            icon: React.cloneElement(t.icon, { size: 18 }),
            active: activeTool === t.id,
            action: () => handleToolSelect(t.id)
        })),
        { label: '----------------', icon: null, action: () => {} },
        // Aggiunto Wiki come elemento della lista, ma con proprietà 'link'
        { label: 'Wiki Pubblica', icon: <Globe size={18}/>, link: '/', active: false },
        { label: 'Vai a Personaggi', icon: <Users size={18}/>, action: onSwitchToPlayer, active: false }
    ];

    // Funzione helper per renderizzare un singolo item della sidebar
    const renderSidebarItem = (item, idx) => {
        if (item.label.includes('---')) return <div key={idx} className="h-px bg-gray-900 my-2 mx-4"></div>;
        
        const baseClasses = `w-full flex items-center justify-between p-3 rounded-xl font-bold transition-all group ${
            item.active 
            ? 'bg-indigo-600 text-white shadow-lg' 
            : 'text-gray-400 hover:bg-gray-900 hover:text-white'
        }`;

        const content = (
            <>
                <div className="flex items-center gap-3">
                    <div className={`transition-transform duration-200 ${item.active ? '' : 'group-hover:scale-110'}`}>
                        {item.icon}
                    </div>
                    <span className="text-xs uppercase tracking-wide truncate">{item.label}</span>
                </div>
                {item.active && <ChevronRight size={14} className="opacity-50"/>}
            </>
        );

        if (item.link) {
            return (
                <Link key={idx} to={item.link} className={baseClasses} title={item.label}>
                    {content}
                </Link>
            );
        }

        return (
            <button key={idx} onClick={item.action} className={baseClasses}>
                {content}
            </button>
        );
    };

    return (
        <div className="flex h-screen bg-gray-950 text-white overflow-hidden font-sans">
            
            {/* === SIDEBAR DESKTOP (Fissa a sinistra, solo desktop) === */}
            <aside className="hidden md:flex flex-col w-72 bg-gray-950 border-r border-gray-800 shadow-2xl z-20">
                <div className="p-6 border-b border-gray-900 flex items-center gap-3">
                     <div className="bg-indigo-600 p-1.5 rounded-lg shadow-lg shadow-indigo-900/50">
                        <LayoutGrid size={20} className="text-white"/>
                     </div>
                     <span className="font-black text-indigo-400 italic tracking-widest uppercase text-sm">MENU MASTER</span>
                </div>
                
                <nav className="flex-1 overflow-y-auto p-4 space-y-2 custom-scrollbar">
                    {sidebarItems.map((item, idx) => renderSidebarItem(item, idx))}
                </nav>

                <div className="p-4 border-t border-gray-900 bg-gray-950">
                    <button onClick={onLogout} className="w-full flex items-center gap-3 p-3 rounded-xl font-bold text-red-500 hover:bg-red-500/10 transition-all mb-2">
                        <LogOut size={18} /><span className="text-xs uppercase tracking-wide">Logout</span>
                    </button>
                    <div className="text-center">
                        <span className="text-[10px] text-gray-700 font-mono tracking-widest">v{versionData?.version || '1.0'}</span>
                    </div>
                </div>
            </aside>

            {/* === SIDEBAR MOBILE (Overlay a DESTRA) === */}
            <Sidebar 
                isOpen={isMenuOpen} 
                onClose={() => setIsMenuOpen(false)} 
                title="Menu Master"
                items={sidebarItems} 
                onLogout={onLogout} 
            />

            {/* === CONTENUTO PRINCIPALE === */}
            <div className="flex-1 flex flex-col min-w-0 overflow-hidden relative bg-gray-900">
                <GenericHeader 
                    title="KOR 35"
                    subtitle={activeTool === 'home' ? "Dashboard" : toolsConfig.find(t => t.id === activeTool)?.label}
                    rightSlot={
                        <div className="flex items-center gap-2">
                            {/* Tasto Home Rapido */}
                            {activeTool !== 'home' && (
                                <button onClick={() => setActiveTool('home')} className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-gray-400 transition-colors" title="Dashboard">
                                    <LayoutGrid size={20}/>
                                </button>
                            )}
                            
                            {/* Hamburger Menu (Visibile SOLO su Mobile, apre sidebar a destra) */}
                            <button 
                                onClick={() => setIsMenuOpen(true)} 
                                className="md:hidden p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-indigo-400 transition-colors"
                            >
                                <Menu size={24} />
                            </button>
                        </div>
                    }
                />

                <main className="flex-1 overflow-y-auto overflow-x-hidden relative p-0 custom-scrollbar">
                    {activeTool === 'home' && (
                        <div className="min-h-full p-6 animate-in fade-in duration-300">
                            <h2 className="text-2xl font-black text-gray-700 uppercase italic mb-6 tracking-widest text-center md:text-left">Strumenti Staff</h2>
                            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                                {toolsConfig.map(tool => (
                                    <button 
                                        key={tool.id}
                                        onClick={() => setActiveTool(tool.id)}
                                        className={`${tool.color} p-6 rounded-2xl shadow-xl hover:scale-[1.02] hover:shadow-2xl transition-all flex flex-col items-center justify-center gap-4 aspect-square border-t border-white/10 group relative overflow-hidden`}
                                    >
                                        <div className="absolute inset-0 bg-linear-to-br from-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity"/>
                                        <div className="text-white drop-shadow-md transform group-hover:-translate-y-1 transition-transform duration-300">
                                            {React.cloneElement(tool.icon, { size: 40 })}
                                        </div>
                                        <span className="font-black text-white uppercase tracking-wider text-xs text-center z-10">{tool.label}</span>
                                    </button>
                                ))}
                                
                                <button 
                                    onClick={onSwitchToPlayer}
                                    className="bg-gray-800 border-2 border-dashed border-gray-700 p-6 rounded-2xl hover:bg-gray-750 hover:border-gray-500 transition-all flex flex-col items-center justify-center gap-4 aspect-square group"
                                >
                                    <Users size={40} className="text-gray-600 group-hover:text-gray-300 transition-colors" />
                                    <span className="font-bold text-gray-500 group-hover:text-white uppercase tracking-wider text-xs text-center">Vai a Personaggi</span>
                                </button>

                                <Link 
                                    to="/" 
                                    className="bg-gray-800 border-2 border-dashed border-gray-700 p-6 rounded-2xl hover:bg-gray-750 hover:border-gray-500 transition-all flex flex-col items-center justify-center gap-4 aspect-square group"
                                >
                                    <BookOpen size={40} className="text-gray-600 group-hover:text-gray-300 transition-colors" />
                                    <span className="font-bold text-gray-500 group-hover:text-white uppercase tracking-wider text-xs text-center">Vai alla Wiki</span>
                                </Link>
                            </div>
                        </div>
                    )}

                    {activeTool !== 'home' && (
                        <div className="h-full w-full flex flex-col animate-in slide-in-from-right-4 duration-300">
                            {toolsConfig.find(t => t.id === activeTool)?.component}
                        </div>
                    )}
                </main>
            </div>
        </div>
    );
};

export default StaffDashboard;

==================================================
FILE: src\components\StaffHeader.jsx
==================================================
import GenericHeader from './GenericHeader';
import { LayoutDashboard, Map, Settings, MessageSquare } from 'lucide-react';

const StaffHeader = ({ onLogout, currentTab, onTabChange, rightSlot }) => {
    const staffMenu = [
        { label: 'Plot Management', icon: <Map size={18}/>, active: currentTab === 'plot', action: () => onTabChange('plot') },
        { label: 'Tools Master', icon: <Settings size={18}/>, active: currentTab === 'tools', action: () => onTabChange('tools') },
        { label: 'Messaggi Staff', icon: <MessageSquare size={18}/>, active: currentTab === 'messages', action: () => onTabChange('messages') },
    ];

    return (
        <GenericHeader 
            subtitle="Area Staff / Master" 
            menuItems={staffMenu} 
            rightSlot={rightSlot}
            onLogout={onLogout} 
        />
    );
};

==================================================
FILE: src\components\TecnicaDetailModal.jsx
==================================================
import React from 'react';
import { X } from 'lucide-react';
import PunteggioDisplay from './PunteggioDisplay.jsx';

const TecnicaDetailModal = ({ tecnica, onClose, type = 'tecnica' }) => {
  if (!tecnica) return null;

  const testoDescrizione = tecnica.testo_formattato_personaggio || tecnica.TestoFormattato || tecnica.testo;

  // LOGICA COSTI:
  // costo_pieno e costo_effettivo arrivano dal serializer backend.
  // Se mancano, usiamo il fallback standard (livello * 100).
  const costoPieno = tecnica.costo_pieno ?? (tecnica.costo_crediti || tecnica.livello * 100);
  const costoEffettivo = tecnica.costo_effettivo ?? costoPieno;
  const hasDiscount = costoEffettivo < costoPieno;

  return (
    <div 
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 p-4 backdrop-blur-sm animate-fadeIn"
      onClick={onClose}
    >
      <div 
        className="relative w-full max-w-lg p-6 bg-gray-800 rounded-xl shadow-2xl border border-gray-700 max-h-[90vh] overflow-y-auto transform transition-all animate-slideIn"
        onClick={(e) => e.stopPropagation()} 
      >
        <button 
          onClick={onClose}
          className="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors"
        >
          <X size={24} />
        </button>
        
        {/* Header con Aura */}
        <div className="flex items-start justify-between pr-10 mb-6">
            <div>
                <h2 className="text-2xl font-bold text-indigo-400 leading-tight mb-1">
                {tecnica.nome}
                </h2>
                <span className="text-xs font-bold text-gray-500 uppercase tracking-wider border border-gray-600 px-2 py-0.5 rounded">
                    {type} - Livello {tecnica.livello}
                </span>
            </div>
            {tecnica.aura_richiesta && (
                <div className="shrink-0 ml-3">
                    <PunteggioDisplay
                        punteggio={tecnica.aura_richiesta}
                        displayText="none"
                        iconType="inv_circle"
                        size="m"
                    />
                </div>
            )}
        </div>
        
        {/* Corpo del testo formattato */}
        <div className="bg-gray-900/60 p-4 rounded-lg border border-gray-700/50 mb-6 shadow-inner">
            {testoDescrizione ? (
            <div
                className="text-gray-300 prose prose-invert prose-sm max-w-none leading-relaxed" 
                dangerouslySetInnerHTML={{ __html: testoDescrizione }}
            />
            ) : (
            <p className="text-gray-500 italic text-sm">Nessuna descrizione disponibile.</p>
            )}
        </div>

        {/* Mattoni Componenti */}
        {tecnica.mattoni && tecnica.mattoni.length > 0 && (
          <div className="mb-6">
            <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 tracking-wider">Mattoni Componenti</h3>
            <div className="flex flex-wrap gap-3">
              {tecnica.mattoni.map((m, idx) => (
                <div key={idx} className="scale-90 origin-top-left">
                    <PunteggioDisplay
                        punteggio={m.mattone}
                        displayText="name"
                        iconType="inv_circle"
                        size="s"
                    />
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Footer: Info Costo e Aura Secondaria */}
        <div className="mt-2 pt-4 border-t border-gray-700 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2 text-xs text-gray-400 font-mono">
            
            {/* VISUALIZZAZIONE PREZZO BARRATO */}
            <div className="bg-gray-900 px-3 py-1.5 rounded flex items-center gap-2">
                <span className="text-gray-500">Costo:</span>
                {hasDiscount && (
                    <span className="text-red-400 line-through decoration-red-500 opacity-70 mr-1">
                        {costoPieno}
                    </span>
                )}
                <span className={`font-bold ${hasDiscount ? 'text-green-400' : 'text-yellow-500'}`}>
                    {costoEffettivo} CR
                </span>
            </div>
            
            {tecnica.aura_infusione && (
                <span className="flex items-center gap-2">
                    Aura Secondaria: 
                    <span className="text-indigo-300 font-bold">{tecnica.aura_infusione.nome}</span>
                </span>
            )}
        </div>

      </div>
    </div>
  );
};

export default TecnicaDetailModal;

==================================================
FILE: src\components\TessitureTab.jsx
==================================================
import React, { useState, Fragment } from 'react';
import { Tab } from '@headlessui/react';
import { useCharacter } from './CharacterContext';
import { Loader2, ShoppingCart, Info, CheckCircle2, PlusCircle, FileEdit } from 'lucide-react'; // Aggiunto FileEdit
import TecnicaDetailModal from './TecnicaDetailModal';
import { acquireTessitura } from '../api.js';
import GenericGroupedList from './GenericGroupedList';
import PunteggioDisplay from './PunteggioDisplay';     
import IconaPunteggio from './IconaPunteggio';
import ProposalManager from './ProposalManager'; // Import del Manager

function classNames(...classes) {
  return classes.filter(Boolean).join(' ');
}

const TessitureTab = ({ onLogout }) => {
  const {
    selectedCharacterData: char,
    selectedCharacterId, 
    acquirableTessiture, 
    refreshCharacterData,
    isLoadingAcquirable,
    isLoadingDetail
  } = useCharacter();
  
  const [modalItem, setModalItem] = useState(null);
  const [isAcquiring, setIsAcquiring] = useState(null);

  // Stato per gestire la visibilità del ProposalManager
  const [showProposals, setShowProposals] = useState(false);

  const handleOpenModal = (item) => setModalItem(item);

  const handleAcquire = async (item, e) => {
    e.stopPropagation();
    if (isAcquiring || !selectedCharacterId) return;
    
    const costoFinale = item.costo_effettivo ?? (item.costo_crediti || item.livello * 100);
    
    if (!window.confirm(`Acquisire Tessitura "${item.nome}" per ${costoFinale} Crediti?`)) return;
    
    setIsAcquiring(item.id);
    try {
      await acquireTessitura(item.id, selectedCharacterId, onLogout);
      await refreshCharacterData(); 
    } catch (error) {
      alert(`Errore: ${error.message}`);
    } finally {
      setIsAcquiring(null);
    }
  };

  const sortItems = (items) => [...items].sort((a, b) => a.livello - b.livello);
  
  const possessed = sortItems(char?.tessiture_possedute || []);
  const acquirable = sortItems(acquirableTessiture || []);

  if (isLoadingAcquirable || isLoadingDetail || !char) {
    return (
      <div className="flex justify-center items-center h-64">
        <Loader2 className="animate-spin text-indigo-500" size={48} />
      </div>
    );
  }

  // --- RENDERERS ---

  const renderGroupHeader = (group) => {
    const fakePunteggio = {
        nome: group.name,
        colore: group.color,
        icona_url: group.icon 
    };

    return (
        <PunteggioDisplay 
            punteggio={fakePunteggio}
            value={group.items.length}
            displayText="name"
            iconType="inv_circle"
            size="s"
            className="rounded-b-none"
        />
    );
  };

  // 1. RENDER ITEM POSSEDUTO (Stile Semplice come Abilità)
  const renderPossessedItem = (item) => {
    const iconUrl = item.aura_richiesta?.icona_url;
    const iconColor = item.aura_richiesta?.colore;

    return (
      <li className="flex justify-between items-center py-2 px-2 hover:bg-gray-700/50 transition-colors rounded-sm border-b border-gray-700/50 last:border-0">
        <div className="flex items-center gap-3 cursor-pointer grow" onClick={() => handleOpenModal(item)}>
            <div className="shrink-0 mt-0.5 relative">
                <IconaPunteggio url={iconUrl} color={iconColor} mode="cerchio_inv" size="xs" />
                <span className="absolute -top-2 -right-2 bg-gray-900 text-gray-200 text-[9px] font-bold px-1 py-0.5 rounded-full border border-gray-600 leading-none">
                    L{item.livello}
                </span>
            </div>
            <span className="font-bold text-gray-200 text-base">{item.nome}</span>
        </div>
        <button
            onClick={(e) => {e.stopPropagation(); handleOpenModal(item)}}
            className="p-2 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full transition-colors ml-2"
        >
            <Info size={18} />
        </button>
      </li>
    );
  };

  // 2. RENDER ITEM ACQUISTABILE (Stile Ricco e Responsive come Abilità)
  const renderAcquirableItem = (item) => {
    const iconUrl = item.aura_richiesta?.icona_url;
    const iconColor = item.aura_richiesta?.colore;
    
    const costoPieno = item.costo_pieno ?? (item.costo_crediti || item.livello * 100);
    const costoEffettivo = item.costo_effettivo ?? costoPieno;
    const hasDiscount = costoEffettivo < costoPieno;
    const canAfford = char.crediti >= costoEffettivo;

    return (
      <li className="flex flex-col sm:flex-row sm:items-center justify-between py-3 px-2 hover:bg-gray-700/50 transition-colors rounded-sm border-b border-gray-700/50 last:border-0 gap-2">
        
        {/* Parte Sinistra: Icona + Nome + Prezzo Mobile */}
        <div className="flex items-center gap-3 cursor-pointer grow" onClick={() => handleOpenModal(item)}>
            <div className="shrink-0 mt-0.5 relative">
                <IconaPunteggio url={iconUrl} color={iconColor} mode="cerchio_inv" size="xs" />
                <span className="absolute -top-2 -right-2 bg-gray-900 text-gray-200 text-[9px] font-bold px-1 py-0.5 rounded-full border border-gray-600 leading-none">
                    L{item.livello}
                </span>
            </div>
            
            <div className="flex flex-col">
                <span className="font-bold text-gray-200 text-base">{item.nome}</span>
                {/* Prezzo Mobile */}
                <div className="text-xs text-gray-400 flex gap-2 mt-0.5 sm:hidden">
                    {hasDiscount ? (
                        <div className="flex items-center gap-1">
                             <span className="text-red-500 line-through decoration-red-500 opacity-70">{costoPieno}</span>
                             <span className={canAfford ? "text-green-400 font-bold" : "text-red-400 font-bold"}>{costoEffettivo} CR</span>
                        </div>
                    ) : (
                        <span className={canAfford ? "text-yellow-300" : "text-red-400"}>{costoEffettivo} CR</span>
                    )}
                </div>
            </div>
        </div>

        {/* Parte Destra: Prezzo Desktop + Bottoni */}
        <div className="flex items-center justify-end gap-3 w-full sm:w-auto">
            {/* Prezzo Desktop */}
            <div className="hidden sm:flex flex-col items-end text-xs font-mono mr-1">
                {hasDiscount ? (
                    <div className="flex flex-col items-end leading-none mt-1">
                        <span className="text-[10px] text-red-500 line-through decoration-red-500 opacity-80">
                            {costoPieno}
                        </span>
                        <span className="text-green-400 font-bold">
                            {costoEffettivo} CR
                        </span>
                    </div>
                ) : (
                    <span className={canAfford ? "text-yellow-300" : "text-red-400 font-bold"}>
                        {costoEffettivo} CR
                    </span>
                )}
            </div>

            <button
                onClick={(e) => handleAcquire(item, e)}
                disabled={!canAfford || isAcquiring === item.id}
                className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-bold transition-all shadow-md ml-auto sm:ml-0 ${
                    canAfford 
                    ? 'bg-indigo-600 hover:bg-indigo-500 text-white hover:shadow-indigo-500/20' 
                    : 'bg-gray-700 text-gray-500 cursor-not-allowed opacity-50'
                }`}
            >
                {isAcquiring === item.id ? (
                    <Loader2 className="animate-spin" size={16} />
                ) : (
                    <>
                        <ShoppingCart size={16} />
                        <span className="hidden sm:inline">Acquista</span>
                    </>
                )}
            </button>
            
            <button
                onClick={(e) => {e.stopPropagation(); handleOpenModal(item)}}
                className="p-2 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full transition-colors"
            >
                <Info size={18} />
            </button>
        </div>
      </li>
    );
  };

  const PossessedList = (
      <GenericGroupedList 
        items={possessed} 
        groupByKey="aura_richiesta"
        orderKey="ordine"
        titleKey="nome"
        colorKey="colore"
        iconKey="icona_url"
        renderItem={renderPossessedItem} // Usa il renderer semplice
        renderHeader={renderGroupHeader}
        itemSortFn={(a, b) => a.livello - b.livello} 
      />
  );

  const AcquirableList = (
      <GenericGroupedList 
        items={acquirable} 
        groupByKey="aura_richiesta"
        orderKey="ordine"
        titleKey="nome"
        colorKey="colore"
        iconKey="icona_url"
        renderItem={renderAcquirableItem} // Usa il renderer complesso
        renderHeader={renderGroupHeader}
        itemSortFn={(a, b) => a.livello - b.livello}
      />
  );

  return (
    <>
      <div className="w-full p-4 max-w-6xl mx-auto pb-24">
        {/* Riepilogo Valute */}
        <div className="mb-4 flex justify-between items-center bg-gray-800 p-3 rounded-lg border border-gray-700 shadow-sm max-w-3xl mx-auto">
            <div className="text-sm text-gray-400">Disponibilità:</div>
            <div className="flex gap-4">
                <div className="flex items-center gap-1 text-yellow-400 font-bold">
                    <span>{char.crediti}</span> <span className="text-xs font-normal text-gray-400">CR</span>
                </div>
            </div>
        </div>

        {/* Pulsante Proposte - NUOVA AGGIUNTA */}
        <div className="flex justify-end mb-6 max-w-3xl mx-auto">
            <button 
                onClick={() => setShowProposals(true)}
                className="flex items-center gap-2 bg-gray-800 hover:bg-gray-700 text-indigo-300 hover:text-white px-4 py-2 rounded-lg border border-gray-600 transition-all shadow-sm text-sm font-medium"
            >
                <FileEdit size={16} />
                Gestisci Proposte Tessitura
            </button>
        </div>

        {/* --- MOBILE --- */}
        <div className="md:hidden">
            <Tab.Group>
              <Tab.List className="flex space-x-1 rounded-xl bg-gray-800/80 p-1 mb-6 shadow-inner">
                {['Possedute', 'Nuove'].map((category, idx) => (
                  <Tab as={Fragment} key={category}>
                    {({ selected }) => (
                      <button className={classNames(
                          'w-full rounded-lg py-2.5 text-sm font-medium leading-5 transition-all',
                          selected ? 'bg-indigo-600 text-white shadow' : 'text-gray-400 hover:bg-gray-700/50 hover:text-white'
                      )}>
                        {category} <span className="ml-1 opacity-60 text-xs">
                            ({idx === 0 ? possessed.length : acquirable.length})
                        </span>
                      </button>
                    )}
                  </Tab>
                ))}
              </Tab.List>
              <Tab.Panels>
                <Tab.Panel className="focus:outline-none animate-fadeIn">{PossessedList}</Tab.Panel>
                <Tab.Panel className="focus:outline-none animate-fadeIn">{AcquirableList}</Tab.Panel>
              </Tab.Panels>
            </Tab.Group>
        </div>

        {/* --- DESKTOP --- */}
        <div className="hidden md:grid grid-cols-2 gap-6">
            <div>
                <div className="flex items-center gap-2 mb-4 pb-2 border-b border-gray-700">
                    <CheckCircle2 className="w-6 h-6 text-green-500" />
                    <h2 className="text-xl font-bold text-white">
                        Tessiture Possedute 
                        <span className="ml-2 text-sm font-normal text-gray-400">({possessed.length})</span>
                    </h2>
                </div>
                {PossessedList}
            </div>
            <div>
                <div className="flex items-center gap-2 mb-4 pb-2 border-b border-gray-700">
                    <PlusCircle className="w-6 h-6 text-indigo-500" />
                    <h2 className="text-xl font-bold text-white">
                        Nuove Tessiture
                        <span className="ml-2 text-sm font-normal text-gray-400">({acquirable.length})</span>
                    </h2>
                </div>
                {AcquirableList}
            </div>
        </div>
      </div>
      
      {modalItem && (
        <TecnicaDetailModal tecnica={modalItem} type="Tessitura" onClose={() => setModalItem(null)} />
      )}

      {/* Modale Proposal Manager - NUOVA AGGIUNTA */}
      {showProposals && (
        <ProposalManager type="Tessitura" onClose={() => setShowProposals(false)} />
      )}
    </>
  );
};

export default TessitureTab;

==================================================
FILE: src\components\TimerOverlay.jsx
==================================================
import React, { useState, useEffect, useCallback } from 'react';

const SingleTimer = ({ timer, onExpire }) => {
  const [timeLeft, setTimeLeft] = useState(0);

  useEffect(() => {
    const tick = () => {
      const now = Date.now();
      const diff = timer.endTime - now;
      
      if (diff <= 0) {
        onExpire(timer);
      } else {
        setTimeLeft(Math.floor(diff / 1000));
      }
    };

    const interval = setInterval(tick, 1000);
    tick(); // Esecuzione immediata al montaggio
    return () => clearInterval(interval);
  }, [timer.endTime, timer, onExpire]);

  const format = (s) => {
    const mins = Math.floor(s / 60);
    const secs = s % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="bg-gray-800/95 text-white p-3 rounded-xl mb-2 border-l-4 border-amber-500 shadow-2xl flex justify-between items-center min-w-40 backdrop-blur-sm ring-1 ring-white/10 animate-slide-in-right">
      <div className="flex flex-col">
        <span className="text-[10px] text-gray-400 uppercase font-black tracking-tighter leading-none mb-1">Timer Attivo</span>
        <span className="text-xs font-bold uppercase truncate max-w-[100px]">{timer.nome}</span>
      </div>
      <div className="flex flex-col items-end ml-4">
        <span className="font-mono text-lg font-bold text-amber-400 drop-shadow-[0_0_8px_rgba(251,191,36,0.4)]">
          {format(timeLeft)}
        </span>
      </div>
    </div>
  );
};

export const TimerOverlay = ({ activeTimers, onRemove }) => {
  
  // Funzione ricorsiva per riprodurre il suono N volte
  const playSoundSequence = useCallback((remaining) => {
    if (remaining <= 0) return;
    
    const audio = new Audio('/sounds/alert.mp3');
    
    // Quando il suono finisce, chiama se stessa riducendo il contatore
    audio.onended = () => playSoundSequence(remaining - 1);
    
    audio.play().catch(err => {
      // I browser bloccano l'audio se l'utente non ha ancora interagito con la pagina
      console.warn("Riproduzione audio bloccata dal browser. Richiesta interazione utente.", err);
    });
  }, []);

  const handleExpire = (timer) => {
    // 1. Alert Sonoro (Ripetuto 3 volte)
    if (timer.alert_suono) {
      playSoundSequence(3);
    }

    // 2. Notifica di Sistema (Browser Push)
    // Utilizza l'API nativa del browser se i permessi sono concessi
    if (timer.notifica_push && "Notification" in window && Notification.permission === "granted") {
        try {
            new Notification(`Timer Scaduto: ${timer.nome}`, {
                body: `Il countdown per la tipologia "${timer.nome}" è terminato.`,
                icon: '/pwa-192x192.png'
            });
        } catch (e) { console.error("Errore invio notifica sistema:", e); }
    }

    // 3. Messaggio In-App (Alert popup)
    if (timer.messaggio_in_app) {
      // Usiamo un piccolo delay per non bloccare l'inizio della sequenza audio
      setTimeout(() => {
        alert(`ATTENZIONE: Il timer "${timer.nome}" è scaduto!`);
      }, 200);
    }

    // Rimuove il timer dallo stato globale in CharacterContext
    onRemove(timer.nome);
  };

  if (Object.keys(activeTimers).length === 0) return null;

  return (
    <div className="fixed top-20 right-4 z-9999 pointer-events-none flex flex-col items-end max-w-[250px]">
      <div className="pointer-events-auto">
        {Object.values(activeTimers).map(t => (
          <SingleTimer 
            key={t.nome} 
            timer={t} 
            onExpire={handleExpire} 
          />
        ))}
      </div>
    </div>
  );
};

export default TimerOverlay;

==================================================
FILE: src\components\ToolsTab.jsx
==================================================
import React, { useState } from 'react';
import { useCharacter } from './CharacterContext';
import InfusioneManager from './editors/InfusioneManager';
import TessituraManager from './editors/TessituraManager';
import CerimonialeManager from './editors/CerimonialeManager';
import OggettoManager from './editors/OggettoManager';
import OggettoBaseManager from './editors/OggettoBaseManager';

const ToolsTab = ({ onLogout, initialSection }) => {
  const [activeTool, setActiveTool] = useState(initialSection || 'generic'); 
  const { setStaffWorkMode } = useCharacter();

  useEffect(() => {
        if (initialSection) setActiveTool(initialSection);
    }, [initialSection]);

  const handleBack = () => setActiveTool('menu');

  // Switch per i vari Manager (List + Editor)
  if (activeTool === 'infusione') return <InfusioneManager onBack={handleBack} onLogout={onLogout} />;
  if (activeTool === 'tessitura') return <TessituraManager onBack={handleBack} onLogout={onLogout} />;
  if (activeTool === 'cerimoniale') return <CerimonialeManager onBack={handleBack} onLogout={onLogout} />;
  if (activeTool === 'oggetti') return <OggettoManager onBack={handleBack} onLogout={onLogout} />;
  if (activeTool === 'oggetti_base') return <OggettoBaseManager onBack={handleBack} onLogout={onLogout} />;

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 animate-in fade-in duration-500">
      <div className="flex justify-between items-center mb-8 border-b border-gray-800 pb-4">
        <h1 className="text-3xl font-bold text-amber-500 uppercase tracking-wider">🛠️ Strumenti Master</h1>
        <button 
          onClick={() => setStaffWorkMode(null)}
          className="bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded border border-gray-700 transition-colors text-sm font-bold uppercase"
        >
          Menu Principale
        </button>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 max-w-6xl mx-auto">
        <ToolCard 
          title="Gestione Infusioni" 
          desc="Crea e modifica Mod, Materie e Innesti" 
          icon="🧪" 
          color="indigo"
          onClick={() => setActiveTool('infusione')} 
        />
        <ToolCard 
          title="Gestione Tessiture" 
          desc="Gestisci le formule e i parametri dell'Aura" 
          icon="✨" 
          color="cyan"
          onClick={() => setActiveTool('tessitura')} 
        />
        <ToolCard 
          title="Gestione Cerimoniali" 
          desc="Configura riti ed effetti tecnici complessi" 
          icon="🕯️" 
          color="amber"
          onClick={() => setActiveTool('cerimoniale')} 
        />
        <ToolCard 
          title="Oggetti (Istanze)" 
          desc="Gestisci i singoli oggetti esistenti nel mondo" 
          icon="🎒" color="emerald"
          onClick={() => setActiveTool('oggetti')} 
        />
        <ToolCard 
          title="Oggetti Base" 
          desc="Configura il listino e i template degli oggetti" 
          icon="📋" color="blue"
          onClick={() => setActiveTool('oggetti_base')} 
        />
      </div>
    </div>
  );
};

const ToolCard = ({ title, desc, icon, onClick, color }) => (
  <button 
    onClick={onClick}
    className={`bg-gray-800/40 border border-gray-700 p-6 rounded-xl hover:border-${color}-500 hover:bg-gray-800/60 transition-all text-left group shadow-lg`}
  >
    <div className="text-4xl mb-4 group-hover:scale-110 transition-transform">{icon}</div>
    <div className={`text-xl font-bold group-hover:text-${color}-400 transition-colors`}>{title}</div>
    <div className="text-sm text-gray-400 mt-2">{desc}</div>
  </button>
);

export default ToolsTab;

==================================================
FILE: src\components\TransazioniViewer.jsx
==================================================
import React, { useState } from 'react';
import { useTransazioni } from '../hooks/useGameData';
import { useCharacter } from './CharacterContext'; // Importa il context

const TransazioniViewer = () => {
  const [page, setPage] = useState(1);
  const [tipo, setTipo] = useState('entrata'); 
  
  // Prendi l'ID del personaggio selezionato
  const { selectedCharacterId } = useCharacter();
  
  // Passalo all'hook
  const { data, isLoading, isPlaceholderData } = useTransazioni(page, tipo, selectedCharacterId);

  if (!selectedCharacterId) {
      return <div className="text-center p-4 text-gray-500">Seleziona un personaggio per vedere le transazioni.</div>;
  }

  return (
    <div className="transazioni-container">
      <div className="flex space-x-4 mb-4 border-b border-gray-700 pb-2">
        <button 
            onClick={() => { setTipo('entrata'); setPage(1); }}
            className={`px-3 py-1 rounded transition-colors ${tipo === 'entrata' ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
        >
            In Entrata (Richieste a te)
        </button>
        <button 
            onClick={() => { setTipo('uscita'); setPage(1); }}
            className={`px-3 py-1 rounded transition-colors ${tipo === 'uscita' ? 'bg-red-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
        >
            In Uscita (Tue richieste)
        </button>
      </div>

      {isLoading ? (
        <div className="text-center p-4 text-gray-400 animate-pulse">Caricamento transazioni...</div>
      ) : (
        <div className="space-y-2">
            {data?.results?.length === 0 && (
                <div className="text-center p-8 border border-dashed border-gray-700 rounded bg-gray-800/50">
                    <p className="text-gray-500 italic">Nessuna transazione trovata in {tipo}.</p>
                </div>
            )}
            
            {data?.results?.map((t) => (
            <div key={t.id} className="p-3 bg-gray-800 rounded border border-gray-700 flex justify-between items-center hover:border-gray-500 transition-colors">
                <div>
                    <div className="font-bold text-indigo-300">{t.oggetto}</div>
                    <div className="text-xs text-gray-400 mt-1">
                        {tipo === 'entrata' ? (
                            <>Da: <span className="text-white">{t.richiedente}</span></>
                        ) : (
                            <>A: <span className="text-white">{t.mittente}</span></>
                        )}
                        <span className="mx-2 text-gray-600">|</span>
                        {new Date(t.data_richiesta).toLocaleDateString()}
                    </div>
                </div>
                <div className={`text-xs px-2 py-1 rounded font-bold ${
                    t.stato === 'IN_ATTESA' ? 'bg-yellow-900 text-yellow-200' :
                    t.stato === 'ACCETTATA' ? 'bg-green-900 text-green-200' :
                    'bg-red-900 text-red-200'
                }`}>
                    {t.stato.replace('_', ' ')}
                </div>
            </div>
            ))}
        </div>
      )}

      {/* Paginazione */}
      <div className="flex justify-between mt-4 pt-2 border-t border-gray-800">
        <button
          onClick={() => setPage(old => Math.max(old - 1, 1))}
          disabled={page === 1}
          className="px-3 py-1 bg-gray-700 rounded disabled:opacity-30 hover:bg-gray-600 text-sm"
        >
          &lt; Indietro
        </button>
        <span className="text-xs py-1.5 text-gray-500">Pagina {page}</span>
        <button
          onClick={() => {
            if (!isPlaceholderData && data?.next) setPage(old => old + 1);
          }}
          disabled={isPlaceholderData || !data?.next}
          className="px-3 py-1 bg-gray-700 rounded disabled:opacity-30 hover:bg-gray-600 text-sm"
        >
          Avanti &gt;
        </button>
      </div>
    </div>
  );
};

export default TransazioniViewer;

==================================================
FILE: src\components\WikiRenderer.jsx
==================================================
import React from 'react';
import WidgetTier from './wg/WidgetTier';
import WidgetAura from './wg/WidgetAura';
import WidgetTabellaAbilita from './wg/WidgetTabellaAbilita';

export default function WikiRenderer({ content }) {
  if (!content) return null;

  // --- FUNZIONE DI PULIZIA PROFONDA ---
  const cleanContent = (html) => {
    let currentHtml = html;
    let hasChanged = true;

    // Regex spiegata:
    // <([a-z][a-z0-9]*)   -> Cattura il tag di apertura (es: p, div, span, strong) nel gruppo 1
    // [^>]*>              -> Ignora attributi (class, style, etc.)
    // [\s\u00A0]* -> Ignora spazi bianchi e Non-Breaking Spaces reali
    // (?:&nbsp;|<br\/?>)* -> Ignora entità &nbsp; e tag <br>
    // ({{WIDGET_[^}]+}})  -> CATTURA IL WIDGET nel gruppo 2
    // ...ripetizione ignore... -> Ignora spazi/br dopo il widget
    // <\/\1>              -> Cerca la chiusura dello STESSO tag catturato all'inizio
    
    const wrapperRegex = /<([a-z][a-z0-9]*)[^>]*>(?:[\s\u00A0]|&nbsp;|<br\/?>)*({{WIDGET_[A-Z_]+:\d+}})(?:[\s\u00A0]|&nbsp;|<br\/?>)*<\/\1>/gi;

    // Continuiamo a eseguire la replace finché troviamo match (per gestire nesting tipo <p><span>{{WIDGET}}</span></p>)
    while (hasChanged) {
      const newHtml = currentHtml.replace(wrapperRegex, '$2');
      if (newHtml !== currentHtml) {
        currentHtml = newHtml;
      } else {
        hasChanged = false;
      }
    }
    
    return currentHtml;
  };

  // 1. Eseguiamo la pulizia
  const processedContent = cleanContent(content);

  // 2. Parsing per dividere HTML e Widget
  const regex = /{{WIDGET_([A-Z_]+):(\d+)}}/g;
  const parts = [];
  let lastIndex = 0;
  let match;

  while ((match = regex.exec(processedContent)) !== null) {
    // Aggiungi parte HTML precedente
    if (match.index > lastIndex) {
      parts.push({ 
        type: 'html', 
        content: processedContent.substring(lastIndex, match.index) 
      });
    }

    // Aggiungi Widget
    parts.push({
      type: 'widget',
      widgetType: match[1], 
      id: match[2]
    });

    lastIndex = regex.lastIndex;
  }

  // Aggiungi eventuale HTML rimanente
  if (lastIndex < processedContent.length) {
    parts.push({ type: 'html', content: processedContent.substring(lastIndex) });
  }

  // console.log("--- DEBUG WIKI RENDERER ---");
  // parts.forEach((part, i) => {
  //     console.log(`Part ${i} [${part.type}]:`, part.content || part.widgetType);
  //     if (part.type === 'html') {
  //         // Controlla se ci sono tag aperti non chiusi
  //         console.log("HTML Chunk:", part.content); 
  //     }
  // });

  return (
    <div className="wiki-content prose prose-red max-w-none text-gray-800">
      {parts.map((part, index) => {
        if (part.type === 'widget') {
            switch (part.widgetType) {
                case 'TIER':
                    return <WidgetTier key={index} id={part.id} />;
                case 'AURA':
                    return <WidgetAura key={index} id={part.id} />;
                case 'TABELLA':
                    return <WidgetTabellaAbilita key={index} id={part.id} />;
                default:
                    return (
                        <div key={index} className="text-red-500 text-xs p-2 border border-red-300 bg-red-50 font-mono">
                            [WIDGET IGNOTO: {part.widgetType}]
                        </div>
                    );
            }
        }
        
        // Renderizza HTML.
        // Importante: se cleanContent ha funzionato, qui dentro NON ci sono pezzi di tag orfani.
        // Se part.content è solo uno spazio o a capo, React lo gestisce bene.
        return <div key={index} dangerouslySetInnerHTML={{ __html: part.content }} />;
      })}
    </div>
  );
}

==================================================
FILE: src\components\editors\AbilitaEditor.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffCreateAbilita, staffUpdateAbilita, getPunteggiList, getAbilitaOptions, getTiersList } from '../../api';
import RichTextEditor from '../RichTextEditor';
import StatModInline from './inlines/StatModInline';
import GenericRelationInline from './inlines/GenericRelationInline';

const AbilitaEditor = ({ onBack, onLogout, initialData = null }) => {
    const [punteggi, setPunteggi] = useState([]); 
    const [abilitaList, setAbilitaList] = useState([]); 
    const [tiersList, setTiersList] = useState([]); 

    const statsOptions = punteggi.filter(p => p.tipo === 'ST');
    const auraOptions = punteggi.filter(p => p.tipo === 'AU');
    const elementOptions = punteggi.filter(p => p.tipo === 'EL' || p.tipo === 'MA'); // 'EL' o 'MA' a seconda di come codifichi gli elementi/materie nel DB

    const [formData, setFormData] = useState(initialData || {
        nome: '',
        descrizione: '',
        caratteristica: null,
        costo_pc: 0,
        costo_crediti: 0,
        is_tratto_aura: false,
        aura_riferimento: null,
        livello_riferimento: 0,
        tiers: [], 
        requisiti: [], 
        punteggi_assegnati: [],
        prerequisiti: [], 
        statistiche: [] 
    });

    useEffect(() => {
        const loadResources = async () => {
            try {
                const [pts, abs, trs] = await Promise.all([
                    getPunteggiList(onLogout),
                    getAbilitaOptions(onLogout),
                    getTiersList(onLogout)
                ]);
                setPunteggi(pts || []);
                setAbilitaList(abs || []);
                setTiersList(trs || []);
            } catch (err) {
                console.error("Errore caricamento risorse editor", err);
            }
        };
        loadResources();
    }, [onLogout]);

    const handleSave = async () => {
        try {
            const payload = {
                ...formData,
                caratteristica: formData.caratteristica ? parseInt(formData.caratteristica) : null,
                aura_riferimento: formData.aura_riferimento ? parseInt(formData.aura_riferimento) : null,
                tiers: formData.tiers.map(t => ({...t, tabella: parseInt(t.tabella)})),
                requisiti: formData.requisiti.map(r => ({...r, requisito: parseInt(r.requisito)})),
                punteggi_assegnati: formData.punteggi_assegnati.map(p => ({...p, punteggio: parseInt(p.punteggio)})),
                prerequisiti: formData.prerequisiti.map(p => ({...p, prerequisito: parseInt(p.prerequisito)})),
                // Statistiche è già gestito come array di oggetti da StatModInline
            };

            if (formData.id) {
                await staffUpdateAbilita(formData.id, payload, onLogout);
            } else {
                await staffCreateAbilita(payload, onLogout);
            }
            onBack(); 
        } catch (error) {
            alert("Errore durante il salvataggio: " + error.message);
        }
    };

    // Helper per StatModInline
    const handleUpdateStat = (index, field, value) => {
        const newStats = [...formData.statistiche];
        newStats[index] = { ...newStats[index], [field]: value };
        setFormData({ ...formData, statistiche: newStats });
    };

    const handleRemoveStat = (index) => {
        const newStats = formData.statistiche.filter((_, i) => i !== index);
        setFormData({ ...formData, statistiche: newStats });
    };

    const handleAddStat = () => {
        setFormData({
            ...formData,
            statistiche: [
                ...formData.statistiche,
                { statistica: null, valore: 1, tipo_modificatore: 'ADD' } // Default
            ]
        });
    };

    const caratteristiche = punteggi.filter(p => p.tipo === 'CA' || p.tipo === 'CO');
    const aure = punteggi.filter(p => p.tipo === 'AU');
    const allStats = punteggi.filter(p => p.tipo === 'ST');

    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-2xl text-white max-w-7xl mx-auto overflow-y-auto max-h-[90vh]">
            {/* HEADER EDITOR */}
            <div className="flex justify-between items-center border-b border-gray-700 pb-4 mb-6 sticky top-0 bg-gray-800 z-10">
                <h2 className="text-xl font-bold text-emerald-400 uppercase tracking-tighter">
                    {formData.id ? `Modifica: ${formData.nome}` : 'Nuova Abilità'}
                </h2>
                <div className="flex gap-3">
                    <button onClick={handleSave} className="bg-emerald-600 hover:bg-emerald-500 px-6 py-2 rounded-lg font-black text-sm shadow-lg">SALVA</button>
                    <button onClick={onBack} className="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg font-bold text-sm">ANNULLA</button>
                </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                
                {/* COLONNA 1: DATI BASE */}
                <div className="space-y-4 lg:col-span-1">
                    <div>
                        <label className="text-xs text-gray-500 uppercase font-bold">Nome</label>
                        <input 
                            type="text" 
                            className="w-full bg-gray-950 border border-gray-700 rounded p-2 text-white"
                            value={formData.nome}
                            onChange={e => setFormData({...formData, nome: e.target.value})}
                        />
                    </div>
                    
                    <div className="grid grid-cols-2 gap-4">
                        <div>
                            <label className="text-xs text-gray-500 uppercase font-bold">Carat. Base</label>
                            <select 
                                className="w-full bg-gray-950 border border-gray-700 rounded p-2 text-white text-sm"
                                value={formData.caratteristica || ""}
                                onChange={e => setFormData({...formData, caratteristica: e.target.value})}
                            >
                                <option value="">- Nessuna -</option>
                                {caratteristiche.map(c => <option key={c.id} value={c.id}>{c.nome}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="text-xs text-gray-500 uppercase font-bold">Costo PC</label>
                            <input 
                                type="number" 
                                className="w-full bg-gray-950 border border-gray-700 rounded p-2 text-white text-right"
                                value={formData.costo_pc}
                                onChange={e => setFormData({...formData, costo_pc: parseInt(e.target.value)})}
                            />
                        </div>
                    </div>

                    <div>
                        <label className="text-xs text-gray-500 uppercase font-bold">Costo Crediti</label>
                        <input 
                            type="number" 
                            className="w-full bg-gray-950 border border-gray-700 rounded p-2 text-white text-right"
                            value={formData.costo_crediti}
                            onChange={e => setFormData({...formData, costo_crediti: parseInt(e.target.value)})}
                        />
                    </div>

                    {/* BOX AURA */}
                    <div className="bg-gray-900/30 p-3 rounded border border-purple-900/30">
                        <label className="flex items-center gap-2 mb-2 cursor-pointer">
                            <input 
                                type="checkbox" 
                                checked={formData.is_tratto_aura} 
                                onChange={e => setFormData({...formData, is_tratto_aura: e.target.checked})}
                            />
                            <span className="text-xs font-bold text-purple-400 uppercase">È un Tratto d'Aura</span>
                        </label>
                        
                        {formData.is_tratto_aura && (
                            <div className="space-y-2 pl-4 border-l-2 border-purple-500/30">
                                <div>
                                    <label className="text-xs text-gray-500 uppercase font-bold">Aura Rif.</label>
                                    <select 
                                        className="w-full bg-gray-950 border border-gray-700 rounded p-1 text-white text-sm"
                                        value={formData.aura_riferimento || ""}
                                        onChange={e => setFormData({...formData, aura_riferimento: e.target.value})}
                                    >
                                        <option value="">- Seleziona -</option>
                                        {aure.map(a => <option key={a.id} value={a.id}>{a.nome}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-gray-500 uppercase font-bold">Livello Sblocco</label>
                                    <input 
                                        type="number" 
                                        className="w-full bg-gray-950 border border-gray-700 rounded p-1 text-white"
                                        value={formData.livello_riferimento}
                                        onChange={e => setFormData({...formData, livello_riferimento: parseInt(e.target.value)})}
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                </div>

                {/* COLONNA 2: DESCRIZIONE */}
                <div className="lg:col-span-2 h-full flex flex-col">
                    <label className="text-xs text-gray-500 uppercase font-bold mb-1">Descrizione Effetto</label>
                    <div className="flex-1 bg-gray-950 border border-gray-700 rounded min-h-[200px]">
                        <RichTextEditor 
                            value={formData.descrizione || ''} 
                            onChange={(val) => setFormData({...formData, descrizione: val})} 
                        />
                    </div>
                </div>
            </div>

            {/* SEZIONE INLINES */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-8">
                
                {/* 1. Tiers */}
                <GenericRelationInline 
                    title="Tabelle (Ordine)"
                    items={formData.tiers}
                    options={tiersList}
                    targetKey="tabella"
                    valueKey="ordine"
                    onChange={list => setFormData({...formData, tiers: list})}
                    labelFinder={t => t.nome}
                />

                {/* 2. Requisiti */}
                <GenericRelationInline 
                    title="Punteggi Richiesti"
                    items={formData.requisiti}
                    options={punteggi}
                    targetKey="requisito"
                    valueKey="valore"
                    onChange={list => setFormData({...formData, requisiti: list})}
                />

                {/* 3. Prerequisiti */}
                <GenericRelationInline 
                    title="Abilità di prerequisito"
                    items={formData.prerequisiti}
                    options={abilitaList.filter(a => a.id !== formData.id)}
                    targetKey="prerequisito"
                    valueKey={null}
                    onChange={list => setFormData({...formData, prerequisiti: list})}
                />

                {/* 4. Punteggi Assegnati */}
                <GenericRelationInline 
                    title="Assegna Punteggi (Bonus Generali)"
                    items={formData.punteggi_assegnati}
                    options={punteggi.filter(p => p.tipo !== 'ST')}
                    targetKey="punteggio"
                    valueKey="valore"
                    onChange={list => setFormData({...formData, punteggi_assegnati: list})}
                />

                {/* 5. Statistiche (Inline Complessa) */}
                <div className="md:col-span-2 lg:col-span-3 bg-gray-900/50 p-4 rounded-lg border border-gray-700">
                    {/* Nota: StatModInline include già il suo header e il pulsante 'Aggiungi', 
                         quindi non serve ricrearli esternamente come facevo prima. 
                         Usiamolo esattamente come in OggettoEditor. */}
                    <StatModInline 
                        items={formData.statistiche}
                        
                        // PROPS FONDAMENTALI (senza queste crasha il map)
                        options={statsOptions}        
                        auraOptions={auraOptions}
                        elementOptions={elementOptions}
                        
                        // Gestione Aggiunta
                        onAdd={() => setFormData({
                            ...formData, 
                            statistiche: [
                                ...formData.statistiche, 
                                // Struttura oggetto vuoto allineata a OggettoEditor
                                { statistica: null, valore: 0, tipo_modificatore: 'ADD' }
                            ]
                        })}
                        
                        // Gestione Modifica
                        onChange={(index, field, value) => {
                            const newStats = [...formData.statistiche];
                            newStats[index] = { ...newStats[index], [field]: value };
                            setFormData({ ...formData, statistiche: newStats });
                        }}
                        
                        // Gestione Rimozione
                        onRemove={(index) => {
                            const newStats = formData.statistiche.filter((_, i) => i !== index);
                            setFormData({ ...formData, statistiche: newStats });
                        }}
                    />
                </div>

            </div>
        </div>
    );
};

export default AbilitaEditor;

==================================================
FILE: src\components\editors\AbilitaList.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffGetAbilitaList, staffDeleteAbilita } from '../../api';
import MasterGenericList from './MasterGenericList';

const AbilitaList = ({ onAdd, onEdit, onLogout }) => {
    const [items, setItems] = useState([]);
    const [loading, setLoading] = useState(true);

    // 1. Caricamento Dati
    const loadData = async () => {
        setLoading(true);
        try {
            const data = await staffGetAbilitaList(onLogout);
            setItems(data || []);
        } catch (error) {
            console.error("Errore caricamento abilità:", error);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadData();
    }, [onLogout]);

    // 2. Gestione Cancellazione
    const handleDelete = async (id) => {
        if (!window.confirm("Sei sicuro di voler eliminare questa abilità?")) return;
        try {
            await staffDeleteAbilita(id, onLogout);
            // Aggiorna la lista locale rimuovendo l'elemento
            setItems(prev => prev.filter(item => item.id !== id));
        } catch (error) {
            alert("Errore durante l'eliminazione: " + error.message);
        }
    };
    
    const columns = [
        { key: 'nome', label: 'Nome', width: '30%', render: (row) => <span className="font-bold text-white">{row.nome}</span> },
        { key: 'costo_pc', label: 'Costo PC', width: '15%', align: 'center', render: (row) => row.costo_pc },
        { key: 'costo_crediti', label: 'Crediti', width: '15%', align: 'center', render: (row) => row.costo_crediti },
        { 
            key: 'tipo', 
            label: 'Tipo', 
            width: '20%',
            align: 'center',
            render: (row) => row.is_tratto_aura ? 
                <span className="text-purple-400 text-[10px] font-bold px-2 py-0.5 bg-purple-900/50 rounded border border-purple-500/30 uppercase tracking-wide">
                    AURA {row.aura_riferimento?.nome} (Lv.{row.livello_riferimento})
                </span> : 
                <span className="text-gray-500 text-xs">-</span> 
        }
    ];

    // Configurazione filtri (Opzionale, ma utile)
    const filterConfig = [
        { 
            key: 'is_tratto_aura', 
            label: 'Tipo', 
            options: [{ id: true, label: 'Tratti Aura' }, { id: false, label: 'Standard' }] 
        }
    ];

    return (
        <MasterGenericList
            title="Database Abilità"
            items={items}           // Passiamo i dati caricati
            loading={loading}       // Passiamo lo stato di caricamento
            onAdd={onAdd}
            onEdit={onEdit}
            onDelete={handleDelete} // Passiamo la funzione che gestisce l'eliminazione
            columns={columns}
            filterConfig={filterConfig}
            sortLogic={(a, b) => (a.nome || "").localeCompare(b.nome || "")}
        />
    );
};

export default AbilitaList;

==================================================
FILE: src\components\editors\AbilitaManager.jsx
==================================================
import React, { useState } from 'react';
import { ArrowLeft } from 'lucide-react';
import AbilitaList from './AbilitaList';
import AbilitaEditor from './AbilitaEditor';

const AbilitaManager = ({ onBack, onLogout }) => {
  const [view, setView] = useState('list'); // 'list' | 'editor'
  const [selectedItem, setSelectedItem] = useState(null);

  const handleAdd = () => {
    setSelectedItem(null);
    setView('editor');
  };

  const handleEdit = (item) => {
    setSelectedItem(item);
    setView('editor');
  };

  const handleBackToList = () => {
    setView('list');
    setSelectedItem(null);
  };

  return (
    <div className="space-y-6">
      <button 
        onClick={view === 'list' ? onBack : handleBackToList}
        className="flex items-center gap-2 text-gray-400 hover:text-white transition-colors text-sm font-bold uppercase"
      >
        <ArrowLeft size={16} />
        {view === 'list' ? 'Torna agli Strumenti' : 'Annulla e Torna alla Lista'}
      </button>

      {view === 'list' ? (
        <AbilitaList onAdd={handleAdd} onEdit={handleEdit} onLogout={onLogout} />
      ) : (
        <AbilitaEditor initialData={selectedItem} onBack={handleBackToList} onLogout={onLogout} />
      )}
    </div>
  );
};

export default AbilitaManager;

==================================================
FILE: src\components\editors\CerimonialeEditor.jsx
==================================================
import React, { useState } from 'react';
import { useCharacter } from '../CharacterContext';
import { staffUpdateCerimoniale, staffCreateCerimoniale } from '../../api';
import CharacteristicInline from './inlines/CharacteristicInline';
import RichTextEditor from '../RichTextEditor';

// Aggiunto onCancel e onSave ai props
const CerimonialeEditor = ({ onBack, onCancel, onSave, onLogout, initialData = null }) => {
  const { punteggiList } = useCharacter();
  
  // FIX: Uniamo initialData ai default per non perdere i campi non presenti nella proposta
  const defaultData = {
    nome: '', testo: '', formula_attacco: '',
    aura_richiesta: null,
    prerequisiti: '',
    svolgimento: '',
    effetto: '',
    liv: 1,
    componenti: []
  };

  const [formData, setFormData] = useState({ ...defaultData, ...initialData });

  // Gestione alias per chiusura
  const handleClose = onCancel || onBack;

  const updateInline = (key, index, field, value) => {
    const newList = [...(formData[key] || [])]; // Protezione array vuoto
    newList[index] = { ...newList[index], [field]: value };
    setFormData({ ...formData, [key]: newList });
  };

  const handleSave = async () => {
    try {
      const dataToSend = { 
        ...formData,
        aura_richiesta: formData.aura_richiesta?.id || formData.aura_richiesta || null
      };

      if (onSave) {
        // MODALITÀ APPROVAZIONE PROPOSTA
        // Passiamo i dati al padre (StaffProposalTab) che gestirà la chiamata API di approvazione
        await onSave(dataToSend);
      } else {
        // MODALITÀ EDITOR STANDARD
        if (formData.id) await staffUpdateCerimoniale(formData.id, dataToSend, onLogout);
        else await staffCreateCerimoniale(dataToSend, onLogout);
        alert("Cerimoniale salvato!");
        if (handleClose) handleClose();
      }
    } catch (e) { 
        console.error(e);
        alert("Errore: " + (e.message || "Errore sconosciuto")); 
    }
  };

  return (
    <div className="bg-gray-800 p-6 rounded-xl space-y-6 max-w-7xl mx-auto overflow-y-auto max-h-[92vh] text-white border border-gray-700 shadow-2xl">
      <div className="flex justify-between items-center border-b border-gray-700 pb-4">
        <h2 className="text-xl font-bold text-amber-400 uppercase tracking-tighter">
          {formData.id ? `Edit Cerimoniale: ${formData.nome}` : 'Nuovo Cerimoniale'}
        </h2>
        <div className="flex gap-3">
           <button onClick={handleSave} className="bg-emerald-600 hover:bg-emerald-500 px-8 py-2 rounded-lg font-black text-sm text-white">
             {onSave ? 'APPROVA & CREA' : 'SALVA'}
           </button>
           {handleClose && (
               <button onClick={handleClose} className="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg font-bold text-sm text-white">ANNULLA</button>
           )}
        </div>
      </div>

      <div className="bg-gray-900/40 p-5 rounded-xl border border-gray-700/50 space-y-5">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <Select label="Aura" value={formData.aura_richiesta?.id || formData.aura_richiesta} 
                    options={punteggiList.filter(p => p.tipo === 'AU')} 
                    onChange={v => setFormData({...formData, aura_richiesta: v ? parseInt(v, 10) : null})} />
            <div className="md:col-span-2">
                <Input label="Nome Cerimoniale" value={formData.nome} onChange={v => setFormData({...formData, nome: v})} />
            </div>
            <Input label="Livello (liv)" type="number" value={formData.liv} onChange={v => setFormData({...formData, liv: v})} />
        </div>
      </div>

      <RichTextEditor label="Effetto Tecnico / Formula (HTML)" value={formData.effetto} onChange={v => setFormData({...formData, effetto: v})} />
      <RichTextEditor label="Prerequisiti e Materiali" value={formData.prerequisiti} onChange={v => setFormData({...formData, prerequisiti: v})} />
      <RichTextEditor label="Svolgimento e Testo Narrativo" value={formData.testo} onChange={v => setFormData({...formData, testo: v})} />

      <CharacteristicInline 
        items={formData.componenti || []} 
        options={punteggiList.filter(p => p.tipo === 'CA')}
        onAdd={() => setFormData({...formData, componenti: [...(formData.componenti || []), {caratteristica:'', valore:1}]})}
        onChange={(i, f, v) => updateInline('componenti', i, f, v)}
        onRemove={(i) => setFormData({...formData, componenti: formData.componenti.filter((_, idx) => idx !== i)})}
      />
    </div>
  );
};

// Helper locali...
const Input = ({ label, value, onChange, type="text" }) => (
    <div className="w-full text-left">
      <label className="text-[10px] text-gray-500 uppercase font-black block mb-1 tracking-tighter">{label}</label>
      <input type={type} className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white focus:border-amber-500 outline-none shadow-inner" value={value || ""} onChange={e => onChange(e.target.value)} />
    </div>
);

const Select = ({ label, value, options, onChange }) => (
    <div className="w-full text-left">
      <label className="text-[10px] text-gray-500 uppercase font-black block mb-1 tracking-tighter">{label}</label>
      <select className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white cursor-pointer focus:border-amber-500 outline-none" value={value ? String(value) : ""} onChange={e => onChange(e.target.value)}>
        <option value="">- SELEZIONA -</option>
        {options.map(o => <option key={o.id} value={String(o.id)}>{o.nome}</option>)}
      </select>
    </div>
);

export default CerimonialeEditor;

==================================================
FILE: src\components\editors\CerimonialeList.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffGetCerimoniali, staffDeleteCerimoniale } from '../../api';
import MasterTechniqueList from './MasterTechniqueList';

const CerimonialeList = ({ onAdd, onEdit, onLogout }) => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);

  const loadData = () => {
    setLoading(true);
    staffGetCerimoniali(onLogout)
      .then(data => setItems(Array.isArray(data) ? data : []))
      .finally(() => setLoading(false));
  };

  useEffect(() => { loadData(); }, []);

  const handleDelete = async (id) => {
    if (window.confirm("Eliminare questo Cerimoniale?")) {
      await staffDeleteCerimoniale(id, onLogout);
      loadData();
    }
  };

  return (
    <MasterTechniqueList 
      title="Gestione Cerimoniali"
      addLabel="Nuovo Cerimoniale"
      items={items}
      loading={loading}
      onAdd={onAdd}
      onEdit={onEdit}
      onDelete={handleDelete}
    />
  );
};

export default CerimonialeList;

==================================================
FILE: src\components\editors\CerimonialeManager.jsx
==================================================
import React, { useState } from 'react';
import CerimonialeList from './CerimonialeList';
import CerimonialeEditor from './CerimonialeEditor';

const CerimonialeManager = ({ onBack, onLogout }) => {
  const [view, setView] = useState('list'); // 'list' o 'edit'
  const [editingItem, setEditingItem] = useState(null);

  const handleAdd = () => {
    setEditingItem(null);
    setView('edit');
  };

  const handleEdit = (item) => {
    setEditingItem(item);
    setView('edit');
  };

  const handleBackToList = () => {
    setEditingItem(null);
    setView('list');
  };

  if (view === 'edit') {
    return (
      <CerimonialeEditor 
        initialData={editingItem} 
        onBack={handleBackToList} 
        onLogout={onLogout} 
      />
    );
  }

  return (
    <div className="space-y-6">
      <button 
        onClick={onBack}
        className="text-gray-400 hover:text-white flex items-center gap-2 mb-4 transition-colors"
      >
        ← Torna agli Strumenti Master
      </button>
      
      <CerimonialeList 
        onAdd={handleAdd} 
        onEdit={handleEdit} 
        onLogout={onLogout} 
      />
    </div>
  );
};

export default CerimonialeManager;

==================================================
FILE: src\components\editors\InfusioneEditor.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { useCharacter } from '../CharacterContext';
import { getStatisticheList, staffCreateInfusione, staffUpdateInfusione, getBodySlots } from '../../api';
import CharacteristicInline from './inlines/CharacteristicInline';
import StatBaseInline from './inlines/StatBaseInline';
import StatModInline from './inlines/StatModInline';
import MultiSelectBodySlots from './MultiSelectBodySlots';
import RichTextEditor from '../RichTextEditor';

const InfusioneEditor = ({ onBack, onCancel, onSave, onLogout, initialData = null }) => {
  const { punteggiList } = useCharacter();
  const [statsOptions, setStatsOptions] = useState([]);
  const allBodySlots = getBodySlots();
  
  // FIX: Unione corretta con defaults per evitare 'undefined' su array mancanti
  const defaultData = {
    nome: '', testo: '', formula_attacco: '',
    aura_richiesta: null, aura_infusione: null,
    tipo_risultato: 'POT', is_pesante: false,
    statistica_cariche: null, metodo_ricarica: '',
    costo_ricarica_crediti: 0, durata_attivazione: 0,
    slot_corpo_permessi: '', 
    componenti: [],
    statistiche_base: [],
    modificatori: []
  };

  const [formData, setFormData] = useState({ ...defaultData, ...initialData });

  // Alias per chiusura
  const handleClose = onCancel || onBack;

  const hasChargesData = !!(
    formData.statistica_cariche || 
    formData.costo_ricarica_crediti > 0 || 
    formData.durata_attivazione > 0 || 
    (formData.metodo_ricarica && formData.metodo_ricarica !== '')
  );
  const [isChargesOpen, setIsChargesOpen] = useState(hasChargesData);

  useEffect(() => {
    getStatisticheList(onLogout).then(setStatsOptions);
  }, [onLogout]);

  const updateInline = (key, index, field, value) => {
    const newList = [...(formData[key] || [])];
    if (index === -1 && key === 'statistiche_base') {
      const exists = newList.find(it => (it.statistica?.id || it.statistica) === value.statId);
      if (!exists) newList.push({ statistica: value.statId, valore_base: value.value });
    } else {
      newList[index] = { ...newList[index], [field]: value };
    }
    setFormData({ ...formData, [key]: newList });
  };

  const handleSave = async () => {
    try {
      // 1. DEDUPLICAZIONE MODIFICATORI
      const modsMap = new Map();
      (formData.modificatori || []).forEach(mod => {
        const sId = mod.statistica?.id || mod.statistica;
        if (sId) {
          modsMap.set(sId, { 
            ...mod, 
            statistica: sId,
            id: undefined 
          });
        }
      });

      // 2. DEDUPLICAZIONE STATISTICHE BASE
      const baseMap = new Map();
      (formData.statistiche_base || []).forEach(sb => {
        const sId = sb.statistica?.id || sb.statistica;
        if (sId) {
          baseMap.set(sId, { 
            statistica: sId, 
            valore_base: sb.valore_base,
            id: undefined 
          });
        }
      });

      const dataToSend = { 
        ...formData,
        statistica_cariche: formData.statistica_cariche?.id || formData.statistica_cariche || null,
        aura_richiesta: formData.aura_richiesta?.id || formData.aura_richiesta || null,
        aura_infusione: formData.aura_infusione?.id || formData.aura_infusione || null,
        modificatori: Array.from(modsMap.values()),
        statistiche_base: Array.from(baseMap.values())
      };
      
      if (onSave) {
        // APPROVAL MODE
        await onSave(dataToSend);
      } else {
        // STANDARD MODE
        if (formData.id) await staffUpdateInfusione(formData.id, dataToSend, onLogout);
        else await staffCreateInfusione(dataToSend, onLogout);
        alert("Infusione salvata correttamente!");
        if (handleClose) handleClose();
      }
    } catch (e) {
      console.error(e);
      alert("Errore salvataggio: " + (e.message || "Controlla i dati."));
    }
  };

  const currentCaricheId = formData.statistica_cariche?.id || formData.statistica_cariche;

  return (
    <div className="bg-gray-800 p-6 rounded-xl space-y-6 max-w-7xl mx-auto overflow-y-auto max-h-[92vh] text-white shadow-2xl border border-gray-700">
      
      {/* HEADER */}
      <div className="flex justify-between items-center border-b border-gray-700 pb-4">
        <h2 className="text-xl font-bold text-indigo-400 uppercase tracking-tighter">
          {formData.id ? `Editing: ${formData.nome}` : 'Nuova Infusione'}
        </h2>
        <div className="flex gap-3">
           <button onClick={handleSave} className="bg-emerald-600 hover:bg-emerald-500 px-8 py-2 rounded-lg font-black text-sm transition-all shadow-lg text-white">
             {onSave ? 'APPROVA & CREA' : 'SALVA TECNICA'}
           </button>
           {handleClose && (
             <button onClick={handleClose} className="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg font-bold text-sm transition-all text-white">ANNULLA</button>
           )}
        </div>
      </div>

      {/* 2. IDENTITÀ, AURE E FORMULA */}
      <div className="bg-gray-900/40 p-5 rounded-xl border border-gray-700/50 shadow-inner space-y-5">
        
        {/* RIGA 1: AURE */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <Select 
            label="Aura Richiesta (Requisito)" 
            value={formData.aura_richiesta?.id || formData.aura_richiesta} 
            options={punteggiList.filter(p => p.tipo === 'AU')} 
            onChange={v => setFormData({...formData, aura_richiesta: v ? parseInt(v, 10) : null})} 
          />
          <Select 
            label="Aura Infusione (Occupazione Slot)" 
            value={formData.aura_infusione?.id || formData.aura_infusione} 
            options={punteggiList.filter(p => p.tipo === 'AU')} 
            onChange={v => setFormData({...formData, aura_infusione: v ? parseInt(v, 10) : null})} 
          />
        </div>

        {/* RIGA 2: Formula Attacco */}
        <div className="bg-indigo-500/5 p-3 rounded-lg border border-indigo-500/20">
            <Input label="Formula Attacco (Parametri e Dadi)" placeholder="es. @for + 1d10 + @potenza_materia" value={formData.formula_attacco} onChange={v => setFormData({...formData, formula_attacco: v})} />
        </div>
        
        {/* RIGA 3: Nome, Tipo e Flag */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <div className="md:col-span-2">
            <Input label="Nome Infusione" value={formData.nome} onChange={v => setFormData({...formData, nome: v})} />
          </div>
          <Select label="Tipo Risultato" value={formData.tipo_risultato} 
                  options={[{id: 'POT', nome: 'Potenziamento'}, {id: 'AUM', nome: 'Aumento Corporeo'}]} 
                  onChange={v => setFormData({...formData, tipo_risultato: v})} />
          <div className="flex items-center gap-3 pt-6 justify-center bg-black/20 rounded-lg">
              <input type="checkbox" className="w-5 h-5 rounded accent-indigo-500 cursor-pointer" id="is_pesante" checked={formData.is_pesante} onChange={e => setFormData({...formData, is_pesante: e.target.checked})} />
              <label htmlFor="is_pesante" className="text-[10px] font-black uppercase text-gray-400 tracking-widest cursor-pointer">Oggetto Pesante</label>
          </div>
        </div>
      </div>

      {/* 3. DESCRIZIONE */}
      <RichTextEditor label="Descrizione Narrativa e Tecnica" value={formData.testo} onChange={v => setFormData({...formData, testo: v})} />

      {/* 4. SLOT CORPOREI */}
      {formData.tipo_risultato === 'AUM' && (
        <div className="animate-in fade-in slide-in-from-top-2 duration-300">
            <MultiSelectBodySlots value={formData.slot_corpo_permessi} allSlots={allBodySlots} onChange={v => setFormData({...formData, slot_corpo_permessi: v})} />
        </div>
      )}

      {/* 5. SEZIONE CARICHE */}
      <div className="border border-indigo-500/20 rounded-xl overflow-hidden shadow-lg">
        <button onClick={() => setIsChargesOpen(!isChargesOpen)} className="w-full flex justify-between items-center p-4 bg-indigo-900/20 hover:bg-indigo-900/30 transition-colors">
          <h3 className="text-xs font-black uppercase tracking-widest text-indigo-300">{isChargesOpen ? '▼' : '▶'} Gestione Cariche e Ricarica</h3>
          <span className="text-[9px] text-indigo-500 uppercase">{isChargesOpen ? 'Chiudi' : 'Espandi'}</span>
        </button>
        {isChargesOpen && (
          <div className="p-5 bg-indigo-900/5 space-y-4 border-t border-indigo-500/10 animate-in slide-in-from-top-2 duration-200">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <Select label="Statistica Cariche" value={currentCaricheId} options={statsOptions} onChange={v => setFormData({...formData, statistica_cariche: v ? parseInt(v, 10) : null})} />
                <Input label="Costo Ricarica (Crediti)" type="number" value={formData.costo_ricarica_crediti} onChange={v => setFormData({...formData, costo_ricarica_crediti: v})} />
                <Input label="Durata Attivazione (sec)" type="number" value={formData.durata_attivazione} onChange={v => setFormData({...formData, durata_attivazione: v})} />
            </div>
            <RichTextEditor label="Metodo e Note di Ricarica" value={formData.metodo_ricarica} onChange={v => setFormData({...formData, metodo_ricarica: v})} />
          </div>
        )}
      </div>

      {/* 6. COMPONENTI CARATTERISTICHE */}
      <CharacteristicInline 
        items={formData.componenti || []} 
        options={punteggiList.filter(p => p.tipo === 'CA')}
        onAdd={() => setFormData({...formData, componenti: [...(formData.componenti || []), {caratteristica:'', valore:1}]})}
        onChange={(i, f, v) => updateInline('componenti', i, f, v)}
        onRemove={(i) => setFormData({...formData, componenti: formData.componenti.filter((_, idx) => idx !== i)})}
      />

      {/* 7. STATISTICHE BASE */}
      <StatBaseInline 
        items={formData.statistiche_base || []} 
        options={statsOptions} 
        onChange={(i, f, v) => updateInline('statistiche_base', i, f, v)} 
      />

      {/* 8. MODIFICATORI */}
      <StatModInline 
        items={formData.modificatori || []} 
        options={statsOptions}
        auraOptions={punteggiList.filter(p => p.tipo === 'AU')}
        elementOptions={punteggiList.filter(p => p.tipo === 'EL')}
        onAdd={() => setFormData({...formData, modificatori: [...(formData.modificatori || []), {statistica: null, valore: 0, tipo_modificatore:'ADD', usa_limitazione_aura: false, limit_a_aure: [], usa_limitazione_elemento: false, limit_a_elementi: [], usa_condizione_text: false, condizione_text: ''}]})}
        onChange={(i, f, v) => updateInline('modificatori', i, f, v)}
        onRemove={(i) => setFormData({...formData, modificatori: formData.modificatori.filter((_, idx) => idx !== i)})}
      />
    </div>
  );
};

const Input = ({ label, value, onChange, type="text", placeholder="" }) => (
  <div className="w-full text-left">
    <label className="text-[10px] text-gray-500 uppercase font-black block mb-1 tracking-tighter">{label}</label>
    <input type={type} placeholder={placeholder} className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white focus:border-indigo-500 outline-none shadow-inner" value={value || ""} onChange={e => onChange(e.target.value)} />
  </div>
);

const Select = ({ label, value, options, onChange }) => (
  <div className="w-full text-left">
    <label className="text-[10px] text-gray-500 uppercase font-black block mb-1 tracking-tighter">{label}</label>
    <select className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white cursor-pointer focus:border-indigo-500 outline-none" value={value ? String(value) : ""} onChange={e => onChange(e.target.value)}>
      <option value="">- SELEZIONA -</option>
      {options.map(o => <option key={o.id} value={String(o.id)}>{o.nome}</option>)}
    </select>
  </div>
);

export default InfusioneEditor;

==================================================
FILE: src\components\editors\InfusioneList.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffGetInfusioni, staffDeleteInfusione } from '../../api';
import MasterTechniqueList from './MasterTechniqueList';

const InfusioneList = ({ onSelect, onNew, onLogout }) => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);

  // Carichiamo i dati. 
  // Nota: MasterTechniqueList filtra localmente, quindi cerchiamo di 
  // ottenere la lista completa se possibile, o gestiamo la paginazione 
  // se il backend è molto popolato.
  const loadData = async () => {
    setLoading(true);
    try {
      const response = await staffGetInfusioni(onLogout);
      
      // Gestione sicura del formato DRF (paginato o array diretto)
      if (Array.isArray(response)) {
        setItems(response);
      } else if (response && response.results) {
        setItems(response.results);
      } else {
        setItems([]);
      }
    } catch (err) {
      console.error("Errore caricamento infusioni:", err);
      setItems([]);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadData();
  }, []);

  const handleDelete = async (id) => {
    if (window.confirm("Sei sicuro di voler eliminare questa Infusione? Questa operazione è irreversibile.")) {
      try {
        await staffDeleteInfusione(id, onLogout);
        loadData();
      } catch (e) {
        alert("Errore durante la cancellazione: " + e.message);
      }
    }
  };

  return (
    <MasterTechniqueList 
      title="Gestione Infusioni"
      addLabel="Nuova Infusione"
      items={items}
      loading={loading}
      onAdd={onNew}
      onEdit={onSelect}
      onDelete={handleDelete}
    />
  );
};

export default InfusioneList;

==================================================
FILE: src\components\editors\InfusioneManager.jsx
==================================================
import React, { useState } from 'react';
import InfusioneList from './InfusioneList';
import InfusioneEditor from './InfusioneEditor';

const InfusioneManager = ({ onBack, onLogout }) => {
  const [view, setView] = useState('list'); // 'list' o 'edit'
  const [selectedItem, setSelectedItem] = useState(null);

  const handleEdit = (item) => {
    setSelectedItem(item);
    setView('edit');
  };

  const handleNew = () => {
    setSelectedItem(null);
    setView('edit');
  };

  const handleEditorBack = () => {
    setView('list');
    setSelectedItem(null);
  };

  return (
    <div className="max-w-6xl mx-auto">
      <div className="mb-6">
        <button onClick={onBack} className="text-amber-500 hover:text-amber-400 text-sm font-bold flex items-center gap-1">
          ← TORNA AGLI STRUMENTI MASTER
        </button>
      </div>

      {view === 'list' ? (
        <InfusioneList 
          onSelect={handleEdit} 
          onNew={handleNew} 
          onLogout={onLogout} 
        />
      ) : (
        <InfusioneEditor 
          initialData={selectedItem} 
          onBack={handleEditorBack} 
          onLogout={onLogout} 
        />
      )}
    </div>
  );
};

export default InfusioneManager;

==================================================
FILE: src\components\editors\MasterGenericList.jsx
==================================================
import React, { useState, useMemo } from 'react';
import { Search, Pencil, Trash2, Plus, FilterX } from 'lucide-react';

const MasterGenericList = ({ 
  items = [], 
  title, 
  onAdd, 
  onEdit, 
  onDelete, 
  addLabel = "Nuovo",
  loading = false,
  filterConfig = [], 
  columns = [],
  sortLogic,
  emptyMessage = "Seleziona dei filtri o cerca per visualizzare i dati."
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [activeFilters, setActiveFilters] = useState({});

  const toggleFilter = (key, val) => {
    setActiveFilters(prev => {
      const current = prev[key] || [];
      const updated = current.includes(val) ? current.filter(v => v !== val) : [...current, val];
      return { ...prev, [key]: updated };
    });
  };

  const resetFilters = () => {
    setActiveFilters({});
    setSearchTerm('');
  };

  const filteredItems = useMemo(() => {
    const hasActiveFilters = Object.values(activeFilters).some(arr => arr.length > 0);
    if (!searchTerm && !hasActiveFilters && filterConfig.length > 0) return []; 

    let filtered = items.filter(item => {
      const matchSearch = (item.nome || "").toLowerCase().includes(searchTerm.toLowerCase());
      if (!matchSearch) return false;
      
      return Object.entries(activeFilters).every(([key, values]) => {
        if (values.length === 0) return true;
        const conf = filterConfig.find(c => c.key === key);
        if (conf?.match) return conf.match(item, values);
        const itemVal = item[key]?.id !== undefined ? item[key].id : item[key];
        return values.includes(itemVal);
      });
    });

    return sortLogic ? [...filtered].sort(sortLogic) : filtered;
  }, [items, searchTerm, activeFilters, sortLogic, filterConfig]);

  return (
    // H-FULL e FLEX-COL sono cruciali per bloccare l'altezza e scrollare dentro
    <div className="flex flex-col h-full space-y-4">
      
      {/* HEADER FISSO */}
      <div className="flex-none bg-gray-800 p-4 rounded-xl border border-gray-700 shadow-lg space-y-4">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
          <h2 className="text-xl font-bold text-white uppercase tracking-tighter">{title}</h2>
          
          <div className="flex items-center gap-3 w-full md:w-auto justify-end">
            {Object.values(activeFilters).some(a => a.length > 0) && (
                <button 
                  onClick={resetFilters} 
                  className="text-gray-500 hover:text-white flex items-center gap-1 text-[10px] uppercase font-bold transition-colors"
                >
                    <FilterX size={14} /> Reset
                </button>
            )}
            <button 
              onClick={onAdd} 
              className="bg-cyan-600 hover:bg-cyan-500 px-4 py-2 rounded-lg font-black text-xs transition-all flex items-center gap-2 uppercase text-white shadow-lg active:scale-95 whitespace-nowrap"
            >
              <Plus size={16} /> {addLabel}
            </button>
          </div>
        </div>

        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500" size={18} />
          <input 
            type="text" 
            placeholder="Cerca per nome..." 
            className="w-full bg-gray-950 border border-gray-700 rounded-lg pl-10 pr-4 py-2 text-sm focus:border-cyan-500 outline-none text-white transition-all placeholder:text-gray-700"
            value={searchTerm} 
            onChange={e => setSearchTerm(e.target.value)}
          />
        </div>

        {filterConfig.length > 0 && (
          <div className="space-y-3 pt-2 border-t border-gray-700/50">
            {filterConfig.map(conf => (
              <div key={conf.key} className="flex flex-col md:flex-row items-start md:items-center gap-2">
                <span className="text-[10px] font-black text-gray-500 uppercase w-full md:w-auto min-w-[70px] mb-1 md:mb-0">
                  {conf.label}:
                </span>
                <div className="flex flex-wrap gap-2">
                    {conf.options.map(opt => {
                      const isActive = (activeFilters[conf.key] || []).includes(opt.id);
                      return (
                        <button 
                          key={opt.id}
                          onClick={() => toggleFilter(conf.key, opt.id)}
                          title={opt.label || opt.nome}
                          className={`transition-all duration-200 ${conf.type === 'icon' ? 'p-1 rounded-full border' : 'px-3 py-1 rounded text-xs font-bold border'} ${
                            isActive
                            ? 'bg-cyan-600 border-cyan-400 text-white shadow-lg scale-105' 
                            : 'bg-gray-900 border-gray-700 text-gray-500 hover:border-gray-500'
                          }`}
                          style={conf.type === 'icon' && isActive ? { backgroundColor: opt.colore || opt.color } : {}}
                        >
                          {conf.renderOption ? conf.renderOption(opt, isActive) : (opt.label || opt.nome)}
                        </button>
                      );
                    })}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* BODY SCROLLABILE - Questa è la parte magica per mobile */}
      <div className="flex-1 bg-gray-800 rounded-xl border border-gray-700 shadow-xl overflow-hidden flex flex-col min-h-0">
        <div className="overflow-auto flex-1"> {/* Overflow-auto qui gestisce X e Y */}
          <table className="w-full text-left border-collapse min-w-[600px]">
            <thead className="sticky top-0 z-20"> {/* Sticky Header */}
              <tr className="bg-gray-900 text-gray-400 text-[10px] uppercase font-black tracking-widest border-b border-gray-700 shadow-md">
                {columns.map((col, idx) => (
                  <th 
                    key={idx} 
                    className={`px-4 py-3 whitespace-nowrap bg-gray-900 ${col.align === 'center' ? 'text-center' : col.align === 'right' ? 'text-right' : ''}`} 
                    style={{ width: col.width }}
                  >
                    {col.header}
                  </th>
                ))}
                <th className="px-4 py-3 text-right w-24 bg-gray-900 sticky right-0 z-30 shadow-[-5px_0px_5px_-2px_rgba(0,0,0,0.5)]">Azioni</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-700/50 text-sm">
              {filteredItems.map(item => (
                <tr key={item.id} className="hover:bg-gray-700/30 transition-colors border-b border-gray-800/50 text-white group">
                  {columns.map((col, idx) => (
                    <td 
                      key={idx} 
                      className={`px-4 py-3 whitespace-nowrap ${col.align === 'center' ? 'text-center' : col.align === 'right' ? 'text-right' : ''}`}
                    >
                      {col.render(item)}
                    </td>
                  ))}
                  <td className="px-4 py-3 text-right whitespace-nowrap sticky right-0 bg-gray-800 group-hover:bg-gray-700/30 transition-colors z-10 shadow-[-5px_0px_5px_-2px_rgba(0,0,0,0.3)]">
                      <div className="flex justify-end gap-1 opacity-100 md:opacity-60 md:group-hover:opacity-100 transition-opacity">
                        <button 
                          onClick={() => onEdit(item)} 
                          className="p-2 bg-amber-600/20 text-amber-500 hover:bg-amber-600 hover:text-white rounded-lg transition-all"
                        >
                          <Pencil size={14} />
                        </button>
                        <button 
                          onClick={() => onDelete(item.id)} 
                          className="p-2 bg-red-600/20 text-red-500 hover:bg-red-600 hover:text-white rounded-lg transition-all"
                        >
                          <Trash2 size={14} />
                        </button>
                      </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        
          {loading && (
              <div className="p-12 text-center text-cyan-500 animate-pulse font-black uppercase tracking-widest">
                  Caricamento dati in corso...
              </div>
          )}
          
          {!loading && filteredItems.length === 0 && (
              <div className="p-12 text-center space-y-3">
                  <div className="text-gray-700 flex justify-center"><FilterX size={48} /></div>
                  <p className="text-gray-500 italic text-sm max-w-xs mx-auto">
                      {emptyMessage}
                  </p>
              </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default MasterGenericList;

==================================================
FILE: src\components\editors\MasterTechniqueList.jsx
==================================================
import React from 'react';
import { useCharacter } from '../CharacterContext';
import IconaPunteggio from '../IconaPunteggio';
import MasterGenericList from './MasterGenericList';

/**
 * MasterTechniqueList
 * Wrapper di MasterGenericList specializzato per la gestione di 
 * Infusioni, Tessiture e Cerimoniali.
 */
const MasterTechniqueList = ({ 
  items, 
  title, 
  onAdd, 
  onEdit, 
  onDelete, 
  addLabel = "Nuovo",
  loading = false 
}) => {
  const { punteggiList } = useCharacter();

  // 1. Configurazione Filtri (Livelli e Aure)
  const filterConfig = [
    {
      key: 'livello_virtual', // Chiave virtuale, usiamo match personalizzato
      label: 'Livelli',
      type: 'button',
      options: [1, 2, 3, 4, 5, 6, 7].map(l => ({ id: l, label: l.toString() })),
      // Logica di matching per coprire sia il campo 'livello' che 'liv'
      match: (item, values) => values.includes(item.livello || item.liv)
    },
    {
      key: 'aura_richiesta',
      label: 'Aure',
      type: 'icon',
      options: punteggiList.filter(p => p.tipo === 'AU'),
      renderOption: (opt) => (
        <IconaPunteggio 
          url={opt.icona_url || opt.icona} 
          color={opt.colore} 
          size="xs" 
          mode="cerchio_inv" 
        />
      ),
      // Matcher per gestire ID o oggetti nidificati per l'aura
      match: (item, values) => {
        const itemAuraId = item.aura_richiesta?.id || item.aura_richiesta;
        return values.includes(itemAuraId);
      }
    }
  ];

  // 2. Definizione Colonne
  const columns = [
    { 
      header: 'Lvl', 
      width: '60px', 
      align: 'center',
      render: (item) => (
        <span className="font-mono font-bold text-gray-400">
          {item.livello || item.liv}
        </span>
      )
    },
    { 
      header: 'Au', 
      width: '50px', 
      align: 'center',
      render: (item) => {
        const aura = item.aura_richiesta;
        return aura ? (
          <div className="flex justify-center" title={aura.nome}>
            <IconaPunteggio 
              url={aura.icona_url || aura.icona} 
              color={aura.colore} 
              size="xs" 
              mode="cerchio_inv" 
            />
          </div>
        ) : <span className="text-gray-600 text-[10px]">—</span>;
      }
    },
    { 
      header: 'Nome', 
      render: (item) => (
        <div className="font-bold text-cyan-50 truncate max-w-[150px] md:max-w-xs">
          {item.nome}
        </div>
      )
    }
  ];

  // 3. Logica di Ordinamento: Aura -> Livello -> Nome
  const sortLogic = (a, b) => {
    // Ordine Aura
    const auraA = a.aura_richiesta?.ordine ?? 999;
    const auraB = b.aura_richiesta?.ordine ?? 999;
    if (auraA !== auraB) return auraA - auraB;

    // Ordine Livello
    const livA = a.livello || a.liv || 0;
    const livB = b.livello || b.liv || 0;
    if (livA !== livB) return livA - livB;

    // Ordine Alfabetico
    return (a.nome || "").localeCompare(b.nome || "");
  };

  return (
    <MasterGenericList 
      title={title}
      items={items}
      columns={columns}
      filterConfig={filterConfig}
      sortLogic={sortLogic}
      onAdd={onAdd} 
      onEdit={onEdit} 
      onDelete={onDelete}
      loading={loading}
      addLabel={addLabel}
      emptyMessage="Seleziona un Livello o un'Aura per visualizzare i dati."
    />
  );
};

export default MasterTechniqueList;

==================================================
FILE: src\components\editors\MostroEditor.jsx
==================================================
import React, { useState } from 'react';
import { staffUpdateMostroTemplate, staffCreateMostroTemplate } from '../../api'; // Assicurati di creare queste funzioni
import RichTextEditor from '../RichTextEditor';
import { Trash, Plus, GripVertical } from 'lucide-react';

const MostroEditor = ({ onBack, onLogout, initialData = null }) => {
  const [formData, setFormData] = useState(initialData || {
    nome: '', 
    punti_vita_base: 1, 
    armatura_base: 0, 
    guscio_base: 0,
    note_generali: '', 
    costume: '',
    attacchi: [] 
  });

  // Gestione Attacchi Inline
  const addAttacco = () => {
    setFormData({
        ...formData,
        attacchi: [...(formData.attacchi || []), { nome_attacco: '', descrizione_danno: '', ordine: (formData.attacchi?.length || 0) + 1 }]
    });
  };

  const updateAttacco = (index, field, value) => {
    const newAttacchi = [...formData.attacchi];
    newAttacchi[index] = { ...newAttacchi[index], [field]: value };
    setFormData({ ...formData, attacchi: newAttacchi });
  };

  const removeAttacco = (index) => {
    const newAttacchi = formData.attacchi.filter((_, i) => i !== index);
    setFormData({ ...formData, attacchi: newAttacchi });
  };

  const handleSave = async () => {
    try {
      // Se l'API richiede serializzatori nested scrivibili, invia tutto l'oggetto.
      // Altrimenti dovrai gestire il salvataggio degli attacchi separatamente.
      // Qui assumo che il backend accetti la lista "attacchi" nested nel JSON.
      
      if (formData.id) await staffUpdateMostroTemplate(formData.id, formData, onLogout);
      else await staffCreateMostroTemplate(formData, onLogout);
      
      alert("Salvato correttamente!"); 
      onBack();
    } catch (e) { 
        console.error(e);
        alert("Errore durante il salvataggio: " + e.message); 
    }
  };

  return (
    <div className="bg-gray-800 p-6 rounded-xl space-y-6 max-w-5xl mx-auto overflow-y-auto max-h-[92vh] border border-gray-700 shadow-2xl text-white">
      {/* Header */}
      <div className="flex justify-between items-center border-b border-gray-700 pb-4">
        <h2 className="text-xl font-bold text-red-400 uppercase tracking-tighter">
            {formData.id ? `Edit: ${formData.nome}` : 'Nuovo Template Mostro'}
        </h2>
        <div className="flex gap-3">
           <button onClick={handleSave} className="bg-emerald-600 hover:bg-emerald-500 px-8 py-2 rounded-lg font-black text-sm shadow-lg">SALVA</button>
           <button onClick={onBack} className="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg font-bold text-sm">ANNULLA</button>
        </div>
      </div>

      {/* Dati Base */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 bg-gray-900/40 p-4 rounded-xl border border-gray-700/50">
        <div className="md:col-span-4">
            <label className="text-[10px] text-gray-500 uppercase font-black block mb-1">Nome Mostro / Tipologia</label>
            <input 
                className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm font-bold text-white focus:border-red-500 outline-none" 
                value={formData.nome} 
                onChange={e => setFormData({...formData, nome: e.target.value})} 
                placeholder="Es. Sgherro Cybernetico, Zombie..."
            />
        </div>
        
        <div className="bg-red-900/10 p-2 rounded border border-red-900/20">
            <label className="text-[10px] text-red-500 uppercase font-black block mb-1">Punti Vita Base</label>
            <input type="number" className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm font-mono" value={formData.punti_vita_base} onChange={e => setFormData({...formData, punti_vita_base: parseInt(e.target.value)})} />
        </div>
        <div className="bg-gray-700/10 p-2 rounded border border-gray-700/20">
            <label className="text-[10px] text-gray-400 uppercase font-black block mb-1">Armatura Base</label>
            <input type="number" className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm font-mono" value={formData.armatura_base} onChange={e => setFormData({...formData, armatura_base: parseInt(e.target.value)})} />
        </div>
        <div className="bg-indigo-900/10 p-2 rounded border border-indigo-900/20">
            <label className="text-[10px] text-indigo-400 uppercase font-black block mb-1">Guscio Base</label>
            <input type="number" className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm font-mono" value={formData.guscio_base} onChange={e => setFormData({...formData, guscio_base: parseInt(e.target.value)})} />
        </div>
      </div>

      {/* Rich Text Editors */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div className="space-y-2">
            <RichTextEditor 
                label="Costume & Tratti Visivi" 
                value={formData.costume} 
                onChange={v => setFormData({...formData, costume: v})} 
            />
          </div>
          <div className="space-y-2">
            <RichTextEditor 
                label="Note Generali & Comportamento" 
                value={formData.note_generali} 
                onChange={v => setFormData({...formData, note_generali: v})} 
            />
          </div>
      </div>

      {/* Sezione Attacchi */}
      <div className="bg-gray-900/40 p-4 rounded-xl border border-gray-700/50">
        <div className="flex justify-between items-center mb-4">
            <h3 className="text-sm font-black uppercase text-amber-500">Attacchi & Capacità Offensive</h3>
            <button onClick={addAttacco} className="flex items-center gap-1 bg-amber-600/20 text-amber-500 px-3 py-1 rounded text-xs font-bold hover:bg-amber-600 hover:text-white transition-colors">
                <Plus size={14} /> AGGIUNGI ATTACCO
            </button>
        </div>
        
        <div className="space-y-2">
            {formData.attacchi && formData.attacchi.map((attacco, index) => (
                <div key={index} className="flex items-start gap-2 bg-gray-950 p-2 rounded border border-gray-800">
                    <div className="pt-2 text-gray-600 cursor-move"><GripVertical size={16}/></div>
                    <div className="flex-1 grid grid-cols-1 md:grid-cols-3 gap-2">
                        <input 
                            className="bg-gray-900 p-2 rounded border border-gray-700 text-xs font-bold text-amber-100 placeholder-gray-600" 
                            placeholder="Nome colpo (es. Artigli)"
                            value={attacco.nome_attacco}
                            onChange={e => updateAttacco(index, 'nome_attacco', e.target.value)}
                        />
                        <div className="md:col-span-2">
                            <input 
                                className="w-full bg-gray-900 p-2 rounded border border-gray-700 text-xs text-gray-300 font-mono placeholder-gray-600" 
                                placeholder="Effetto (es. 2 Fisici, Sbilanciare)"
                                value={attacco.descrizione_danno}
                                onChange={e => updateAttacco(index, 'descrizione_danno', e.target.value)}
                            />
                        </div>
                    </div>
                    <button onClick={() => removeAttacco(index)} className="p-2 text-red-700 hover:text-red-500 transition-colors">
                        <Trash size={16} />
                    </button>
                </div>
            ))}
            {(!formData.attacchi || formData.attacchi.length === 0) && (
                <div className="text-center py-4 text-gray-600 text-xs italic">Nessun attacco definito.</div>
            )}
        </div>
      </div>
    </div>
  );
};

export default MostroEditor;

==================================================
FILE: src\components\editors\MostroList.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react'; // <--- Aggiungi useMemo
import { staffGetMostriTemplates, staffDeleteMostroTemplate } from '../../api'; 
import MasterGenericList from './MasterGenericList';
import { Heart, Shield, Layout } from 'lucide-react';

const MostroList = ({ onAdd, onEdit, onLogout }) => {
    const [items, setItems] = useState([]);
    const [loading, setLoading] = useState(true);

    const loadData = () => {
        setLoading(true);
        if (typeof staffGetMostriTemplates === 'function') {
            staffGetMostriTemplates(onLogout)
                .then(data => {
                    console.log("DEBUG MOSTRI:", data);
                    if (data && data.results && Array.isArray(data.results)) {
                        setItems(data.results);
                    } else if (Array.isArray(data)) {
                        setItems(data);
                    } else {
                        setItems([]);
                    }
                })
                .catch(err => {
                    console.error("Errore fetch mostri:", err);
                    setItems([]);
                })
                .finally(() => setLoading(false));
        } else {
            setLoading(false);
        }
    };

    useEffect(() => { loadData(); }, []);

    // --- CORREZIONE: Avvolgi columns in useMemo ---
    const columns = useMemo(() => [
        { 
            header: 'Nome Template', 
            render: (item) => (
                <span className="font-bold text-lg text-red-400">{item.nome}</span>
            )
        },
        { 
            header: 'Stats Base', 
            width: '200px',
            render: (item) => (
                <div className="flex gap-3 text-sm font-mono">
                    <span className="flex items-center gap-1 text-red-500" title="PV"><Heart size={12} fill="currentColor"/> {item.punti_vita_base}</span>
                    <span className="flex items-center gap-1 text-gray-400" title="Armatura"><Shield size={12}/> {item.armatura_base}</span>
                    <span className="flex items-center gap-1 text-indigo-400" title="Guscio"><Layout size={12}/> {item.guscio_base}</span>
                </div>
            )
        },
        {
            header: 'Attacchi',
            render: (item) => (
                <span className="text-xs text-gray-500">
                    {item.attacchi ? item.attacchi.length : 0} attacchi definiti
                </span>
            )
        }
    ], []); // Dipendenze vuote perché le colonne sono statiche
    // ----------------------------------------------

    const sortLogic = (a, b) => a.nome.localeCompare(b.nome);

    const handleDelete = (id) => {
        if (window.confirm("Sei sicuro di voler eliminare definitivamente questo template di mostro?")) {
            if (typeof staffDeleteMostroTemplate === 'function') {
                staffDeleteMostroTemplate(id, onLogout).then(loadData);
            }
        }
    };

    return (
        <MasterGenericList 
            title="Database Template Mostri"
            items={items}
            columns={columns}
            sortLogic={sortLogic}
            onAdd={onAdd} 
            onEdit={onEdit} 
            onDelete={handleDelete}
            loading={loading}
            addLabel="Nuovo Mostro"
        />
    );
};

export default MostroList;

==================================================
FILE: src\components\editors\MostroManager.jsx
==================================================
import React, { useState } from 'react';
import { ArrowLeft } from 'lucide-react';
import MostroList from './MostroList';
import MostroEditor from './MostroEditor';

const MostroManager = ({ onBack, onLogout }) => {
  const [view, setView] = useState('list'); // 'list' | 'editor'
  const [selectedItem, setSelectedItem] = useState(null);

  const handleAdd = () => {
    setSelectedItem(null);
    setView('editor');
  };

  const handleEdit = (item) => {
    setSelectedItem(item);
    setView('editor');
  };

  const handleBackToList = () => {
    setView('list');
    setSelectedItem(null);
  };

  return (
    <div className="space-y-6">
      <button 
        onClick={view === 'list' ? onBack : handleBackToList}
        className="flex items-center gap-2 text-gray-400 hover:text-white transition-colors text-sm font-bold uppercase"
      >
        <ArrowLeft size={16} /> 
        {view === 'list' ? 'Torna agli Strumenti' : 'Annulla e Torna alla Lista'}
      </button>

      {view === 'list' ? (
        <MostroList 
          onAdd={handleAdd} 
          onEdit={handleEdit} 
          onLogout={onLogout} 
        />
      ) : (
        <MostroEditor 
          initialData={selectedItem} 
          onBack={handleBackToList} 
          onLogout={onLogout} 
        />
      )}
    </div>
  );
};

export default MostroManager;

==================================================
FILE: src\components\editors\MultiSelectBodySlots.jsx
==================================================
import React from 'react';

const MultiSelectBodySlots = ({ value = "", allSlots, onChange }) => {
  // Converte la stringa salvata in un array di codici
  const selectedList = value ? value.split(',') : [];

  const toggleSlot = (code) => {
    const newList = selectedList.includes(code)
      ? selectedList.filter(s => s !== code)
      : [...selectedList, code];
    // Restituisce la stringa unita per il backend
    onChange(newList.join(','));
  };

  return (
    <div className="bg-gray-900/30 p-4 rounded-lg border border-gray-700">
      <label className="text-[10px] text-gray-500 uppercase font-black block mb-2 text-center tracking-widest">Slot Corporei Consentiti</label>
      <div className="flex flex-wrap gap-2 justify-center">
        {allSlots.map(slot => (
          <button
            key={slot.code}
            type="button"
            onClick={() => toggleSlot(slot.code)}
            className={`px-3 py-1 rounded-md text-[10px] font-bold border uppercase transition-all shadow-sm ${
              selectedList.includes(slot.code) 
                ? 'bg-indigo-600 border-indigo-400 text-white scale-105' 
                : 'bg-gray-800 border-gray-700 text-gray-500 hover:border-gray-500'
            }`}
          >
            {slot.name}
          </button>
        ))}
      </div>
    </div>
  );
};

export default MultiSelectBodySlots;

==================================================
FILE: src\components\editors\OggettoBaseEditor.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { useCharacter } from '../CharacterContext';
import { staffUpdateOggettoBase, staffCreateOggettoBase, staffGetClassiOggetto } from '../../api';
import StatBaseInline from './inlines/StatBaseInline';
import StatModInline from './inlines/StatModInline';
import RichTextEditor from '../RichTextEditor'; // Importazione corretta
import { ArrowLeft, Save } from 'lucide-react';

const TIPO_CHOICES = [
    {id:'FIS', nome:'Fisico'}, {id:'MAT', nome:'Materia'}, {id:'MOD', nome:'Mod'},
    {id:'INN', nome:'Innesto'}, {id:'MUT', nome:'Mutazione'}, {id:'AUM', nome:'Aumento'}, {id:'POT', nome:'Potenziamento'}
];

const OggettoBaseEditor = ({ onBack, onLogout, initialData = null }) => {
  const { punteggiList } = useCharacter();
  const [classi, setClassi] = useState([]);
  
  const [formData, setFormData] = useState(initialData || {
    nome: '', 
    descrizione: '', 
    tipo_oggetto: 'FIS', 
    classe_oggetto: null, 
    costo: 0, 
    is_tecnologico: false, 
    is_pesante: false, 
    attacco_base: '',
    in_vendita: true,
    statistiche_base: [], 
    statistiche_modificatori: []
  });

  useEffect(() => { staffGetClassiOggetto(onLogout).then(setClassi); }, []);

  // Gestione aggiornamento liste (statistiche base e mod)
  const updateInline = (key, index, field, value) => {
    const newList = [...formData[key]];
    if (index === -1) {
        // Creazione nuova riga
        const exists = newList.find(it => (it.statistica?.id || it.statistica) === value.statId);
        if (!exists) {
            const newRecord = { statistica: value.statId };
            if (key === 'statistiche_base') {
                newRecord.valore_base = value.value;
            } else {
                newRecord.valore = value.value;
                newRecord.tipo_modificatore = 'ADD'; 
            }
            newList.push(newRecord);
        }
    } else {
        // Aggiornamento riga esistente
        newList[index] = { ...newList[index], [field]: value };
    }
    setFormData({ ...formData, [key]: newList });
  };

  const handleSave = async () => {
    try {
        const getId = (item) => item?.id || item || null;
        
        // Funzione robusta per pulire le statistiche prima dell'invio
        const prepareStats = (list, isMod = false) => {
            return list.map(item => {
                const statId = typeof item.statistica === 'object' ? item.statistica.id : item.statistica;
                // Base object structure
                const cleanItem = { statistica: statId };
                
                if (isMod) {
                    cleanItem.valore = parseInt(item.valore || 0);
                    cleanItem.tipo_modificatore = item.tipo_modificatore || 'ADD';
                } else {
                    cleanItem.valore_base = parseInt(item.valore_base || 0);
                }
                return cleanItem;
            }).filter(i => i.statistica); // Rimuove entry vuote
        };

        const data = { 
            ...formData, 
            classe_oggetto: getId(formData.classe_oggetto),
            statistiche_base: prepareStats(formData.statistiche_base, false),
            statistiche_modificatori: prepareStats(formData.statistiche_modificatori, true)
        };

        if (formData.id) await staffUpdateOggettoBase(formData.id, data, onLogout);
        else await staffCreateOggettoBase(data, onLogout);
        
        alert("Salvato correttamente!");
        onBack();
    } catch (e) { 
        console.error("Errore Salvataggio:", e);
        alert("Errore salvataggio: " + (e.message || "Controlla i dati.")); 
    }
  };

  const Select = ({ label, value, options, onChange }) => (
    <div className="w-full">
      <label className="text-[10px] text-gray-500 uppercase font-black block mb-1">{label}</label>
      <select className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white focus:border-blue-500 outline-none" 
        value={value || ""} onChange={e => onChange(e.target.value)}>
        <option value="">- SELEZIONA -</option>
        {options.map(o => <option key={o.id} value={o.id}>{o.nome || o.label}</option>)}
      </select>
    </div>
  );

  return (
    <div className="bg-gray-800 p-6 rounded-xl space-y-6 max-w-7xl mx-auto border border-gray-700 shadow-2xl text-white overflow-y-auto max-h-[92vh]">
      
      {/* Header */}
      <div className="flex justify-between items-center border-b border-gray-700 pb-4">
        <h2 className="text-xl font-bold text-blue-400 uppercase tracking-tighter">
            {formData.id ? `Edit Template: ${formData.nome}` : 'Nuovo Oggetto Base'}
        </h2>
        <div className="flex gap-3">
           <button onClick={handleSave} className="bg-blue-600 hover:bg-blue-500 px-6 py-2 rounded-lg font-black text-xs uppercase shadow-lg transition-all flex items-center gap-2">
                <Save size={16}/> Salva
           </button>
           <button onClick={onBack} className="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg font-bold text-xs uppercase transition-all flex items-center gap-2">
                <ArrowLeft size={16}/> Indietro
           </button>
        </div>
      </div>

      {/* Dati Principali */}
      <div className="bg-gray-900/40 p-4 rounded-xl border border-gray-800 space-y-4">
        
        {/* Riga 1: Nome e Tipo */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
                <label className="text-[10px] text-gray-500 uppercase font-black block mb-1">Nome Template</label>
                <input className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm focus:border-blue-500 outline-none text-white font-bold" 
                    value={formData.nome} onChange={e => setFormData({...formData, nome: e.target.value})} />
            </div>
            <Select label="Tipo Oggetto" value={formData.tipo_oggetto} options={TIPO_CHOICES} onChange={v => setFormData({...formData, tipo_oggetto: v})} />
        </div>

        {/* Riga 2: Classe e Costo */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Select label="Classe Oggetto" value={formData.classe_oggetto?.id || formData.classe_oggetto} options={classi} onChange={v => setFormData({...formData, classe_oggetto: v})} />
            <div>
                <label className="text-[10px] text-gray-500 uppercase font-black block mb-1">Costo (CR)</label>
                <input type="number" className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm focus:border-blue-500 outline-none text-amber-400 font-mono" 
                    value={formData.costo} onChange={e => setFormData({...formData, costo: e.target.value})} />
            </div>
        </div>

        {/* Riga 3: Flags */}
        <div className="flex flex-wrap gap-6 pt-2 border-t border-gray-800 mt-2">
            <label className="flex items-center gap-2 text-xs font-bold cursor-pointer hover:text-blue-300 transition-colors">
                <input type="checkbox" className="accent-blue-500 w-4 h-4" checked={formData.in_vendita} onChange={e => setFormData({...formData, in_vendita: e.target.checked})} /> 
                In Vendita (Shop)
            </label>
            <label className="flex items-center gap-2 text-xs font-bold cursor-pointer hover:text-red-300 transition-colors">
                <input type="checkbox" className="accent-red-500 w-4 h-4" checked={formData.is_pesante} onChange={e => setFormData({...formData, is_pesante: e.target.checked})} /> 
                Pesante (OGP)
            </label>
            <label className="flex items-center gap-2 text-xs font-bold cursor-pointer hover:text-emerald-300 transition-colors">
                <input type="checkbox" className="accent-emerald-500 w-4 h-4" checked={formData.is_tecnologico} onChange={e => setFormData({...formData, is_tecnologico: e.target.checked})} /> 
                Tecnologico
            </label>
        </div>
      </div>

      {/* Attacco Base (Riga Isolata) */}
      <div className="bg-gray-900/40 p-4 rounded-xl border border-gray-800">
            <label className="text-[10px] text-red-500 uppercase font-black block mb-1">Formula Attacco Base</label>
            <input className="w-full bg-gray-950 p-3 rounded border border-gray-700 text-sm focus:border-red-500 outline-none text-red-300 font-mono tracking-wide" 
                placeholder="Es. {forza} Danni Contundenti + 2"
                value={formData.attacco_base || ''} onChange={e => setFormData({...formData, attacco_base: e.target.value})} />
            <p className="text-[9px] text-gray-600 mt-1 italic">Usa le parentesi graffe per le variabili dinamiche, es: &#123;forza&#125;</p>
      </div>

      {/* Descrizione (Rich Text) */}
      <div className="bg-gray-900/40 p-4 rounded-xl border border-gray-800">
            <label className="text-[10px] text-gray-500 uppercase font-black block mb-2">Descrizione Dettagliata</label>
            <div className="bg-gray-950 rounded-lg border border-gray-700 overflow-hidden min-h-[150px]">
                <RichTextEditor 
                    value={formData.descrizione || ''} 
                    onChange={val => setFormData({...formData, descrizione: val})} 
                />
            </div>
      </div>

      {/* Statistiche Base (Piena Larghezza) */}
      <div className="bg-gray-900/40 p-4 rounded-xl border border-gray-800">
          <h3 className="text-xs font-black uppercase text-indigo-400 mb-4 pb-2 border-b border-gray-800">Statistiche Base Richieste</h3>
          <StatBaseInline 
            items={formData.statistiche_base} 
            options={punteggiList.filter(p => p.tipo === 'ST')} 
            onChange={(i, f, v) => updateInline('statistiche_base', i, f, v)}
          />
      </div>
      
      {/* Modificatori (Piena Larghezza) */}
      <div className="bg-gray-900/40 p-4 rounded-xl border border-gray-800">
          <h3 className="text-xs font-black uppercase text-emerald-400 mb-4 pb-2 border-b border-gray-800">Modificatori Applicati (Bonus/Malus)</h3>
          <StatModInline 
            items={formData.statistiche_modificatori} 
            options={punteggiList.filter(p => p.tipo === 'ST')} 
            auraOptions={punteggiList.filter(p => p.tipo === 'AU')} 
            elementOptions={punteggiList.filter(p => p.tipo === 'EL')}
            onAdd={() => setFormData({...formData, statistiche_modificatori: [...formData.statistiche_modificatori, {statistica:'', valore:0, tipo_modificatore:'ADD'}]})} 
            onChange={(i,f,v) => updateInline('statistiche_modificatori', i, f, v)}
            onRemove={i => setFormData({...formData, statistiche_modificatori: formData.statistiche_modificatori.filter((_,idx)=>idx!==i)})} 
          />
      </div>

    </div>
  );
};

export default OggettoBaseEditor;

==================================================
FILE: src\components\editors\OggettoBaseList.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffGetOggettiBase, staffDeleteOggettoBase, staffGetClassiOggetto } from '../../api';
import MasterGenericList from './MasterGenericList';

const TIPO_OGGETTO_CHOICES = [
    { id: 'FIS', nome: 'Fisico' },
    { id: 'MAT', nome: 'Materia' },
    { id: 'MOD', nome: 'Mod' },
    { id: 'INN', nome: 'Innesto' },
    { id: 'MUT', nome: 'Mutazione' },
    { id: 'AUM', nome: 'Aumento' },
    { id: 'POT', nome: 'Potenziamento' },
];

const OggettoBaseList = ({ onAdd, onEdit, onLogout }) => {
    const [items, setItems] = useState([]);
    const [classi, setClassi] = useState([]);
    const [loading, setLoading] = useState(true);

    const loadData = () => {
        setLoading(true);
        // Carichiamo sia i template che le classi per i filtri
        Promise.all([
            staffGetOggettiBase(onLogout),
            staffGetClassiOggetto(onLogout)
        ]).then(([data, cData]) => {
            setItems(data || []);
            setClassi(cData || []);
        }).finally(() => setLoading(false));
    };

    useEffect(() => { loadData(); }, []);

    // MODIFICA QUI: Rimossa la configurazione per 'tipo_oggetto'
    const filterConfig = [
        {
            key: 'classe_oggetto',
            label: 'Classe',
            type: 'button',
            options: classi.map(c => ({ id: c.id, label: c.nome }))
        }
    ];

    const columns = [
        { 
            header: 'Classe', 
            width: '120px',
            render: (item) => <span className="font-bold text-blue-400 text-xs">{item.classe_oggetto_nome || '—'}</span>
        },
        { 
            header: 'Tipo', 
            width: '100px',
            render: (item) => (
                <span className="text-[10px] bg-gray-900 border border-gray-700 px-2 py-0.5 rounded font-black text-gray-500">
                    {TIPO_OGGETTO_CHOICES.find(c => c.id === item.tipo_oggetto)?.nome || item.tipo_oggetto}
                </span>
            )
        },
        { 
            header: 'Nome Template', 
            render: (item) => (
                <div className="flex items-center gap-2">
                    <span className="font-bold text-white">{item.nome}</span>
                    {item.is_pesante && (
                        <span className="bg-red-900/30 text-red-500 text-[8px] px-1 border border-red-900 rounded font-black">PESANTE</span>
                    )}
                    {!item.in_vendita && (
                        <span className="bg-gray-700 text-gray-400 text-[8px] px-1 rounded font-black italic uppercase">Off-List</span>
                    )}
                </div>
            ) 
        },
        {
            header: 'Costo',
            width: '100px',
            align: 'right',
            render: (item) => <span className="font-mono text-emerald-400 font-bold">{item.costo} <small className="text-[10px] text-gray-500">CR</small></span>
        }
    ];

    const sortLogic = (a, b) => {
        // Ordiniamo prima per Classe e poi per Nome
        if (a.classe_oggetto_nome !== b.classe_oggetto_nome) {
            return (a.classe_oggetto_nome || "").localeCompare(b.classe_oggetto_nome || "");
        }
        return a.nome.localeCompare(b.nome);
    };

    const handleDelete = (id) => {
        if (window.confirm("Attenzione: l'eliminazione di un Oggetto Base non influisce sulle istanze già possedute dai PG, ma lo rimuoverà dal listino. Procedere?")) {
            staffDeleteOggettoBase(id, onLogout).then(loadData);
        }
    };

    return (
        <MasterGenericList 
            title="Listino Oggetti Base (Template)"
            items={items}
            columns={columns}
            filterConfig={filterConfig}
            sortLogic={sortLogic}
            onAdd={onAdd} 
            onEdit={onEdit} 
            onDelete={handleDelete}
            loading={loading}
            addLabel="Nuovo Template"
            emptyMessage="Usa i filtri sopra per sfogliare il listino oggetti base."
        />
    );
};

export default OggettoBaseList;

==================================================
FILE: src\components\editors\OggettoBaseManager.jsx
==================================================
import React, { useState } from 'react';
import { ArrowLeft } from 'lucide-react';
import OggettoBaseList from './OggettoBaseList';
import OggettoBaseEditor from './OggettoBaseEditor';

const OggettoBaseManager = ({ onBack, onLogout }) => {
  const [view, setView] = useState('list');
  const [selectedItem, setSelectedItem] = useState(null);

  const handleAdd = () => {
    setSelectedItem(null);
    setView('editor');
  };

  const handleEdit = (item) => {
    setSelectedItem(item);
    setView('editor');
  };

  const handleBackToList = () => {
    setView('list');
    setSelectedItem(null);
  };

  return (
    <div className="space-y-6">
      <button 
        onClick={view === 'list' ? onBack : handleBackToList}
        className="flex items-center gap-2 text-gray-400 hover:text-white transition-colors text-sm font-bold uppercase"
      >
        <ArrowLeft size={16} /> 
        {view === 'list' ? 'Torna agli Strumenti' : 'Annulla e Torna alla Lista'}
      </button>

      {view === 'list' ? (
        <OggettoBaseList 
          onAdd={handleAdd} 
          onEdit={handleEdit} 
          onLogout={onLogout} 
        />
      ) : (
        <OggettoBaseEditor 
          initialData={selectedItem} 
          onBack={handleBackToList} 
          onLogout={onLogout} 
        />
      )}
    </div>
  );
};

export default OggettoBaseManager;

==================================================
FILE: src\components\editors\OggettoEditor.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { useCharacter } from '../CharacterContext';
import { staffUpdateOggetto, staffCreateOggetto, staffGetClassiOggetto, getPersonaggiList } from '../../api';
import CharacteristicInline from './inlines/CharacteristicInline';
import StatBaseInline from './inlines/StatBaseInline';
import StatModInline from './inlines/StatModInline';
import RichTextEditor from '../RichTextEditor';

const TIPO_CHOICES = [
    {id:'FIS', nome:'Fisico'}, {id:'MAT', nome:'Materia'}, {id:'MOD', nome:'Mod'},
    {id:'INN', nome:'Innesto'}, {id:'MUT', nome:'Mutazione'}, {id:'AUM', nome:'Aumento'}, {id:'POT', nome:'Potenziamento'}
];

const OggettoEditor = ({ onBack, onLogout, initialData = null }) => {
  const { punteggiList } = useCharacter();
  const [classi, setClassi] = useState([]);
  const [personaggi, setPersonaggi] = useState([]);

  const [formData, setFormData] = useState(initialData || {
    nome: '', testo: '', tipo_oggetto: 'FIS', aura: null, classe_oggetto: null,
    is_tecnologico: false, is_equipaggiato: false, is_pesante: false,
    inventario_corrente: null,
    attacco_base: '', componenti: [], statistiche_base: [], statistiche: []
  });

  useEffect(() => {
    const loadData = async () => {
        try {
            const [classiData, pgsData] = await Promise.all([
                staffGetClassiOggetto(onLogout),
                getPersonaggiList(onLogout, true)
            ]);
            setClassi(classiData || []);
            setPersonaggi(pgsData || []);
        } catch (error) {
            console.error("Errore caricamento dati editor:", error);
        }
    };
    loadData();
  }, [onLogout]);

  // Logica unificata per update inline
  const updateInline = (key, index, field, value) => {
    const newList = [...formData[key]];
    if (index === -1) {
      const exists = newList.find(it => (it.statistica?.id || it.statistica) === value.statId);
      if (!exists) {
          const newRecord = { statistica: value.statId };
          if (key === 'statistiche_base') newRecord.valore_base = value.value;
          else {
              newRecord.valore = value.value;
              newRecord.tipo_modificatore = 'ADD';
          }
          newList.push(newRecord);
      }
    } else {
      newList[index] = { ...newList[index], [field]: value };
    }
    setFormData({ ...formData, [key]: newList });
  };

  const handleSave = async () => {
    try {
      const getId = (item) => item?.id || item || null;
      
      const cleanAndDeduplicate = (list, keyField) => {
        const seen = new Set();
        return list
          .map(item => ({ ...item, [keyField]: getId(item[keyField]) }))
          .filter(item => {
            const id = item[keyField];
            if (!id || seen.has(id)) return false; 
            seen.add(id);
            return true;
          });
      };

      const data = { 
          ...formData, 
          aura: getId(formData.aura), 
          classe_oggetto: getId(formData.classe_oggetto),
          inventario_corrente: formData.inventario_corrente ? parseInt(formData.inventario_corrente) : null,
          
          statistiche_base: cleanAndDeduplicate(formData.statistiche_base, 'statistica'),
          statistiche: cleanAndDeduplicate(formData.statistiche, 'statistica'),
          componenti: cleanAndDeduplicate(formData.componenti, 'caratteristica')
      };

      if (formData.id) await staffUpdateOggetto(formData.id, data, onLogout);
      else await staffCreateOggetto(data, onLogout);
      
      alert("Salvato correttamente!"); 
      onBack();
    } catch (e) { 
        console.error(e);
        alert("Errore: " + e.message); 
    }
  };

  const Select = ({ label, value, options, onChange }) => (
    <div className="w-full">
      <label className="text-[10px] text-gray-500 uppercase font-black block mb-1">{label}</label>
      <select className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white cursor-pointer" 
        value={value || ""} onChange={e => onChange(e.target.value)}>
        <option value="">- SELEZIONA -</option>
        {options.map(o => <option key={o.id} value={o.id}>{o.nome || o.label}</option>)}
      </select>
    </div>
  );

  return (
    <div className="bg-gray-800 p-6 rounded-xl space-y-6 max-w-7xl mx-auto overflow-y-auto max-h-[92vh] border border-gray-700 shadow-2xl text-white">
      <div className="flex justify-between items-center border-b border-gray-700 pb-4">
        <h2 className="text-xl font-bold text-emerald-400 uppercase tracking-tighter">{formData.id ? `Edit: ${formData.nome}` : 'Nuovo Oggetto'}</h2>
        <div className="flex gap-3">
           <button onClick={handleSave} className="bg-emerald-600 hover:bg-emerald-500 px-8 py-2 rounded-lg font-black text-sm">SALVA</button>
           <button onClick={onBack} className="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg font-bold text-sm">ANNULLA</button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 bg-gray-900/40 p-4 rounded-xl">
        <div className="md:col-span-2">
            <label className="text-[10px] text-gray-500 uppercase font-black block mb-1">Nome</label>
            <input className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm" value={formData.nome} onChange={e => setFormData({...formData, nome: e.target.value})} />
        </div>
        
        <Select label="Tipo" value={formData.tipo_oggetto} options={TIPO_CHOICES} onChange={v => setFormData({...formData, tipo_oggetto: v})} />
        
        <Select 
            label="Proprietario (Inventario)" 
            value={formData.inventario_corrente} 
            options={personaggi} 
            onChange={v => setFormData({...formData, inventario_corrente: v})} 
        />

        <Select label="Aura" value={formData.aura?.id || formData.aura} options={punteggiList.filter(p => p.tipo === 'AU')} onChange={v => setFormData({...formData, aura: v})} />
        <Select label="Classe" value={formData.classe_oggetto?.id || formData.classe_oggetto} options={classi} onChange={v => setFormData({...formData, classe_oggetto: v})} />
        
        <div className="flex flex-col gap-2 pt-2">
            <label className="flex items-center gap-2 text-xs font-bold cursor-pointer"><input type="checkbox" checked={formData.is_tecnologico} onChange={e => setFormData({...formData, is_tecnologico: e.target.checked})} /> Tecnologico</label>
            <label className="flex items-center gap-2 text-xs font-bold cursor-pointer"><input type="checkbox" checked={formData.is_pesante} onChange={e => setFormData({...formData, is_pesante: e.target.checked})} /> Pesante (OGP)</label>
        </div>
        
        <div className="md:col-span-2">
            <label className="text-[10px] text-gray-500 uppercase font-black block mb-1">Formula Attacco</label>
            <input className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm font-mono" value={formData.attacco_base} onChange={e => setFormData({...formData, attacco_base: e.target.value})} />
        </div>
      </div>

      <RichTextEditor label="Descrizione Narrativa" value={formData.testo} onChange={v => setFormData({...formData, testo: v})} />

      <div className="grid grid-cols-1 gap-6">
          <StatBaseInline 
            items={formData.statistiche_base} 
            options={punteggiList.filter(p => p.tipo === 'ST')} 
            onChange={(i, f, v) => updateInline('statistiche_base', i, f, v)}
          />
          
          <StatModInline 
            items={formData.statistiche} 
            options={punteggiList.filter(p => p.tipo === 'ST')} 
            auraOptions={punteggiList.filter(p => p.tipo === 'AU')} 
            elementOptions={punteggiList.filter(p => p.tipo === 'EL')} 
            onAdd={() => setFormData({...formData, statistiche: [...formData.statistiche, {statistica:'', valore:0, tipo_modificatore:'ADD'}]})} 
            onChange={(i,f,v) => updateInline('statistiche', i, f, v)} 
            onRemove={i => setFormData({...formData, statistiche: formData.statistiche.filter((_,idx)=>idx!==i)})} 
          />
      </div>

      <CharacteristicInline items={formData.componenti} options={punteggiList.filter(p => p.tipo === 'CA')} onAdd={() => setFormData({...formData, componenti: [...formData.componenti, {caratteristica:'', valore:1}]})} onChange={(i,f,v) => {const n=[...formData.componenti]; n[i][f]=v; setFormData({...formData, componenti:n});}} onRemove={i => setFormData({...formData, componenti: formData.componenti.filter((_,idx)=>idx!==i)})} />
    </div>
  );
};

export default OggettoEditor;

==================================================
FILE: src\components\editors\OggettoList.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffGetOggetti, staffDeleteOggetto } from '../../api';
import { useCharacter } from '../CharacterContext';
import MasterGenericList from './MasterGenericList';
import IconaPunteggio from '../IconaPunteggio';

const TIPO_OGGETTO_CHOICES = [
    { id: 'FIS', nome: 'Fisico' },
    { id: 'MAT', nome: 'Materia' },
    { id: 'MOD', nome: 'Mod' },
    { id: 'INN', nome: 'Innesto' },
    { id: 'MUT', nome: 'Mutazione' },
    { id: 'AUM', nome: 'Aumento' },
    { id: 'POT', nome: 'Potenziamento' },
];

const OggettoList = ({ onAdd, onEdit, onLogout }) => {
    const [items, setItems] = useState([]);
    const [loading, setLoading] = useState(true);
    const { punteggiList } = useCharacter();

    const loadData = () => {
        setLoading(true);
        staffGetOggetti(onLogout)
            .then(data => setItems(data || []))
            .finally(() => setLoading(false));
    };

    useEffect(() => { loadData(); }, []);

    const filterConfig = [
        {
            key: 'aura',
            label: 'Aura',
            type: 'icon',
            options: punteggiList.filter(p => p.tipo === 'AU'),
            renderOption: (opt) => (
                <IconaPunteggio url={opt.icona_url} color={opt.colore} size="xs" mode="cerchio_inv" />
            )
        },
        {
            key: 'tipo_oggetto',
            label: 'Tipo',
            type: 'button',
            options: TIPO_OGGETTO_CHOICES
        }
    ];

    const columns = [
        { 
            header: 'Au', 
            width: '50px', 
            align: 'center',
            render: (item) => item.aura ? (
                <IconaPunteggio url={item.aura.icona_url} color={item.aura.colore} size="xs" mode="cerchio_inv" />
            ) : <span className="text-gray-600">—</span>
        },
        { 
            header: 'Tipo', 
            width: '100px',
            render: (item) => (
                <span className="text-[10px] bg-gray-900 border border-gray-700 px-2 py-0.5 rounded font-black text-gray-400">
                    {TIPO_OGGETTO_CHOICES.find(c => c.id === item.tipo_oggetto)?.nome || item.tipo_oggetto}
                </span>
            )
        },
        { 
            header: 'Nome', 
            render: (item) => (
                <div className="flex flex-col">
                    <span className="font-bold text-cyan-50">{item.nome}</span>
                    {item.classe_oggetto_nome && (
                        <span className="text-[9px] text-gray-500 uppercase tracking-tighter">{item.classe_oggetto_nome}</span>
                    )}
                </div>
            )
        }
    ];

    const sortLogic = (a, b) => {
        const auraA = a.aura?.ordine ?? 999;
        const auraB = b.aura?.ordine ?? 999;
        if (auraA !== auraB) return auraA - auraB;
        if (a.tipo_oggetto !== b.tipo_oggetto) return a.tipo_oggetto.localeCompare(b.tipo_oggetto);
        return a.nome.localeCompare(b.nome);
    };

    const handleDelete = (id) => {
        if (window.confirm("Sei sicuro di voler eliminare definitivamente questo oggetto?")) {
            staffDeleteOggetto(id, onLogout).then(loadData);
        }
    };

    return (
        <MasterGenericList 
            title="Istanze Oggetti in Gioco"
            items={items}
            columns={columns}
            filterConfig={filterConfig}
            sortLogic={sortLogic}
            onAdd={onAdd} 
            onEdit={onEdit} 
            onDelete={handleDelete}
            loading={loading}
            addLabel="Crea Oggetto"
        />
    );
};

export default OggettoList;

==================================================
FILE: src\components\editors\OggettoManager.jsx
==================================================
import React, { useState } from 'react';
import { ArrowLeft } from 'lucide-react';
import OggettoList from './OggettoList';
import OggettoEditor from './OggettoEditor';

const OggettoManager = ({ onBack, onLogout }) => {
  const [view, setView] = useState('list'); // 'list' | 'editor'
  const [selectedItem, setSelectedItem] = useState(null);

  const handleAdd = () => {
    setSelectedItem(null);
    setView('editor');
  };

  const handleEdit = (item) => {
    setSelectedItem(item);
    setView('editor');
  };

  const handleBackToList = () => {
    setView('list');
    setSelectedItem(null);
  };

  return (
    <div className="space-y-6">
      <button 
        onClick={view === 'list' ? onBack : handleBackToList}
        className="flex items-center gap-2 text-gray-400 hover:text-white transition-colors text-sm font-bold uppercase"
      >
        <ArrowLeft size={16} /> 
        {view === 'list' ? 'Torna agli Strumenti' : 'Annulla e Torna alla Lista'}
      </button>

      {view === 'list' ? (
        <OggettoList 
          onAdd={handleAdd} 
          onEdit={handleEdit} 
          onLogout={onLogout} 
        />
      ) : (
        <OggettoEditor 
          initialData={selectedItem} 
          onBack={handleBackToList} 
          onLogout={onLogout} 
        />
      )}
    </div>
  );
};

export default OggettoManager;

==================================================
FILE: src\components\editors\StaffProposalTab.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffGetProposteInValutazione, staffRifiutaProposta, staffApprovaProposta } from '../../api';
import GenericHeader from '../GenericHeader';
import { Eye, X, Check, ClipboardCheck, AlertCircle } from 'lucide-react';
import RichTextEditor from '../RichTextEditor';

// Importazione degli Editor per la fase di approvazione/creazione finale
import InfusioneEditor from './InfusioneEditor';
import TessituraEditor from './TessituraEditor';
import CerimonialeEditor from './CerimonialeEditor';

const StaffProposalTab = ({ onLogout }) => {
    const [proposals, setProposals] = useState([]);
    const [selectedProposal, setSelectedProposal] = useState(null);
    const [viewMode, setViewMode] = useState('list'); // 'list', 'detail', 'approve_edit'
    const [staffNotes, setStaffNotes] = useState("");
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        loadProposals();
    }, []);

    const loadProposals = async () => {
        setLoading(true);
        try {
            const data = await staffGetProposteInValutazione(onLogout);
            setProposals(Array.isArray(data) ? data : data.results || []);
        } catch (error) {
            console.error("Errore caricamento proposte", error);
        } finally {
            setLoading(false);
        }
    };

    const handleOpenDetail = (prop) => {
        setSelectedProposal(prop);
        setStaffNotes(prop.note_staff || "");
        setViewMode('detail');
    };

    const handleBack = () => {
        setSelectedProposal(null);
        setViewMode('list');
    };

    const handleRifiuta = async () => {
        if (!confirm("Confermi il rifiuto? La proposta tornerà in Bozza al giocatore.")) return;
        try {
            await staffRifiutaProposta(selectedProposal.id, staffNotes, onLogout);
            alert("Proposta rifiutata e rimandata al giocatore.");
            handleBack();
            loadProposals();
        } catch (err) {
            alert("Errore: " + err.message);
        }
    };

    const handleStartApproval = () => {
        setViewMode('approve_edit');
    };

    // Prepara i dati per l'editor.
    // FIX: Mappiamo correttamente i dati per evitare errori 'undefined map'
    const getInitialEditorData = () => {
        if (!selectedProposal) return {};
        const p = selectedProposal;
        
        // Normalizziamo i componenti: l'editor si aspetta un array.
        // Inoltre, convertiamo l'oggetto 'caratteristica' nel suo ID, perché i select degli editor lavorano con gli ID.
        const cleanComponenti = (p.componenti || []).map(c => ({
            caratteristica: (c.caratteristica && typeof c.caratteristica === 'object') ? c.caratteristica.id : c.caratteristica,
            valore: c.valore
        }));

        return {
            nome: p.nome,
            descrizione: p.descrizione,
            testo: p.descrizione, // ridondanza utile per alcuni editor
            aura_richiesta: (p.aura && typeof p.aura === 'object') ? p.aura.id : p.aura,
            
            // Livello e Liv (per compatibilità cerimoniali)
            livello: p.livello,
            liv: p.livello_proposto || 1, 
            
            // FIX CRITICO: Passiamo 'componenti' con la chiave standard, non 'override'
            componenti: cleanComponenti,
            
            // Altri campi testuali
            prerequisiti: p.prerequisiti || "",
            svolgimento: p.svolgimento || "",
            effetto: p.effetto || "",
            
            note_staff: staffNotes
        };
    };

    const handleFinalizeApproval = async (finalData) => {
        try {
            // Assicuriamoci che le note staff siano aggiornate
            finalData.note_staff = staffNotes;
            
            // Chiamata API
            await staffApprovaProposta(selectedProposal.id, finalData, onLogout);
            
            // Feedback Utente
            alert("Tecnica approvata e creata con successo!");
            
            // Chiudi e Aggiorna
            // IMPORTANTE: Eseguiamo queste azioni in ordine sicuro
            handleBack(); // Chiude il modale
            setTimeout(() => {
                loadProposals(); // Ricarica la lista dopo un attimo per dare tempo al DB di aggiornarsi
            }, 300);

        } catch (err) {
            console.error("Errore Approvazione:", err);
            // Gestione sicura dell'errore (evita variabili non definite come 't')
            const errorMsg = err.response?.data?.error || err.message || "Errore sconosciuto";
            alert("Errore durante l'approvazione: " + errorMsg);
        }
    };

    // Helper per visualizzare nomi
    const getCharName = (componente) => {
        if (componente.caratteristica_nome) return componente.caratteristica_nome;
        if (componente.caratteristica && typeof componente.caratteristica === 'object') {
            return componente.caratteristica.nome || componente.caratteristica.sigla || "Caratteristica";
        }
        return "ID: " + componente.caratteristica;
    };

    const getPgName = (p) => {
        // Gestione robusta del nome personaggio
        if (p.personaggio_nome) return p.personaggio_nome;
        if (p.personaggio && typeof p.personaggio === 'object') return p.personaggio.nome;
        // Se è solo ID, proviamo a vedere se abbiamo info extra, altrimenti fallback
        return "Personaggio (ID " + p.personaggio + ")";
    };

    // --- RENDER: LISTA ---
    if (viewMode === 'list') {
        return (
            <div className="h-full flex flex-col bg-gray-900 text-white p-6 overflow-hidden">
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-2xl font-black uppercase tracking-wider text-orange-500 flex items-center gap-3">
                        <ClipboardCheck size={32}/> Valutazione Proposte
                    </h2>
                    <button onClick={loadProposals} className="text-sm underline text-gray-400 hover:text-white">Aggiorna</button>
                </div>
                
                <div className="flex-1 overflow-auto rounded-xl border border-gray-700 bg-gray-800/50 shadow-inner">
                    <table className="w-full text-left text-gray-300">
                        <thead className="bg-gray-800 text-xs uppercase font-bold text-gray-400 sticky top-0 z-10 shadow-md">
                            <tr>
                                <th className="px-6 py-4">Personaggio</th>
                                <th className="px-6 py-4">Tipo</th>
                                <th className="px-6 py-4">Nome Tecnica</th>
                                {/* Rimossa colonna data come richiesto */}
                                <th className="px-6 py-4 text-right">Azioni</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-gray-700">
                            {proposals.length === 0 ? (
                                <tr>
                                    <td colSpan="4" className="p-10 text-center text-gray-500 italic flex flex-col items-center gap-2">
                                        <AlertCircle size={24}/>
                                        Nessuna proposta in attesa di valutazione.
                                    </td>
                                </tr>
                            ) : (
                                proposals.map(p => (
                                    <tr key={p.id} className="hover:bg-gray-700/50 transition-colors">
                                        <td className="px-6 py-4 font-bold text-white">
                                            {getPgName(p)}
                                        </td>
                                        <td className="px-6 py-4">
                                            <span className={`px-2 py-1 rounded text-[10px] font-black tracking-wider uppercase border ${
                                                p.tipo==='INF' ? 'bg-indigo-900/30 text-indigo-300 border-indigo-700' :
                                                p.tipo==='TES' ? 'bg-cyan-900/30 text-cyan-300 border-cyan-700' : 
                                                'bg-purple-900/30 text-purple-300 border-purple-700'
                                            }`}>
                                                {p.tipo === 'INF' ? 'Infusione' : p.tipo === 'TES' ? 'Tessitura' : 'Cerimoniale'}
                                            </span>
                                        </td>
                                        <td className="px-6 py-4 text-white font-medium">{p.nome}</td>
                                        <td className="px-6 py-4 text-right">
                                            <button 
                                                onClick={() => handleOpenDetail(p)} 
                                                className="bg-orange-600 hover:bg-orange-500 text-white px-4 py-1.5 rounded-lg text-xs font-bold uppercase shadow-lg transition-all flex items-center gap-2 ml-auto"
                                            >
                                                <Eye size={14} /> Valuta
                                            </button>
                                        </td>
                                    </tr>
                                ))
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    }

    // --- RENDER: EDITOR DI APPROVAZIONE ---
    if (viewMode === 'approve_edit') {
        const commonProps = {
            initialData: getInitialEditorData(),
            onSave: handleFinalizeApproval,
            onCancel: () => setViewMode('detail'),
            onLogout: onLogout, 
            isApprovalMode: true 
        };

        return (
            <div className="fixed inset-0 bg-black z-60 overflow-y-auto">
                <div className="p-6 max-w-7xl mx-auto">
                    <div className="flex justify-between items-center mb-6 bg-gray-800 p-4 rounded-xl border border-gray-700">
                        <div className="flex items-center gap-3">
                            <div className="bg-green-600/20 p-2 rounded-lg border border-green-500/50">
                                <Check className="text-green-500" size={24}/>
                            </div>
                            <div>
                                <h2 className="text-xl font-bold text-white">Finalizzazione {selectedProposal.tipo}</h2>
                                <p className="text-sm text-gray-400">Modifica se necessario e salva per creare la tecnica effettiva.</p>
                            </div>
                        </div>
                        <button onClick={() => setViewMode('detail')} className="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg font-bold text-sm">Annulla</button>
                    </div>
                    
                    <div className="bg-gray-900 rounded-xl border border-gray-700 overflow-hidden min-h-[80vh]">
                        {selectedProposal.tipo === 'INF' && <InfusioneEditor {...commonProps} />}
                        {selectedProposal.tipo === 'TES' && <TessituraEditor {...commonProps} />}
                        {selectedProposal.tipo === 'CER' && <CerimonialeEditor {...commonProps} />}
                    </div>
                </div>
            </div>
        );
    }

    // --- RENDER: DETTAGLIO (MODALE VALUTAZIONE) ---
    return (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center p-4 z-50 overflow-y-auto backdrop-blur-md">
            <div className="bg-gray-900 border border-gray-600 rounded-2xl w-full max-w-6xl max-h-[95vh] flex flex-col shadow-2xl">
                
                {/* Header Modale */}
                <div className="p-5 border-b border-gray-700 flex justify-between items-center bg-gray-800 rounded-t-2xl">
                    <div>
                        <h2 className="text-2xl font-bold text-white flex items-center gap-2">
                            <span className="text-orange-500">Valutazione:</span> {selectedProposal.nome}
                        </h2>
                        <div className="flex gap-2 mt-1">
                            <span className="text-xs bg-gray-700 px-2 py-0.5 rounded text-gray-300 font-mono">ID: {selectedProposal.id}</span>
                            <span className="text-xs bg-gray-700 px-2 py-0.5 rounded text-gray-300">Livello: {selectedProposal.livello}</span>
                        </div>
                    </div>
                    <button onClick={handleBack} className="text-gray-400 hover:text-white bg-gray-700/50 p-2 rounded-full hover:bg-gray-700"><X size={24}/></button>
                </div>

                {/* Contenuto Scrollabile */}
                <div className="p-6 overflow-y-auto flex-1 space-y-6">
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 h-full">
                        
                        {/* Colonna SX: Dati della Proposta */}
                        <div className="space-y-6 overflow-y-auto pr-2">
                            {/* Card Dati Tecnici */}
                            <div className="bg-gray-800/50 p-5 rounded-xl border border-gray-700">
                                <h3 className="text-cyan-500 font-black uppercase text-xs tracking-widest mb-4 border-b border-gray-700 pb-2">Specifiche Tecniche</h3>
                                <div className="space-y-2 text-sm">
                                    <p><strong className="text-gray-400">Tipo:</strong> {selectedProposal.tipo}</p>
                                    <p><strong className="text-gray-400">Aura Richiesta:</strong> {selectedProposal.aura_nome || (typeof selectedProposal.aura === 'object' ? selectedProposal.aura.nome : selectedProposal.aura)}</p>
                                    {selectedProposal.tipo === 'CER' && (
                                        <p><strong className="text-gray-400">Livello Proposto:</strong> {selectedProposal.livello_proposto}</p>
                                    )}
                                    <div className="mt-3 bg-gray-900 p-3 rounded-lg">
                                        <strong className="text-gray-400 block mb-2 text-xs uppercase">Componenti / Mattoni:</strong>
                                        <ul className="list-disc pl-5 text-gray-300 space-y-1">
                                            {selectedProposal.componenti && selectedProposal.componenti.map((c, i) => (
                                                <li key={i}>
                                                    <span className="text-cyan-400 font-bold">{getCharName(c)}</span> 
                                                    <span className="text-gray-500 text-xs ml-2">x{c.valore}</span>
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            {/* Card Descrizione */}
                            <div className="bg-gray-800/50 p-5 rounded-xl border border-gray-700">
                                <h3 className="text-cyan-500 font-black uppercase text-xs tracking-widest mb-4 border-b border-gray-700 pb-2">Descrizione Giocatore</h3>
                                <div className="prose prose-invert text-sm max-w-none text-gray-300 leading-relaxed whitespace-pre-wrap"
                                     dangerouslySetInnerHTML={{ __html: selectedProposal.descrizione }} 
                                />
                                
                                {selectedProposal.tipo === 'CER' && (
                                    <div className="mt-6 space-y-4 pt-4 border-t border-gray-700/50">
                                        <div>
                                            <strong className="text-yellow-500 block text-xs uppercase mb-1">Prerequisiti</strong>
                                            <p className="text-sm text-gray-300">{selectedProposal.prerequisiti}</p>
                                        </div>
                                        <div>
                                            <strong className="text-yellow-500 block text-xs uppercase mb-1">Svolgimento</strong>
                                            <p className="text-sm text-gray-300">{selectedProposal.svolgimento}</p>
                                        </div>
                                        <div>
                                            <strong className="text-yellow-500 block text-xs uppercase mb-1">Effetto</strong>
                                            <p className="text-sm text-gray-300">{selectedProposal.effetto}</p>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Colonna DX: Note Staff e Azioni */}
                        <div className="flex flex-col h-full bg-gray-800 p-1 rounded-xl border border-gray-700">
                            <div className="bg-gray-900 rounded-t-lg p-3 border-b border-gray-700">
                                <label className="text-xs font-black text-gray-400 uppercase tracking-widest flex items-center gap-2">
                                    <ClipboardCheck size={14}/> Note Staff (Visibili al giocatore)
                                </label>
                            </div>
                            <div className="flex-1 overflow-hidden relative">
                                <RichTextEditor 
                                    value={staffNotes} 
                                    onChange={setStaffNotes}
                                    placeholder="Scrivi qui le motivazioni del rifiuto o eventuali note di approvazione..."
                                    className="h-full border-none rounded-none focus:ring-0"
                                />
                            </div>
                        </div>
                    </div>
                </div>

                {/* Footer Azioni */}
                <div className="p-5 border-t border-gray-700 bg-gray-800 rounded-b-2xl flex justify-end gap-4 shadow-lg z-20">
                    <button 
                        onClick={handleRifiuta}
                        className="bg-red-900/30 border border-red-700 text-red-300 hover:bg-red-900/50 px-6 py-3 rounded-xl flex items-center gap-2 text-sm font-bold uppercase transition-all"
                    >
                        <X size={18} /> Rifiuta (Torna in Bozza)
                    </button>
                    
                    <button 
                        onClick={handleStartApproval}
                        className="bg-green-600 hover:bg-green-500 text-white px-8 py-3 rounded-xl flex items-center gap-2 font-black uppercase shadow-lg shadow-green-900/30 hover:scale-105 transition-all"
                    >
                        <Check size={18} /> Approva & Crea Tecnica
                    </button>
                </div>
            </div>
        </div>
    );
};

export default StaffProposalTab;

==================================================
FILE: src\components\editors\TabellaEditor.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { 
    Save, X, Plus, Trash2, Search, Layers, 
    ChevronDown, LayoutList, Type, AlignLeft 
} from 'lucide-react';
import RichTextEditor from '../RichTextEditor'; 
import { getAllAbilitaSimple } from '../../api';

// Mappatura delle tipologie (da allineare con personaggi/models.py)
const TIER_TYPES = [
    { value: 'G0', label: 'Tabelle Generali' },
    { value: 'T1', label: 'Tier 1' },
    { value: 'T2', label: 'Tier 2' },
    { value: 'T3', label: 'Tier 3' },
    { value: 'T4', label: 'Tier 4' },
    // { value: 'SP', label: 'Specializzazione' },
    // { value: 'AL', label: 'Altro' },
];

const TabellaEditor = ({ tier, onSave, onCancel, onLogout }) => {
    // Stato form principale
    const [formData, setFormData] = useState({
        nome: tier?.nome || '',
        tipo: tier?.tipo || 'CL', // Default sicuro
        descrizione: tier?.descrizione || '',
    });

    // Stato gestione abilità collegate
    const [connectedSkills, setConnectedSkills] = useState(
        tier?.abilita_collegate?.map(a => ({
            abilita_id: a.abilita_id,
            nome: a.abilita_nome,
            ordine: a.ordine
        })) || []
    );

    // Stato gestione ricerca/aggiunta abilità
    const [allAbilities, setAllAbilities] = useState([]);
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedAbilityId, setSelectedAbilityId] = useState('');
    const [newOrder, setNewOrder] = useState(0);

    // Carica lista completa abilità
    useEffect(() => {
        const loadAbilities = async () => {
            try {
                const data = await getAllAbilitaSimple(onLogout);
                setAllAbilities(data);
                const maxOrder = connectedSkills.length > 0 ? Math.max(...connectedSkills.map(s => s.ordine)) : 0;
                setNewOrder(maxOrder + 1);
            } catch (error) {
                console.error("Errore caricamento abilità", error);
            }
        };
        loadAbilities();
    }, []); // eslint-disable-line react-hooks/exhaustive-deps

    // Filtra abilità
    const filteredAbilities = allAbilities.filter(a => 
        a.nome.toLowerCase().includes(searchTerm.toLowerCase()) &&
        !connectedSkills.some(cs => cs.abilita_id === a.id)
    );

    const handleAddSkill = () => {
        if (!selectedAbilityId) return;
        const abilityToAdd = allAbilities.find(a => a.id === parseInt(selectedAbilityId));
        
        setConnectedSkills(prev => [...prev, {
            abilita_id: abilityToAdd.id,
            nome: abilityToAdd.nome,
            ordine: parseInt(newOrder)
        }].sort((a,b) => a.ordine - b.ordine));

        setSelectedAbilityId('');
        setNewOrder(parseInt(newOrder) + 1);
        setSearchTerm('');
    };

    const handleRemoveSkill = (id) => {
        setConnectedSkills(prev => prev.filter(s => s.abilita_id !== id));
    };
    
    const handleSkillOrderEdit = (idx, val) => {
        const newSkills = [...connectedSkills];
        newSkills[idx].ordine = parseInt(val);
        newSkills.sort((a,b) => a.ordine - b.ordine);
        setConnectedSkills(newSkills);
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        onSave(formData, connectedSkills);
    };

    return (
        <div className="bg-gray-900 rounded-xl shadow-2xl border border-gray-800 flex flex-col h-full overflow-hidden animate-in fade-in zoom-in-95 duration-300">
            
            {/* === HEADER === */}
            <div className="p-4 md:p-5 border-b border-gray-800 flex justify-between items-center bg-linear-to-r from-gray-900 to-gray-800 shrink-0 z-10">
                <div className="flex items-center gap-3">
                    <div className="bg-indigo-600/20 p-2 rounded-lg border border-indigo-500/30 text-indigo-400">
                        <Layers size={24} />
                    </div>
                    <div>
                        <h2 className="text-lg md:text-xl font-black text-white uppercase tracking-wide leading-none">
                            {tier ? 'Modifica Tabella' : 'Nuova Tabella'}
                        </h2>
                        <span className="text-[10px] text-gray-400 font-mono uppercase tracking-widest">Editor Configurazione</span>
                    </div>
                </div>
                <button onClick={onCancel} className="bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-white p-2 rounded-full transition-all border border-gray-700 hover:border-gray-500">
                    <X size={20} />
                </button>
            </div>

            {/* === BODY SCROLLABILE === */}
            <div className="flex-1 overflow-y-auto p-4 md:p-6 space-y-6 custom-scrollbar bg-gray-900/50">
                
                {/* SEZIONE 1: Dati Generali */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* Nome */}
                    <div className="space-y-2">
                        <label className="flex items-center gap-2 text-xs font-bold text-indigo-400 uppercase tracking-wider">
                            <Type size={14}/> Nome Tabella
                        </label>
                        <input 
                            type="text" 
                            value={formData.nome}
                            onChange={e => setFormData({...formData, nome: e.target.value})}
                            className="w-full bg-gray-800 border border-gray-700 rounded-lg p-3 text-white focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:outline-none transition-all font-medium text-sm placeholder-gray-600"
                            placeholder="Es. Guerriero, Elfo, Fabbro..."
                            required
                        />
                    </div>

                    {/* Tipo (Select Reale) */}
                    <div className="space-y-2">
                        <label className="flex items-center gap-2 text-xs font-bold text-indigo-400 uppercase tracking-wider">
                            <LayoutList size={14}/> Tipologia
                        </label>
                        <div className="relative">
                            <select 
                                value={formData.tipo}
                                onChange={e => setFormData({...formData, tipo: e.target.value})}
                                className="w-full appearance-none bg-gray-800 border border-gray-700 rounded-lg p-3 pr-10 text-white focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:outline-none transition-all font-medium text-sm cursor-pointer hover:bg-gray-750"
                            >
                                {TIER_TYPES.map(type => (
                                    <option key={type.value} value={type.value}>{type.label}</option>
                                ))}
                            </select>
                            <ChevronDown className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 pointer-events-none" size={18} />
                        </div>
                    </div>
                </div>

                {/* Descrizione */}
                <div className="space-y-2">
                    <label className="flex items-center gap-2 text-xs font-bold text-indigo-400 uppercase tracking-wider">
                        <AlignLeft size={14}/> Descrizione Formattata
                    </label>
                    <div className="bg-white rounded-lg border border-gray-700 overflow-hidden min-h-[150px] shadow-inner">
                        <RichTextEditor 
                            value={formData.descrizione} 
                            onChange={(val) => setFormData({...formData, descrizione: val})} 
                        />
                    </div>
                </div>

                <div className="border-t border-gray-800 my-2"></div>

                {/* SEZIONE 2: Gestione Abilità */}
                <div className="bg-gray-800/40 rounded-xl border border-gray-800 overflow-hidden">
                    <div className="p-4 bg-gray-800/60 border-b border-gray-800 flex flex-col md:flex-row md:items-center justify-between gap-4">
                        <h3 className="text-sm font-bold text-gray-200 flex items-center gap-2">
                            <span className="w-1.5 h-1.5 rounded-full bg-emerald-500"></span>
                            ABILITÀ NEL TIER
                            <span className="bg-gray-700 text-gray-300 text-[10px] px-2 py-0.5 rounded-full">{connectedSkills.length}</span>
                        </h3>
                        
                        {/* Area Aggiunta Rapida */}
                        <div className="flex gap-2 w-full md:w-auto">
                            <div className="relative flex-1 md:w-64 group">
                                <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500 group-focus-within:text-indigo-400 transition-colors"/>
                                <input 
                                    type="text"
                                    placeholder="Cerca abilità..."
                                    value={searchTerm}
                                    onChange={e => setSearchTerm(e.target.value)}
                                    className="w-full pl-9 pr-2 py-2 bg-gray-900 border border-gray-700 rounded-lg text-sm focus:border-indigo-500 focus:outline-none transition-colors"
                                />
                                {/* Dropdown Risultati */}
                                {searchTerm && filteredAbilities.length > 0 && (
                                    <div className="absolute top-full left-0 right-0 mt-1 bg-gray-800 border border-gray-700 rounded-lg shadow-xl max-h-48 overflow-y-auto z-50 divide-y divide-gray-700/50">
                                        {filteredAbilities.map(a => (
                                            <button 
                                                key={a.id}
                                                onClick={() => { setSelectedAbilityId(a.id); setSearchTerm(a.nome); }}
                                                className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-indigo-600 hover:text-white transition-colors"
                                            >
                                                {a.nome}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>
                            
                            <div className="flex items-center gap-2 bg-gray-900 rounded-lg border border-gray-700 p-1 px-2">
                                <span className="text-[10px] uppercase text-gray-500 font-bold">Ord.</span>
                                <input 
                                    type="number" 
                                    value={newOrder}
                                    onChange={e => setNewOrder(e.target.value)}
                                    className="w-10 bg-transparent text-center text-sm font-bold text-white focus:outline-none"
                                />
                            </div>

                            <button 
                                type="button"
                                onClick={handleAddSkill}
                                disabled={!selectedAbilityId && !searchTerm}
                                className="bg-emerald-600 hover:bg-emerald-500 disabled:bg-gray-700 disabled:text-gray-500 text-white p-2 rounded-lg shadow-lg transition-all active:scale-95"
                            >
                                <Plus size={20}/>
                            </button>
                        </div>
                    </div>

                    {/* Lista Card Abilità */}
                    <div className="p-2 space-y-2 max-h-[300px] overflow-y-auto custom-scrollbar bg-gray-900/20">
                        {connectedSkills.length === 0 && (
                            <div className="text-center py-8 border-2 border-dashed border-gray-800 rounded-lg m-2">
                                <Layers size={32} className="mx-auto text-gray-700 mb-2"/>
                                <p className="text-gray-500 text-sm">Nessuna abilità collegata.</p>
                            </div>
                        )}
                        
                        {connectedSkills.map((skill, idx) => (
                            <div key={skill.abilita_id} className="flex items-center gap-3 bg-gray-800 p-2 px-3 rounded-lg border border-gray-700/50 hover:border-gray-600 transition-all group animate-in slide-in-from-left-2 duration-300">
                                
                                {/* Badge Ordine */}
                                <div className="flex flex-col items-center justify-center bg-gray-900 w-10 h-10 rounded border border-gray-700 shrink-0">
                                    <span className="text-[9px] text-gray-500 uppercase leading-none">Ord</span>
                                    <input 
                                        type="number" 
                                        value={skill.ordine}
                                        onChange={(e) => handleSkillOrderEdit(idx, e.target.value)}
                                        className="w-full bg-transparent text-center font-bold text-indigo-400 focus:outline-none text-sm leading-none mt-0.5"
                                    />
                                </div>
                                
                                {/* Nome Skill */}
                                <div className="flex-1 min-w-0">
                                    <span className="block font-bold text-gray-200 truncate">{skill.nome}</span>
                                    <span className="text-[10px] text-gray-500 uppercase tracking-wider">ID: {skill.abilita_id}</span>
                                </div>

                                {/* Azioni */}
                                <button 
                                    onClick={() => handleRemoveSkill(skill.abilita_id)}
                                    className="text-gray-500 hover:text-red-500 hover:bg-red-500/10 p-2 rounded-lg transition-all opacity-100 md:opacity-0 md:group-hover:opacity-100"
                                    title="Rimuovi"
                                >
                                    <Trash2 size={18} />
                                </button>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {/* === FOOTER === */}
            <div className="p-4 border-t border-gray-800 bg-gray-900 flex justify-end gap-3 shrink-0 z-10">
                <button 
                    onClick={onCancel}
                    className="px-6 py-2.5 text-sm font-bold text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors"
                >
                    Annulla
                </button>
                <button 
                    onClick={handleSubmit}
                    className="px-6 py-2.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-bold rounded-lg shadow-lg shadow-indigo-900/30 flex items-center gap-2 transition-all hover:scale-[1.02]"
                >
                    <Save size={18} />
                    <span>{tier ? 'Salva Modifiche' : 'Crea Tabella'}</span>
                </button>
            </div>
        </div>
    );
};

export default TabellaEditor;

==================================================
FILE: src\components\editors\TabellaList.jsx
==================================================
import React from 'react';
import { Edit, Trash2, Layers, ListOrdered } from 'lucide-react';

const TabellaList = ({ tiers, onEdit, onDelete }) => {
    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 p-4">
            {tiers.map(tier => (
                <div key={tier.id} className="bg-gray-800 border border-gray-700 rounded-lg p-3 shadow-md hover:border-gray-500 transition-all flex flex-col group relative overflow-hidden h-24">
                    
                    {/* Header Row: Tipo, Nome e Azioni */}
                    <div className="flex justify-between items-start z-10">
                        <div className="flex-1 min-w-0 pr-2">
                            <div className="flex items-center gap-2 mb-0.5">
                                <span className="text-[9px] uppercase tracking-widest font-bold text-indigo-300 bg-indigo-900/40 px-1.5 py-px rounded border border-indigo-500/20 truncate">
                                    {tier.tipo || 'Generico'}
                                </span>
                            </div>
                            <h3 className="text-sm font-bold text-gray-100 leading-tight truncate" title={tier.nome}>
                                {tier.nome}
                            </h3>
                        </div>

                        {/* Actions (Icone compatte) */}
                        <div className="flex items-center gap-1 shrink-0 bg-gray-900/80 rounded-md p-0.5 border border-gray-700/50 backdrop-blur-sm">
                            <button 
                                onClick={() => onEdit(tier)}
                                className="p-1.5 text-gray-400 hover:text-white hover:bg-indigo-600 rounded transition-all"
                                title="Modifica"
                            >
                                <Edit size={14} />
                            </button>
                            <div className="w-px h-3 bg-gray-700"></div>
                            <button 
                                onClick={() => onDelete(tier.id)}
                                className="p-1.5 text-gray-400 hover:text-white hover:bg-red-600 rounded transition-all"
                                title="Elimina"
                            >
                                <Trash2 size={14} />
                            </button>
                        </div>
                    </div>

                    {/* Footer Row: Conteggio Abilità */}
                    <div className="mt-auto flex items-end justify-between z-10">
                        <div className="flex items-center gap-1.5 text-xs text-gray-500">
                            <ListOrdered size={14} className="text-emerald-500/80" />
                            <span className="font-mono font-bold text-gray-300">{tier.abilita_count || 0}</span>
                            <span className="text-[10px] uppercase">Abilità</span>
                        </div>
                    </div>

                    {/* Sfondo decorativo molto leggero e piccolo */}
                    <Layers className="absolute -bottom-3 -right-3 text-white/3 w-16 h-16 rotate-12 pointer-events-none group-hover:scale-110 group-hover:text-white/5 transition-all" />
                </div>
            ))}

            {/* Empty State compatto */}
            {tiers.length === 0 && (
                <div className="col-span-full flex flex-col items-center justify-center py-8 text-gray-500 border-2 border-dashed border-gray-700 rounded-lg bg-gray-800/30">
                    <Layers size={32} className="mb-2 opacity-50" />
                    <p className="text-sm font-medium">Nessuna tabella trovata</p>
                </div>
            )}
        </div>
    );
};

export default TabellaList;

==================================================
FILE: src\components\editors\TabellaManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { Plus, Loader2, RefreshCw } from 'lucide-react';
import TabellaList from './TabellaList';
import TabellaEditor from './TabellaEditor';
import { getTiers, createTier, updateTier, deleteTier, updateTierAbilita } from '../../api';

const TabellaManager = ({ onLogout }) => {
    const [tiers, setTiers] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [isEditing, setIsEditing] = useState(false);
    const [currentTier, setCurrentTier] = useState(null);
    
    // RIMOSSO: const token = localStorage.getItem('access_token'); 
    // fetchAuthenticated gestisce il token internamente ('kor35_token')

    const fetchTiers = async () => {
        setIsLoading(true);
        try {
            // CORRETTO: Passiamo onLogout, non il token
            const data = await getTiers(onLogout);
            setTiers(data);
        } catch (error) {
            console.error("Errore fetch tiers", error);
            // Se l'errore è gestito da fetchAuthenticated, onLogout potrebbe essere già stato chiamato
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        fetchTiers();
    }, []);

    const handleCreate = () => {
        setCurrentTier(null);
        setIsEditing(true);
    };

    const handleEdit = (tier) => {
        setCurrentTier(tier);
        setIsEditing(true);
    };

    const handleDelete = async (id) => {
        if (!window.confirm("Sei sicuro di voler eliminare questa tabella?")) return;
        try {
            await deleteTier(id, onLogout);
            setTiers(prev => prev.filter(t => t.id !== id));
        } catch (error) {
            alert("Errore durante l'eliminazione");
        }
    };

    const handleSave = async (formData, connectedSkills) => {
        try {
            let savedTier;
            if (currentTier) {
                // Update Base Info
                savedTier = await updateTier(currentTier.id, formData, onLogout);
                // Update Skills Relation
                await updateTierAbilita(currentTier.id, connectedSkills, onLogout);
            } else {
                // Create
                savedTier = await createTier(formData, onLogout);
                // Update Skills Relation (ora che abbiamo l'ID)
                await updateTierAbilita(savedTier.id, connectedSkills, onLogout);
            }
            
            setIsEditing(false);
            fetchTiers(); // Ricarica per avere i dati aggiornati
        } catch (error) {
            console.error("Errore salvataggio", error);
            alert("Errore durante il salvataggio: " + error.message);
        }
    };

    if (isEditing) {
        return (
            <div className="h-full p-4 animate-in fade-in slide-in-from-bottom-4">
                <TabellaEditor 
                    tier={currentTier} 
                    onSave={handleSave} 
                    onCancel={() => setIsEditing(false)} 
                    onLogout={onLogout} // Passiamo onLogout anche all'editor
                />
            </div>
        );
    }

    return (
        <div className="flex flex-col h-full bg-gray-900">
            {/* Toolbar */}
            <div className="p-4 border-b border-gray-800 flex justify-between items-center bg-gray-950 shadow-sm z-10">
                <div className="flex items-center gap-3">
                    <h2 className="text-xl font-black text-gray-100 uppercase tracking-wide">Gestione Tabelle (Tier)</h2>
                    <span className="bg-gray-800 text-gray-400 text-xs px-2 py-1 rounded-full font-mono">{tiers?.length || 0}</span>
                </div>
                <div className="flex gap-2">
                    <button 
                        onClick={fetchTiers} 
                        className="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors"
                        title="Aggiorna"
                    >
                        <RefreshCw size={20} className={isLoading ? "animate-spin" : ""} />
                    </button>
                    <button 
                        onClick={handleCreate} 
                        className="flex items-center gap-2 bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-lg font-bold shadow-lg shadow-indigo-900/30 transition-all hover:scale-105"
                    >
                        <Plus size={20} /> Nuova Tabella
                    </button>
                </div>
            </div>

            {/* Content */}
            <div className="flex-1 overflow-y-auto custom-scrollbar relative">
                {isLoading ? (
                    <div className="absolute inset-0 flex items-center justify-center">
                        <Loader2 size={40} className="text-indigo-500 animate-spin" />
                    </div>
                ) : (
                    <TabellaList 
                        tiers={tiers} 
                        onEdit={handleEdit} 
                        onDelete={handleDelete} 
                    />
                )}
            </div>
        </div>
    );
};

export default TabellaManager;

==================================================
FILE: src\components\editors\TessituraEditor.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { useCharacter } from '../CharacterContext';
import { getStatisticheList, staffUpdateTessitura, staffCreateTessitura } from '../../api';
import CharacteristicInline from './inlines/CharacteristicInline';
import StatBaseInline from './inlines/StatBaseInline';
import RichTextEditor from '../RichTextEditor';

const TessituraEditor = ({ onBack, onCancel, onSave, onLogout, initialData = null }) => {
  const { punteggiList } = useCharacter();
  const [statsOptions, setStatsOptions] = useState([]);
  
  // FIX: Default Data Merging
  const defaultData = {
    nome: '', testo: '', formula: '',
    aura_richiesta: null,
    elemento_principale: null,
    componenti: [],
    statistiche_base: []
  };

  const [formData, setFormData] = useState({ ...defaultData, ...initialData });

  // Alias per chiusura
  const handleClose = onCancel || onBack;

  useEffect(() => {
    getStatisticheList(onLogout).then(setStatsOptions);
  }, [onLogout]);

  // Calcolo livello property (numero componenti)
  const calculatedLevel = (formData.componenti || []).reduce((acc, curr) => acc + (parseInt(curr.valore) || 0), 0);

  const updateInline = (key, index, field, value) => {
    const newList = [...(formData[key] || [])];
    if (index === -1 && key === 'statistiche_base') {
      const exists = newList.find(it => (it.statistica?.id || it.statistica) === value.statId);
      if (!exists) newList.push({ statistica: value.statId, valore_base: value.value });
    } else {
      newList[index] = { ...newList[index], [field]: value };
    }
    setFormData({ ...formData, [key]: newList });
  };

  const handleSave = async () => {
    try {
      const dataToSend = { 
        ...formData,
        aura_richiesta: formData.aura_richiesta?.id || formData.aura_richiesta || null,
        elemento_principale: formData.elemento_principale?.id || formData.elemento_principale || null,
        statistiche_base: (formData.statistiche_base || []).map(sb => ({
          ...sb,
          statistica: sb.statistica?.id || sb.statistica
        }))
      };
      
      if (onSave) {
        // APPROVAL MODE
        await onSave(dataToSend);
      } else {
        // STANDARD MODE
        if (formData.id) await staffUpdateTessitura(formData.id, dataToSend, onLogout);
        else await staffCreateTessitura(dataToSend, onLogout);
        alert("Tessitura salvata!");
        if (handleClose) handleClose();
      }
    } catch (e) { 
        console.error(e);
        alert("Errore: " + (e.message || "Errore sconosciuto")); 
    }
  };

  return (
    <div className="bg-gray-800 p-6 rounded-xl space-y-6 max-w-7xl mx-auto overflow-y-auto max-h-[92vh] text-white border border-gray-700 shadow-2xl">
      <div className="flex justify-between items-center border-b border-gray-700 pb-4">
        <h2 className="text-xl font-bold text-cyan-400 uppercase tracking-tighter">
          {formData.id ? `Edit: ${formData.nome}` : 'Nuova Tessitura'}
        </h2>
        <div className="flex gap-3">
           <button onClick={handleSave} className="bg-emerald-600 hover:bg-emerald-500 px-8 py-2 rounded-lg font-black text-sm text-white">
             {onSave ? 'APPROVA & CREA' : 'SALVA'}
           </button>
           {handleClose && (
             <button onClick={handleClose} className="bg-gray-700 px-6 py-2 rounded-lg font-bold text-sm text-white">ANNULLA</button>
           )}
        </div>
      </div>

      <div className="bg-gray-900/40 p-5 rounded-xl border border-gray-700/50 space-y-5 shadow-inner">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <Select label="Aura Richiesta" value={formData.aura_richiesta?.id || formData.aura_richiesta} 
                  options={punteggiList.filter(p => p.tipo === 'AU')} 
                  onChange={v => setFormData({...formData, aura_richiesta: v ? parseInt(v, 10) : null})} />
          <Select label="Elemento Principale" value={formData.elemento_principale?.id || formData.elemento_principale} 
                  options={punteggiList.filter(p => p.tipo === 'EL')} 
                  onChange={v => setFormData({...formData, elemento_principale: v ? parseInt(v, 10) : null})} />
        </div>
        <Input label="Formula Tessitura (es. {caratt} + 1d10)" value={formData.formula} onChange={v => setFormData({...formData, formula: v})} />
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <div className="md:col-span-3">
            <Input label="Nome" value={formData.nome} onChange={v => setFormData({...formData, nome: v})} />
          </div>
          <div className="bg-black/20 p-2 rounded flex flex-col items-center justify-center">
             <span className="text-[9px] text-gray-500 uppercase font-black">Livello</span>
             <span className="text-xl font-bold text-cyan-400">{calculatedLevel}</span>
          </div>
        </div>
      </div>

      <RichTextEditor label="Descrizione Effetto" value={formData.testo} onChange={v => setFormData({...formData, testo: v})} />

      <CharacteristicInline 
        items={formData.componenti || []} 
        options={punteggiList.filter(p => p.tipo === 'CA')}
        onAdd={() => setFormData({...formData, componenti: [...(formData.componenti || []), {caratteristica:'', valore:1}]})}
        onChange={(i, f, v) => updateInline('componenti', i, f, v)}
        onRemove={(i) => setFormData({...formData, componenti: formData.componenti.filter((_, idx) => idx !== i)})}
      />

      <StatBaseInline 
        items={formData.statistiche_base || []} 
        options={statsOptions} 
        onChange={(i, f, v) => updateInline('statistiche_base', i, f, v)} 
      />
    </div>
  );
};

const Input = ({ label, value, onChange, type="text" }) => (
    <div className="w-full text-left">
      <label className="text-[10px] text-gray-500 uppercase font-black block mb-1 tracking-tighter">{label}</label>
      <input type={type} className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white focus:border-cyan-500 outline-none" value={value || ""} onChange={e => onChange(e.target.value)} />
    </div>
);

const Select = ({ label, value, options, onChange }) => (
    <div className="w-full text-left">
      <label className="text-[10px] text-gray-500 uppercase font-black block mb-1 tracking-tighter">{label}</label>
      <select className="w-full bg-gray-950 p-2 rounded border border-gray-700 text-sm text-white cursor-pointer focus:border-cyan-500 outline-none" value={value ? String(value) : ""} onChange={e => onChange(e.target.value)}>
        <option value="">- SELEZIONA -</option>
        {options.map(o => <option key={o.id} value={String(o.id)}>{o.nome}</option>)}
      </select>
    </div>
);

export default TessituraEditor;

==================================================
FILE: src\components\editors\TessituraList.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { staffGetTessiture, staffDeleteTessitura } from '../../api';
import MasterTechniqueList from './MasterTechniqueList';

const TessituraList = ({ onAdd, onEdit, onLogout }) => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);

  const loadData = () => {
    setLoading(true);
    staffGetTessiture(onLogout)
      .then(data => setItems(Array.isArray(data) ? data : []))
      .finally(() => setLoading(false));
  };

  useEffect(() => { loadData(); }, []);

  const handleDelete = async (id) => {
    if (window.confirm("Sei sicuro di voler eliminare questa Tessitura?")) {
      await staffDeleteTessitura(id, onLogout);
      loadData();
    }
  };

  return (
    <MasterTechniqueList 
      title="Gestione Tessiture"
      addLabel="Nuova Tessitura"
      items={items}
      loading={loading}
      onAdd={onAdd}
      onEdit={onEdit}
      onDelete={handleDelete}
    />
  );
};

export default TessituraList;

==================================================
FILE: src\components\editors\TessituraManager.jsx
==================================================
import React, { useState } from 'react';
import TessituraList from './TessituraList';
import TessituraEditor from './TessituraEditor';

const TessituraManager = ({ onBack, onLogout }) => {
  const [view, setView] = useState('list'); // 'list' o 'edit'
  const [editingItem, setEditingItem] = useState(null);

  const handleAdd = () => {
    setEditingItem(null);
    setView('edit');
  };

  const handleEdit = (item) => {
    setEditingItem(item);
    setView('edit');
  };

  const handleBackToList = () => {
    setEditingItem(null);
    setView('list');
  };

  if (view === 'edit') {
    return (
      <TessituraEditor 
        initialData={editingItem} 
        onBack={handleBackToList} 
        onLogout={onLogout} 
      />
    );
  }

  return (
    <div className="space-y-6">
      <button 
        onClick={onBack}
        className="text-gray-400 hover:text-white flex items-center gap-2 mb-4 transition-colors"
      >
        ← Torna agli Strumenti Master
      </button>
      
      <TessituraList 
        onAdd={handleAdd} 
        onEdit={handleEdit} 
        onLogout={onLogout} 
      />
    </div>
  );
};

export default TessituraManager;

==================================================
FILE: src\components\editors\inlines\CharacteristicInline.jsx
==================================================
import React from 'react';

const CharacteristicInline = ({ items, options, onChange, onAdd, onRemove }) => (
  <div className="bg-gray-900/50 p-4 rounded-lg border border-gray-700">
    <div className="flex justify-between items-center mb-4">
      <h3 className="text-sm font-bold text-gray-300 uppercase">Componenti (Caratteristiche)</h3>
      <button onClick={onAdd} className="text-xs bg-indigo-600 px-2 py-1 rounded">+ Aggiungi</button>
    </div>
    <div className="space-y-2">
      {items.map((item, i) => (
        <div key={i} className="flex gap-2">
          <select 
            className="flex-1 bg-gray-800 p-2 rounded text-sm border border-gray-700"
            value={item.caratteristica} 
            onChange={e => onChange(i, 'caratteristica', e.target.value)}
          >
            <option value="">Seleziona...</option>
            {options.map(o => <option key={o.id} value={o.id}>{o.nome}</option>)}
          </select>
          <input 
            type="number" className="w-20 bg-gray-800 p-2 rounded text-sm text-center border border-gray-700"
            value={item.valore} onChange={e => onChange(i, 'valore', e.target.value)} 
          />
          <button onClick={() => onRemove(i)} className="text-red-500 px-2">✕</button>
        </div>
      ))}
    </div>
  </div>
);

export default CharacteristicInline;

==================================================
FILE: src\components\editors\inlines\GenericRelationInline.jsx
==================================================
import React from 'react';
import { Trash2, Plus } from 'lucide-react';

const GenericRelationInline = ({ 
    title, 
    items, 
    options, 
    valueKey = 'valore', 
    targetKey, // Chiave dell'oggetto target (es. 'punteggio', 'requisito')
    onChange, 
    labelFinder = (opt) => opt.nome 
}) => {
    
    const handleAdd = () => {
        const newItem = { [targetKey]: null, [valueKey]: 1 };
        onChange([...items, newItem]);
    };

    const handleRemove = (index) => {
        const newItems = [...items];
        newItems.splice(index, 1);
        onChange(newItems);
    };

    const handleChange = (index, field, value) => {
        const newItems = [...items];
        newItems[index] = { ...newItems[index], [field]: value };
        onChange(newItems);
    };

    return (
        <div className="bg-gray-900/50 p-4 rounded-lg border border-gray-700">
            <div className="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                <h4 className="font-bold text-gray-300 uppercase text-xs">{title}</h4>
                <button onClick={handleAdd} className="text-emerald-500 hover:text-emerald-400">
                    <Plus size={16} />
                </button>
            </div>
            
            <div className="space-y-2">
                {items.map((item, idx) => (
                    <div key={idx} className="flex gap-2 items-center">
                        <select 
                            value={item[targetKey] || ""} 
                            onChange={(e) => handleChange(idx, targetKey, parseInt(e.target.value))}
                            className="flex-1 bg-gray-950 border border-gray-700 rounded px-2 py-1 text-sm text-white"
                        >
                            <option value="">- Seleziona -</option>
                            {options.map(opt => (
                                <option key={opt.id} value={opt.id}>{labelFinder(opt)}</option>
                            ))}
                        </select>
                        
                        {/* Se esiste la chiave valore, mostra l'input numerico */}
                        {valueKey && (
                            <input 
                                type="number" 
                                value={item[valueKey]} 
                                onChange={(e) => handleChange(idx, valueKey, parseInt(e.target.value))}
                                className="w-20 bg-gray-950 border border-gray-700 rounded px-2 py-1 text-sm text-white text-right"
                            />
                        )}

                        <button onClick={() => handleRemove(idx)} className="text-red-500 hover:text-red-400">
                            <Trash2 size={14} />
                        </button>
                    </div>
                ))}
                {items.length === 0 && <p className="text-gray-600 text-xs italic">Nessun elemento assegnato.</p>}
            </div>
        </div>
    );
};

export default GenericRelationInline;

==================================================
FILE: src\components\editors\inlines\StatBaseInline.jsx
==================================================
import React from 'react';

const StatBaseInline = ({ items, options, onChange }) => {
  return (
    <div className="bg-gray-900/50 p-4 rounded-lg border border-gray-700 w-full">
      <div className="mb-4 border-b border-gray-800 pb-2">
        <h3 className="text-sm font-bold uppercase tracking-widest text-indigo-400">Statistiche Base per l'abilità</h3>
        <p className="text-[9px] text-gray-500 italic uppercase font-medium">Parametri tecnici per la definizione dell'effetto</p>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-x-8 gap-y-2 max-h-[500px] overflow-y-auto pr-2 custom-scrollbar">
        {options.map((stat) => {
          const existingRecord = items.find(it => (it.statistica?.id || it.statistica) === stat.id);
          
          let displayValue = existingRecord?.valore_base;
          
          // ORA IL BACKEND INVIA SEMPRE 'valore_base_predefinito'
          if (displayValue === null || displayValue === undefined || displayValue === "") {
            displayValue = stat.valore_base_predefinito;
          }

          return (
            <div key={stat.id} className="flex items-center gap-3 bg-gray-800/20 p-2 rounded hover:bg-gray-800/50 transition-all border border-transparent hover:border-gray-700/50 group">
              <div className="flex-1 flex items-baseline gap-2 overflow-hidden">
                <span className="text-[11px] font-bold text-gray-300 truncate">{stat.nome}</span>
                <span className="text-[9px] text-gray-600 font-mono group-hover:text-indigo-400 transition-colors">({stat.parametro})</span>
              </div>
              
              <div className="w-20 shrink-0">
                <input 
                  type="number" 
                  step="any"
                  className="w-full bg-gray-950 p-1.5 rounded text-xs text-center border border-gray-800 text-amber-500 focus:border-indigo-500 outline-none font-bold"
                  value={displayValue ?? ""} 
                  onChange={e => {
                    const newVal = e.target.value;
                    const recordIndex = items.findIndex(it => (it.statistica?.id || it.statistica) === stat.id);
                    
                    if (recordIndex !== -1) {
                      onChange(recordIndex, 'valore_base', newVal);
                    } else {
                      onChange(-1, 'statistica', { statId: stat.id, value: newVal });
                    }
                  }} 
                />
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default StatBaseInline;

==================================================
FILE: src\components\editors\inlines\StatModInline.jsx
==================================================
import React from 'react';

const StatModInline = ({ items, options, auraOptions, elementOptions, onChange, onAdd, onRemove }) => {
  const toggleM2M = (index, field, id) => {
    const currentList = items[index][field] || [];
    const newList = currentList.includes(id)
      ? currentList.filter(item => item !== id)
      : [...currentList, id];
    onChange(index, field, newList);
  };

  return (
    <div className="bg-gray-900/50 p-4 rounded-lg border border-gray-700">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-sm font-bold text-emerald-400 uppercase tracking-widest">Modifica Generale alle statistiche</h3>
        <button onClick={onAdd} className="text-xs bg-emerald-600 hover:bg-emerald-500 px-3 py-1 rounded font-bold transition-all shadow-md">+ AGGIUNGI MODIFICATORE</button>
      </div>
      
      <div className="space-y-4">
        {items.map((item, i) => (
          <div key={i} className="bg-gray-800/80 p-4 rounded border border-gray-700 space-y-4 shadow-xl">
            <div className="flex flex-wrap gap-3">
              <div className="flex-1 min-w-[200px]">
                <label className="text-[9px] uppercase text-gray-500 font-black block mb-1">Statistica</label>
                <select 
                  className="w-full bg-gray-900 p-2 rounded text-sm border border-gray-600 text-white outline-none focus:border-emerald-500"
                  value={item.statistica?.id || item.statistica || ""} 
                  onChange={e => onChange(i, 'statistica', e.target.value ? parseInt(e.target.value, 10) : null)}
                >
                  <option value="">Seleziona...</option>
                  {options.map(o => {
                    const isUsed = items.some((it, idx) => idx !== i && (it.statistica?.id || it.statistica) === o.id);
                    return (
                      <option key={o.id} value={String(o.id)} disabled={isUsed}>
                        {o.nome} {isUsed ? "(GIA' IN USO)" : ""}
                      </option>
                    );
                  })}
                </select>
              </div>
              <div className="w-32">
                <label className="text-[9px] uppercase text-gray-500 font-black block mb-1">Tipo</label>
                <select className="w-full bg-gray-900 p-2 rounded text-sm border border-gray-600 text-white"
                  value={item.tipo_modificatore} onChange={e => onChange(i, 'tipo_modificatore', e.target.value)}>
                  <option value="ADD">Additivo (+)</option>
                  <option value="MOL">Moltiplicatore (x)</option>
                </select>
              </div>
              <div className="w-24">
                <label className="text-[9px] uppercase text-gray-500 font-black block mb-1">Valore</label>
                <input type="number" step="any" className="w-full bg-gray-900 p-2 rounded text-sm text-center border border-gray-600 text-white"
                  value={item.valore} onChange={e => onChange(i, 'valore', e.target.value)} />
              </div>
              <button onClick={() => onRemove(i)} className="self-end mb-1 text-red-500 hover:bg-red-500/10 p-2 rounded transition-colors text-xl">✕</button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 bg-black/30 p-3 rounded border border-gray-800">
              <div className="space-y-2">
                <ConditionToggle label="Usa Limite Aura" checked={item.usa_limitazione_aura} onChange={v => onChange(i, 'usa_limitazione_aura', v)} color="indigo" />
                {item.usa_limitazione_aura && <M2MSelector options={auraOptions} selected={item.limit_a_aure} onToggle={id => toggleM2M(i, 'limit_a_aure', id)} color="indigo" />}
              </div>
              <div className="space-y-2 border-x border-gray-800/50 px-4">
                <ConditionToggle label="Usa Limite Elemento" checked={item.usa_limitazione_elemento} onChange={v => onChange(i, 'usa_limitazione_elemento', v)} color="emerald" />
                {item.usa_limitazione_elemento && <M2MSelector options={elementOptions} selected={item.limit_a_elementi} onToggle={id => toggleM2M(i, 'limit_a_elementi', id)} color="emerald" />}
              </div>
              <div className="space-y-2">
                <ConditionToggle label="Usa Condizione Testo" checked={item.usa_condizione_text} onChange={v => onChange(i, 'usa_condizione_text', v)} color="amber" />
                {item.usa_condizione_text && (
                  <input placeholder="Formula o condizione..." className="w-full bg-gray-900 p-2 rounded text-[10px] border border-gray-700 text-amber-500 font-mono"
                    value={item.condizione_text || ''} onChange={e => onChange(i, 'condizione_text', e.target.value)} />
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

const ConditionToggle = ({ label, checked, onChange, color }) => (
    <label className="flex items-center gap-2 cursor-pointer group">
      <input type="checkbox" className={`accent-${color}-500`} checked={checked} onChange={e => onChange(e.target.checked)} />
      <span className="text-[10px] font-black text-gray-500 group-hover:text-gray-300 uppercase">{label}</span>
    </label>
);

const M2MSelector = ({ options, selected = [], onToggle, color }) => (
    <div className="flex flex-wrap gap-1 max-h-24 overflow-y-auto p-1">
      {options.map(o => (
        <button key={o.id} onClick={() => onToggle(o.id)}
          className={`text-[9px] px-2 py-0.5 rounded border transition-all ${selected.includes(o.id) ? `bg-${color}-600 border-${color}-400 text-white` : 'bg-gray-900 border-gray-700 text-gray-600'}`}>
          {o.nome}
        </button>
      ))}
    </div>
);

export default StatModInline;

==================================================
FILE: src\components\wg\WidgetAura.jsx
==================================================
import React, { useEffect, useState } from 'react';
import { getWikiAura } from '../../api';
import MattoneList from '../wiki/MattoneList';

export default function WidgetAura({ id }) {
  const [aura, setAura] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    getWikiAura(id)
       .then(data => setAura(data))
       .catch(err => {
         console.error(`Errore caricamento Aura #${id}`, err);
         setError(true);
       });
  }, [id]);

  if (error) return <div className="text-red-500 text-xs">[Aura #{id} non trovata]</div>;
  if (!aura) return <div className="text-xs text-gray-400 p-2">Caricamento dati aura...</div>;

  return (
    <div className="my-6 p-4 md:p-6 bg-blue-50 border border-blue-200 rounded-xl shadow-sm w-full max-w-full">
      {/* Header Flessibile: Colonna su mobile, Riga su desktop */}
      <div className="flex flex-col md:flex-row justify-between items-start border-b border-blue-200 pb-3 mb-3 gap-2">
          <div>
            <h2 className="text-xl md:text-2xl font-bold text-blue-900 leading-tight">{aura.nome}</h2>
            <div className="text-blue-700 text-xs md:text-sm mt-1 flex flex-wrap gap-3">
                <span className="bg-blue-100 px-2 py-0.5 rounded">⚡ Costo: <strong>{aura.costo_attivazione || '-'}</strong></span>
                <span className="bg-blue-100 px-2 py-0.5 rounded">🔄 Mant: <strong>{aura.mantenimento || '-'}</strong></span>
            </div>
          </div>
          <div className="bg-blue-600 text-white px-2 py-1 rounded text-[10px] md:text-xs uppercase font-bold tracking-wider self-start">
            Aura
          </div>
      </div>

      {aura.descrizione && (
        <div className="mb-4 prose prose-blue prose-sm max-w-none text-gray-700 break-words">
           <div dangerouslySetInnerHTML={{ __html: aura.descrizione }} />
        </div>
      )}

      {aura.mattoni && aura.mattoni.length > 0 && (
        <div className="mt-4">
            <h4 className="font-bold text-blue-900 mb-2 uppercase text-[10px] tracking-wider border-b border-blue-200 inline-block pb-1">
                Effetti e Mattoni
            </h4>
            <MattoneList mattoni={aura.mattoni} />
        </div>
      )}
    </div>
  );
}

==================================================
FILE: src\components\wg\WidgetTabellaAbilita.jsx
==================================================
import React, { useEffect, useState } from 'react';
import { getWikiTable } from '../../api'; 
import AbilitaTable from '../wiki/AbilitaTable'; 

export default function WidgetTabellaAbilita({ id }) {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    getWikiTable(id)
       .then(responseData => setData(responseData))
       .catch(err => {
         console.error(`Errore caricamento tabella Wiki #${id}:`, err);
         setError(true);
       });
  }, [id]);

  if (error) return (
    <div className="p-3 border-l-4 border-red-500 bg-red-50 text-red-700 text-sm my-4 rounded">
      <strong>Errore:</strong> Tabella #{id} non trovata.
    </div>
  );

  if (!data) return (
    <div className="animate-pulse flex space-x-4 my-4 p-4 border rounded">
       <div className="h-4 bg-gray-200 rounded w-3/4"></div>
    </div>
  );

  const listaAbilita = data.abilita_selezionate || data.abilita || [];

  return (
    <div className="my-6 w-full max-w-full bg-white rounded-lg shadow-sm border border-gray-200">
      <div className="p-3 md:p-4 border-b border-gray-100 bg-gray-50 rounded-t-lg">
          <h3 className="text-lg md:text-xl font-bold text-red-900 leading-tight">
            {data.titolo}
          </h3>
          {data.descrizione && (
            <div className="mt-2 text-xs md:text-sm text-gray-600 italic break-words" dangerouslySetInnerHTML={{__html: data.descrizione}} />
          )}
      </div>

      <div className="bg-white">
        <AbilitaTable list={listaAbilita} />
      </div>
    </div>
  );
}

==================================================
FILE: src\components\wg\WidgetTier.jsx
==================================================
import React, { useEffect, useState } from 'react';
import { getWikiTier } from '../../api';
import AbilitaTable from '../wiki/AbilitaTable'; 

export default function WidgetTier({ id }) {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    getWikiTier(id)
       .then(res => setData(res))
       .catch(err => {
         console.error(`Errore caricamento Tier #${id}:`, err);
         setError(true);
       });
  }, [id]);

  if (error) return <div className="text-red-500 text-xs border border-red-300 p-2 rounded bg-red-50">Tier #{id} non disponibile.</div>;
  if (!data) return <div className="animate-pulse h-20 bg-gray-200 rounded my-4"></div>;

  const sortedList = [...(data.abilita || [])].sort((a, b) => 
    (a.nome || '').localeCompare(b.nome || '')
  );

  return (
    <div className="my-6 w-full max-w-full border border-gray-300 rounded-lg bg-white shadow-sm break-inside-avoid">
        {/* HEADER DEL TIER */}
        <div className="bg-gray-800 text-white p-3 md:p-4 flex flex-row justify-between items-center gap-2 rounded-t-lg">
            <div className="flex flex-col">
                <h3 className="text-base md:text-xl font-bold uppercase tracking-wider leading-tight">{data.nome}</h3>
                {data.costo && (
                  <span className="text-[10px] md:text-xs text-gray-300 bg-gray-700 px-2 py-0.5 rounded mt-1 self-start">
                    Costo Base: {data.costo}
                  </span>
                )}
            </div>
            <div className="text-xl md:text-2xl opacity-20 select-none">📊</div>
        </div>

        {/* DESCRIZIONE TIER */}
        {data.descrizione && (
            <div 
              className="p-3 md:p-4 bg-gray-50 text-gray-700 text-xs md:text-sm border-b border-gray-200 italic prose prose-sm max-w-none wrap-break-words"
              dangerouslySetInnerHTML={{ __html: data.descrizione }}
            />
        )}

        {/* GRIGLIA ABILITÀ (Non serve più padding extra qui, ci pensa AbilitaTable) */}
        <div className="w-full bg-gray-50/30">
            <AbilitaTable list={sortedList} />
        </div>
    </div>
  );
}

==================================================
FILE: src\components\wiki\AbilitaTable.jsx
==================================================
import React from 'react';
import PunteggioDisplay from '../PunteggioDisplay';

export default function AbilitaTable({ list }) {
  if (!list || list.length === 0) return <p className="text-gray-500 italic text-sm p-2">Nessuna abilità elencata.</p>;

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-3 p-2">
      {list.map((item) => (
        <div key={item.id} className="bg-white border border-gray-200 rounded-lg shadow-sm flex flex-col overflow-hidden hover:shadow-md transition-shadow break-inside-avoid">
          
          {/* HEADER SCHEDA: Nome + Costo */}
          <div className="bg-gray-50 px-3 py-2 border-b border-gray-100 flex justify-between items-center gap-2">
            <span className="font-bold text-red-900 text-sm md:text-base leading-tight truncate">
              {item.nome}
            </span>
            
            <div className="flex items-center gap-2 shrink-0">
               {/* Costo */}
               {item.costo && (
                  <span className="text-xs font-mono bg-white border border-gray-200 px-1.5 py-0.5 rounded text-gray-600 whitespace-nowrap">
                    Costo: {item.costo}
                  </span>
                )}
            </div>
          </div>

          {/* CORPO SCHEDA */}
          <div className="p-3 text-xs md:text-sm text-gray-700 relative">
            
            {/* BADGE CARATTERISTICA (Flottante a destra) */}
            {/* Controllo se esiste e se è un oggetto valido con colore */}
            {item.caratteristica && typeof item.caratteristica === 'object' && (
                <div className="float-right ml-2 mb-1">
                    <PunteggioDisplay 
                        punteggio={item.caratteristica}
                        value={null} // Nessun valore numerico
                        size="badge" // Uso il nuovo preset compatto
                        readOnly={true} // Disabilita click e interazioni
                        iconType="inv_circle"
                    />
                </div>
            )}
            
            {/* Descrizione HTML */}
            <div 
              className="prose prose-sm max-w-none leading-snug"
              dangerouslySetInnerHTML={{ __html: item.descrizione }} 
            />
          </div>
        </div>
      ))}
    </div>
  );
}

==================================================
FILE: src\components\wiki\MattoneList.jsx
==================================================
import React from 'react';

export default function MattoneList({ mattoni }) {
  return (
    <ul className="space-y-2 mt-2">
      {mattoni.map(m => (
        <li key={m.id} className="bg-gray-100 p-2 rounded border-l-4 border-blue-500">
          <span className="font-bold block">{m.nome}</span>
          <span className="text-sm text-gray-600">{m.descrizione}</span>
        </li>
      ))}
    </ul>
  );
}

==================================================
FILE: src\components\wiki\WikiPageEditorModal.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { getWikiTierList, createWikiPage, updateWikiPage } from '../../api';
import RichTextEditor from '../RichTextEditor';

export default function WikiPageEditorModal({ onClose, onSuccess, initialData = null }) {
  const [formData, setFormData] = useState({
    titolo: '',
    slug: '',
    parent: '',
    contenuto: '',
    public: false,
    ...initialData
  });
  
  // Gestione file immagine
  const [imageFile, setImageFile] = useState(null);
  const [previewUrl, setPreviewUrl] = useState(initialData?.immagine || null);

  const isEditing = !!initialData?.id;
  const [loading, setLoading] = useState(false);

  // Widget Helper logic
  const [showWidgetHelper, setShowWidgetHelper] = useState(false);
  const [availableTiers, setAvailableTiers] = useState([]);

  useEffect(() => {
    if (showWidgetHelper) {
        getWikiTierList()
            .then(data => setAvailableTiers(data))
            .catch(err => console.error("Err loading tiers", err));
    }
  }, [showWidgetHelper]);

  const insertWidget = (code) => {
    const widgetHtml = `<p><strong>${code}</strong></p><p>&nbsp;</p>`;
    setFormData(prev => ({
        ...prev,
        contenuto: (prev.contenuto || '') + widgetHtml
    }));
    setShowWidgetHelper(false);
  };

  const handleImageChange = (e) => {
      const file = e.target.files[0];
      if (file) {
          setImageFile(file);
          setPreviewUrl(URL.createObjectURL(file));
      }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);

    try {
        const data = new FormData();
        data.append('titolo', formData.titolo);
        data.append('contenuto', formData.contenuto || ''); 
        data.append('public', formData.public);
        
        if (formData.slug) data.append('slug', formData.slug);
        if (formData.parent) data.append('parent', formData.parent);
        
        if (imageFile) {
            data.append('immagine', imageFile);
        }

        let response;
        if (isEditing) {
             response = await updateWikiPage(initialData.id, data);
        } else {
             response = await createWikiPage(data);
        }

        alert("Salvataggio completato!");
        
        // Se la risposta contiene i dati aggiornati (es. slug), li usiamo
        const newSlug = response.slug || formData.slug; 
        onSuccess(newSlug);

    } catch (error) {
        console.error("Errore salvataggio:", error);
        alert("Errore durante il salvataggio. Controlla la console.");
    } finally {
        setLoading(false);
    }
  };

  return (
    // CONTENITORE PRINCIPALE: Padding ridotto su mobile (p-0) per usare tutto lo schermo
    <div className="fixed inset-0 bg-black/80 z-[60] flex items-center justify-center p-0 md:p-4">
      <div className="bg-white md:rounded-lg shadow-xl w-full max-w-6xl h-full md:h-auto md:max-h-[95vh] flex flex-col">
        
        {/* HEADER */}
        <div className="p-3 md:p-4 border-b flex justify-between items-center bg-gray-100 md:rounded-t-lg shrink-0">
            <h2 className="font-bold text-lg md:text-xl text-gray-800 flex items-center gap-2 truncate">
                {isEditing ? '✏️ Modifica Pagina' : '📄 Nuova Pagina Wiki'}
            </h2>
            <button onClick={onClose} className="text-gray-500 hover:text-red-600 font-bold text-xl px-2">✕</button>
        </div>

        {/* BODY SCROLLABILE: Layout a colonna su mobile, riga su desktop */}
        <div className="p-4 overflow-y-auto flex-1 flex flex-col md:flex-row gap-6">
            
            {/* COLONNA SINISTRA: IMPOSTAZIONI */}
            <div className="w-full md:w-1/3 space-y-6">
                
                {/* 1. Titolo e Slug */}
                <div className="space-y-4">
                    <div>
                        <label className="block text-xs font-bold text-gray-700 mb-1">Titolo Pagina</label>
                        <input 
                            type="text" 
                            className="w-full border border-gray-300 p-2 rounded focus:ring-2 focus:ring-indigo-500 outline-none text-sm" 
                            value={formData.titolo}
                            onChange={e => setFormData({...formData, titolo: e.target.value})}
                            required 
                        />
                    </div>
                    <div>
                        <label className="block text-xs font-bold text-gray-700 mb-1">Slug URL <span className="font-normal text-gray-400 text-xs">(Opzionale)</span></label>
                        <input 
                            type="text" 
                            className="w-full border border-gray-300 p-2 rounded bg-gray-50 text-gray-600 text-sm" 
                            value={formData.slug}
                            onChange={e => setFormData({...formData, slug: e.target.value})}
                            placeholder="es: combattimento-avanzato"
                        />
                    </div>
                </div>

                {/* 2. Immagine */}
                <div className="border rounded-lg p-3 bg-gray-50">
                    <label className="block text-xs font-bold text-gray-700 mb-2">Immagine Copertina</label>
                    <div className="space-y-3">
                        <div className="w-full h-24 md:h-32 bg-gray-200 rounded overflow-hidden border border-gray-300 relative group">
                            {previewUrl ? (
                                <img src={previewUrl} alt="Anteprima" className="w-full h-full object-cover" />
                            ) : (
                                <div className="w-full h-full flex items-center justify-center text-gray-400 text-xs">Nessuna Immagine</div>
                            )}
                        </div>
                        <input 
                            type="file" 
                            accept="image/*"
                            onChange={handleImageChange}
                            className="block w-full text-xs text-gray-500 file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:bg-indigo-100 file:text-indigo-700"
                        />
                    </div>
                </div>

                {/* 3. Visibilità */}
                <div className="flex items-center gap-3 bg-yellow-50 p-3 rounded border border-yellow-200">
                    <input 
                        type="checkbox" 
                        id="is_public"
                        className="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500"
                        checked={formData.public} 
                        onChange={e => setFormData({...formData, public: e.target.checked})}
                    />
                    <label htmlFor="is_public" className="text-sm font-bold text-gray-800 cursor-pointer">
                        Pubblica Online
                    </label>
                </div>

                {/* 4. Widget Helper (Ripristinato testo e loader) */}
                <div className="bg-blue-50 p-3 rounded border border-blue-200">
                    <button 
                        type="button"
                        onClick={() => setShowWidgetHelper(!showWidgetHelper)}
                        className="w-full bg-blue-600 text-white px-3 py-2 rounded text-xs hover:bg-blue-700 transition flex justify-between items-center"
                    >
                        <span>🧩 Inserisci Widget</span>
                        <span>{showWidgetHelper ? '▲' : '▼'}</span>
                    </button>
                    
                    {showWidgetHelper && (
                        <div className="mt-2 max-h-40 md:max-h-60 overflow-y-auto bg-white rounded border border-gray-300 shadow-inner">
                            {/* RIPRISTINATO: Messaggio di caricamento */}
                            {availableTiers.length === 0 && <p className="p-2 text-xs text-gray-500">Caricamento...</p>}
                            
                            {availableTiers.map(tier => (
                                <button 
                                    key={tier.id}
                                    type="button"
                                    onClick={() => insertWidget(`{{WIDGET_TIER:${tier.id}}}`)}
                                    className="w-full text-left text-xs p-2 border-b hover:bg-blue-50 flex justify-between items-center group"
                                >
                                    <span className="font-bold text-gray-700 group-hover:text-blue-800 truncate pr-2">{tier.nome}</span>
                                    <span className="text-[10px] bg-gray-100 text-gray-500 px-1 rounded">ID:{tier.id}</span>
                                </button>
                            ))}
                        </div>
                    )}
                    {/* RIPRISTINATO: Testo esplicativo */}
                    <p className="text-[10px] text-gray-500 mt-2 leading-tight">
                        Cliccando su un widget, verrà aggiunto in fondo all'editor.
                    </p>
                </div>
            </div>

            {/* COLONNA DESTRA: EDITOR */}
            <div className="w-full md:w-2/3 flex flex-col min-h-[400px]">
                <label className="block text-xs font-bold text-gray-700 mb-2">Contenuto Pagina</label>
                
                <div className="flex-1 border border-gray-300 rounded-lg overflow-hidden bg-white">
                    <RichTextEditor 
                        value={formData.contenuto} 
                        onChange={(newContent) => setFormData({...formData, contenuto: newContent})}
                        placeholder="Scrivi qui il contenuto della pagina..."
                        className="h-full min-h-[300px]"
                    />
                </div>
            </div>

        </div>

        {/* FOOTER AZIONI */}
        <div className="p-3 md:p-4 border-t bg-gray-50 md:rounded-b-lg flex justify-end gap-3 shrink-0">
            <button 
                onClick={onClose} 
                disabled={loading}
                className="px-4 py-2 text-sm text-gray-600 hover:bg-gray-200 rounded font-medium disabled:opacity-50"
            >
                Annulla
            </button>
            <button 
                onClick={handleSubmit}
                disabled={loading}
                className="px-5 py-2 text-sm bg-red-700 text-white font-bold rounded hover:bg-red-800 shadow disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
            >
                {loading && <div className="animate-spin h-3 w-3 border-2 border-white border-t-transparent rounded-full"></div>}
                {isEditing ? 'Salva Modifiche' : 'Crea Pagina'}
            </button>
        </div>

      </div>
    </div>
  );
}

==================================================
FILE: src\hooks\useGameData.js
==================================================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { keepPreviousData } from '@tanstack/react-query'; 
import { 
  getPersonaggiList, 
  getPersonaggioDetail, 
  getAcquirableSkills, 
  getAcquirableInfusioni, 
  getAcquirableTessiture, 
  getPunteggiList,
  getPersonaggioLogs,       
  getPersonaggioTransazioni,
  getForgingQueue, 
  getShopItems,
  fetchAuthenticated,
  equipaggiaOggetto,
  assemblaOggetto,
  smontaOggetto,
  completeForging,
  getAcquirableCerimoniali,
} from '../api';

// --- HOOKS DI LETTURA (QUERY) ---

export const usePunteggi = (onLogout) => {
  return useQuery({
    queryKey: ['punteggi'],
    queryFn: () => getPunteggiList(onLogout),
    staleTime: Infinity, 
    refetchOnWindowFocus: false,
  });
};

export const usePersonaggiList = (onLogout, viewAll) => {
  return useQuery({
    queryKey: ['personaggi_list', viewAll],
    queryFn: () => getPersonaggiList(onLogout, viewAll),
  });
};

export const usePersonaggioDetail = (id, onLogout) => {
  return useQuery({
    queryKey: ['personaggio', String(id)], 
    queryFn: () => getPersonaggioDetail(id, onLogout),
    enabled: !!id, 
    staleTime: 1000 * 60 * 5, 
  });
};

export const useAcquirableSkills = (id, onLogout) => {
  return useQuery({
    queryKey: ['abilita_acquistabili', id],
    queryFn: () => getAcquirableSkills(onLogout, id),
    enabled: !!id,
    staleTime: 1000 * 60 * 5,
  });
};

export const useAcquirableInfusioni = (id) => {
  return useQuery({
    queryKey: ['infusioni_acquistabili', id],
    queryFn: () => getAcquirableInfusioni(id),
    enabled: !!id,
    staleTime: 1000 * 60 * 5,
  });
};

export const useAcquirableTessiture = (id) => {
  return useQuery({
    queryKey: ['tessiture_acquistabili', id],
    queryFn: () => getAcquirableTessiture(id),
    enabled: !!id,
    staleTime: 1000 * 60 * 5,
  });
};

export const useAcquirableCerimoniali = (id) => {
  return useQuery({
    queryKey: ['cerimoniali_acquistabili', id],
    queryFn: () => getAcquirableCerimoniali(id), // <--- Chiamata API
    enabled: !!id,
    staleTime: 1000 * 60 * 5,
  });
};

export const usePersonaggioLogs = (page = 1) => {
  return useQuery({
    queryKey: ['personaggio_logs', page],
    queryFn: () => getPersonaggioLogs(page),
    placeholderData: keepPreviousData, 
    staleTime: 1000 * 60, 
  });
};

export const useTransazioni = (page = 1, tipo = 'entrata', charId = null) => {
  return useQuery({
    queryKey: ['personaggio_transazioni', charId, tipo, page], 
    queryFn: () => getPersonaggioTransazioni(page, tipo, charId),
    placeholderData: keepPreviousData,
    staleTime: 1000 * 60,
    enabled: !!charId, 
  });
};

export const useForgingQueue = (charId) => {
  return useQuery({
    queryKey: ['forging_queue', charId],
    queryFn: () => getForgingQueue(charId),
    enabled: !!charId,
    refetchInterval: 5000, 
  });
};

export const useShopItems = () => {
  return useQuery({
    queryKey: ['shop_items'],
    queryFn: getShopItems,
    staleTime: 1000 * 60 * 5, 
  });
};

// --- HELPER OPTIMISTIC UI GENERALE ---
const useOptimisticAction = (queryKeyBase, mutationFn, updateFn) => {
    const queryClient = useQueryClient();
  
    return useMutation({
      mutationFn: mutationFn,
      onMutate: async (variables) => {
        const rawCharId = variables.charId || variables.personaggio_id; 
        const charId = String(rawCharId); 
        const queryKey = [...queryKeyBase, charId];
  
        await queryClient.cancelQueries({ queryKey });
        const previousData = queryClient.getQueryData(queryKey);
  
        if (previousData) {
            queryClient.setQueryData(queryKey, (old) => {
                if (!old) return old;
                try {
                    return updateFn(old, variables);
                } catch (e) {
                    console.error("Errore updateFn optimistic:", e);
                    return old;
                }
            });
        }
        return { previousData, queryKey };
      },
      onError: (err, newTodo, context) => {
        if (context?.previousData) {
          queryClient.setQueryData(context.queryKey, context.previousData);
        }
        console.error("Optimistic Update Failed:", err);
      },
      onSettled: (data, error, variables, context) => {
        if (context?.queryKey) {
          queryClient.invalidateQueries({ queryKey: context.queryKey });
        }
      },
    });
};

// --- HOOKS DI SCRITTURA (OPTIMISTIC MUTATIONS) ---

// A. CAMBIO STATISTICHE (Esteso per Zone Corpo)
export const useOptimisticStatChange = () => {
    return useOptimisticAction(
        ['personaggio'], 
        async ({ charId, stat_sigla, mode, max_override }) => {
            return fetchAuthenticated('/personaggi/api/game/modifica_stat_temp/', {
                method: 'POST',
                // Passiamo max_override se presente (per zone corpo)
                body: JSON.stringify({ char_id: charId, stat_sigla, mode, max_value: max_override })
            });
        },
        (oldData, { stat_sigla, mode, max_override }) => {
            // Aggiorniamo statistiche_temporanee (la fonte di verità per i dati dinamici)
            const tempStats = { ...oldData.statistiche_temporanee };
            
            // Trova il valore corrente
            let val = tempStats[stat_sigla];
            
            // Se non esiste nel temp, cerchiamo il default nei primari o usiamo il max_override passato
            if (val === undefined) {
                if (max_override !== undefined) val = max_override;
                else {
                    const primaryStat = oldData.statistiche_primarie?.find(s => s.sigla === stat_sigla);
                    val = primaryStat ? primaryStat.valore_max : 0;
                }
            }

            // Determina il massimale per il clamp
            let maxVal = max_override;
            if (maxVal === undefined) {
                 const primaryStat = oldData.statistiche_primarie?.find(s => s.sigla === stat_sigla);
                 maxVal = primaryStat ? primaryStat.valore_max : 999;
            }

            // Calcolo
            if (mode === 'consuma') val = Math.max(0, val - 1);
            else if (mode === 'reset') val = maxVal;
            else if (mode === 'add') val = Math.min(maxVal, val + 1);

            // Scrittura aggiornata
            tempStats[stat_sigla] = val;

            // Aggiorna anche l'array statistiche_primarie per coerenza visuale se la stat è lì
            const updatedPrimaries = oldData.statistiche_primarie?.map(stat => {
                if (stat.sigla === stat_sigla) {
                    return { ...stat, valore_corrente: val };
                }
                return stat;
            });

            return {
                ...oldData,
                statistiche_temporanee: tempStats,
                statistiche_primarie: updatedPrimaries
            };
        }
    );
};

// B. EQUIPAGGIA / DISEQUIPAGGIA
export const useOptimisticEquip = () => {
    return useOptimisticAction(
        ['personaggio'],
        ({ itemId, charId }) => equipaggiaOggetto(itemId, charId),
        (oldData, { itemId }) => {
            if (!oldData.oggetti) return oldData;
            return {
                ...oldData,
                oggetti: oldData.oggetti.map(obj => 
                    obj.id === itemId 
                    ? { ...obj, is_equipaggiato: !obj.is_equipaggiato } 
                    : obj
                )
            };
        }
    );
};

// C. USA OGGETTO
export const useOptimisticUseItem = () => {
    return useOptimisticAction(
        ['personaggio'],
        async ({ oggetto_id, charId }) => {
            return fetchAuthenticated('/personaggi/api/game/usa_oggetto/', {
                method: 'POST',
                body: JSON.stringify({ oggetto_id, char_id: charId })
            });
        },
        (oldData, { oggetto_id, durata_totale, is_aura_zero_off }) => {
            if (!oldData.oggetti) return oldData;
            return {
                ...oldData,
                oggetti: oldData.oggetti.map(obj => {
                    if (obj.id !== oggetto_id) return obj;
                    const attuali = obj.cariche_attuali || 0;
                    const nuoveCariche = Math.max(0, (obj.cariche_attuali || 0) - 1);
                    let updates = { cariche_attuali: nuoveCariche };
                    if (durata_totale > 0) {
                        if (attuali > 0) { // Puoi attivare solo se avevi cariche
                            const now = new Date();
                            // Imposta la fine nel futuro
                            const endDate = new Date(now.getTime() + durata_totale * 1000);
                            updates.data_fine_attivazione = endDate.toISOString();
                            updates.is_active = true; // Diventa attivo
                        }
                    }
                    if (is_aura_zero_off && nuoveCariche === 0) {
                        updates.is_active = false;
                        updates.data_fine_attivazione = null; // Reset timer se si spegne forzatamente
                    }
                    return { ...obj, ...updates };
                })
            };
        }
    );
};

// D. RICARICA OGGETTO
export const useOptimisticRecharge = () => {
    return useOptimisticAction(
        ['personaggio'],
        async ({ oggetto_id, charId }) => {
             return fetchAuthenticated('/personaggi/api/game/ricarica_oggetto/', {
                method: 'POST',
                body: JSON.stringify({ oggetto_id, char_id: charId })
            });
        },
        (oldData, { oggetto_id }) => {
            if (!oldData.oggetti) return oldData;
            return {
                ...oldData,
                oggetti: oldData.oggetti.map(obj => 
                    obj.id === oggetto_id 
                    ? { ...obj, cariche_attuali: obj.cariche_massime } 
                    : obj
                )
            };
        }
    );
};

// E. ASSEMBLAGGIO
export const useOptimisticAssembly = (action) => {
    return useOptimisticAction(
        ['personaggio'],
        async ({ host_id, mod_id, charId, useAcademy }) => {
             const apiFn = action === 'monta' ? assemblaOggetto : smontaOggetto;
             return apiFn(host_id, mod_id, charId, useAcademy);
        },
        (oldData, { host_id, mod_id }) => {
            if (!oldData.oggetti) return oldData;
            const hostIndex = oldData.oggetti.findIndex(o => o.id === host_id);
            if (hostIndex === -1) return oldData;
            const host = { ...oldData.oggetti[hostIndex] };
            let listaOggetti = [...oldData.oggetti];
            if (action === 'monta') {
                const mod = listaOggetti.find(o => o.id === mod_id);
                if (mod) {
                    listaOggetti = listaOggetti.filter(o => o.id !== mod_id);
                    host.potenziamenti_installati = [...(host.potenziamenti_installati || []), mod];
                }
            } else { 
                const mod = host.potenziamenti_installati?.find(o => o.id === mod_id);
                if (mod) {
                    host.potenziamenti_installati = host.potenziamenti_installati.filter(o => o.id !== mod_id);
                    listaOggetti.push({ ...mod, is_equipaggiato: false }); 
                }
            }
            listaOggetti[hostIndex] = host;
            return { ...oldData, oggetti: listaOggetti };
        }
    );
};

// F. RITIRO FORGIATURA
export const useOptimisticForgingCollect = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: ({ forgiaturaId, charId }) => completeForging(forgiaturaId, charId),
        onMutate: async ({ forgiaturaId, charId }) => {
             const cId = String(charId);
             const queueKey = ['forging_queue', cId];
             const charKey = ['personaggio', cId];
             await queryClient.cancelQueries({ queryKey: queueKey });
             const prevQueue = queryClient.getQueryData(queueKey);
             if (prevQueue) {
                queryClient.setQueryData(queueKey, (old) => {
                    if (!old) return [];
                    return old.filter(item => item.id !== forgiaturaId);
                });
             }
             return { prevQueue, queueKey, charKey };
        },
        onError: (err, vars, ctx) => {
             if(ctx?.prevQueue) queryClient.setQueryData(ctx.queueKey, ctx.prevQueue);
             alert("Errore ritiro oggetto: " + err.message);
        },
        onSettled: (data, err, vars, ctx) => {
             if(ctx) {
                 queryClient.invalidateQueries({ queryKey: ctx.queueKey });
                 queryClient.invalidateQueries({ queryKey: ctx.charKey });
             }
        }
    });
};

==================================================
FILE: src\hooks\useTimers.js
==================================================
import { useCallback } from 'react';
import { useCharacter } from '../components/CharacterContext';

export const useTimers = () => {
    const { activeTimers, setActiveTimers } = useCharacter();

    const addTimer = useCallback((config) => {
        // Estraiamo i dati. Supportiamo sia 'label' che 'nome' per flessibilità
        const { 
            nome,
            label, 
            duration, 
            endsAt, 
            alert_suono, 
            notifica_push, 
            messaggio_in_app 
        } = config;

        const timerNome = nome || label || "Operazione";

        // Calcoliamo endTime (millisecondi) come richiesto dal tuo SingleTimer
        const finalExpiration = endsAt 
            ? new Date(endsAt).getTime() 
            : Date.now() + (parseInt(duration || 0) * 1000);

        // Aggiorniamo l'OGGETTO (non l'array) per coerenza con TimerOverlay
        setActiveTimers(prev => ({
            ...prev,
            [timerNome]: {
                nome: timerNome,
                endTime: finalExpiration, // Il tuo SingleTimer usa .endTime
                alert_suono,
                notifica_push,
                messaggio_in_app,
                notified: false
            }
        }));

        console.log(`⏱️ Hook: Timer "${timerNome}" impostato a ${new Date(finalExpiration).toLocaleTimeString()}`);
    }, [setActiveTimers]); // Corretta la dipendenza

    const removeTimer = useCallback((nome) => {
        setActiveTimers(prev => {
            const newTimers = { ...prev };
            delete newTimers[nome];
            return newTimers;
        });
    }, [setActiveTimers]);

    return {
        activeTimers,
        addTimer,
        removeTimer
    };
};

==================================================
FILE: src\layouts\AppLayout.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { useCharacter } from '../components/CharacterContext';
import StaffDashboard from '../components/StaffDashboard';
import MainPage from '../components/MainPage';

const AppLayout = ({ token, onLogout }) => {
  const { isStaff } = useCharacter();
  
  // Stato per gestire quale interfaccia mostrare (solo per lo staff)
  // 'staff' = Dashboard Master | 'player' = Interfaccia Giocatore
  const [viewMode, setViewMode] = useState('staff'); 

  // Memorizza quale tool aprire nella dashboard (default 'home')
  const [dashboardInitialTool, setDashboardInitialTool] = useState('home');

  // Effetto: Se l'utente non è staff, forziamo sempre la vista player
  useEffect(() => {
    if (!isStaff) {
      setViewMode('player');
    }
  }, [isStaff]);

  // Render: Vista Master (Solo se è staff E siamo in modalità staff)
  if (isStaff && viewMode === 'staff') {
    return (
      <StaffDashboard 
        token={token}
        onLogout={onLogout} 
        onSwitchToPlayer={() => {
            setViewMode('player');
            setDashboardInitialTool('home'); 
        }}
        initialTool={dashboardInitialTool}
      />
    );
  }

  // Render: Vista Giocatore (Default per tutti)
  return (
    <MainPage 
      token={token}
      onLogout={onLogout}
      isStaff={isStaff} 
      onSwitchToMaster={(tool = 'home') => {
          setDashboardInitialTool(tool);
          setViewMode('staff');
      }}
    />
  );
};

export default AppLayout;

==================================================
FILE: src\layouts\PublicLayout.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { Outlet, Link, useLocation } from 'react-router-dom';
import { useCharacter } from '../components/CharacterContext';
import { getWikiMenu } from '../api';
import WikiPageEditorModal from '../components/wiki/WikiPageEditorModal';

export default function PublicLayout({ token }) {
  const [isSidebarOpen, setSidebarOpen] = useState(false);
  
  // Gestione stato del Modale Editor
  const [isEditorOpen, setEditorOpen] = useState(false);
  const [newParentId, setNewParentId] = useState(null); // Per memorizzare il parent scelto

  const { character, isStaff, isMaster } = useCharacter();
  const canEdit = isStaff || isMaster;

  const location = useLocation();
  
  // Stato per il menu (Albero e Lista Piatta)
  const [menuTree, setMenuTree] = useState([]);
  const [flatMenu, setFlatMenu] = useState([]); // Memorizziamo anche la lista piatta per ricerche
  const [loadingMenu, setLoadingMenu] = useState(true);

  // Caricamento Menu
  useEffect(() => {
    const fetchMenu = async () => {
      try {
        const flatList = await getWikiMenu();
        setFlatMenu(flatList); // Salviamo la lista grezza
        const tree = buildTree(flatList);
        setMenuTree(tree);
      } catch (error) {
        console.error("Errore caricamento menu:", error);
      } finally {
        setLoadingMenu(false);
      }
    };
    fetchMenu();
  }, []);

  const buildTree = (items) => {
    if (!Array.isArray(items)) return [];
    // Clona gli oggetti per evitare mutazioni sulla flatList originale
    const map = {};
    const roots = [];
    
    // Inizializza mappa
    items.forEach((item) => {
      map[item.id] = { ...item, children: [] };
    });

    // Collega i nodi
    items.forEach((item) => {
      if (item.parent) {
        if (map[item.parent]) {
          map[item.parent].children.push(map[item.id]);
        }
      } else {
        roots.push(map[item.id]);
      }
    });
    return roots;
  };

  // Funzione per trovare l'ID della pagina corrente basandosi sull'URL
  const getCurrentPageId = () => {
      const path = location.pathname;
      let currentSlug = '';
      
      if (path === '/') {
          currentSlug = 'home';
      } else if (path.startsWith('/regolamento/')) {
          // Estrae lo slug dall'URL: /regolamento/pippo -> pippo
          currentSlug = path.split('/')[2];
      }

      // Cerca nella lista piatta
      const page = flatMenu.find(p => p.slug === currentSlug);
      return page ? page.id : null;
  };

  // Apre modale per NUOVA PAGINA ROOT (dal menu laterale)
  const handleCreateRoot = () => {
      setNewParentId(null); // Nessun genitore
      setEditorOpen(true);
  };

  // Apre modale per SOTTO-PAGINA (dal bottone +)
  const handleCreateNested = () => {
      const parentId = getCurrentPageId();
      setNewParentId(parentId); // Imposta il genitore corrente
      setEditorOpen(true);
  };

  const MenuItem = ({ item }) => (
    <li>
      <Link 
        to={item.slug === 'home' ? '/' : `/regolamento/${item.slug}`}
        className={`block px-4 py-2 hover:bg-gray-700 border-b border-gray-700 transition-colors text-sm ${
           location.pathname.includes(item.slug) ? 'bg-gray-700 text-white font-bold' : 'text-gray-300'
        }`}
        onClick={() => setSidebarOpen(false)}
      >
        {item.titolo}
      </Link>
      {item.children && item.children.length > 0 && (
        <ul className="pl-4 bg-gray-900 bg-opacity-30 border-l border-gray-600">
          {item.children.map(child => <MenuItem key={child.id} item={child} />)}
        </ul>
      )}
    </li>
  );

  return (
    <div className="flex flex-col h-screen bg-gray-100 text-gray-900 font-sans">
      
      {/* HEADER */}
      <header className="bg-red-900 text-white shadow-md flex items-center justify-between px-4 py-3 z-20 relative">
        <div className="flex items-center gap-3">
          <button 
            onClick={() => setSidebarOpen(!isSidebarOpen)}
            className="md:hidden text-2xl focus:outline-none"
          >
            ☰
          </button>
          <Link to="/" className="text-xl font-bold tracking-wider flex items-center gap-2">
            <img src="/Logo Kor-AD_Trasp.png" alt="Logo" className="h-8" />
            <span className="hidden xs:inline">KOR35 WIKI</span>
          </Link>
        </div>

        <div className="flex items-center gap-3">
          {token ? (
            <div className="flex items-center gap-3">
                <div className="text-right hidden sm:block leading-tight">
                    <div className="font-bold text-sm">{character?.nome}</div>
                    <div className="text-xs text-red-200">{isStaff ? 'Staff' : 'Giocatore'}</div>
                </div>
                <Link 
                  to="/app" 
                  className="bg-white text-red-900 px-3 py-1 rounded font-bold hover:bg-gray-200 transition text-sm flex items-center gap-1"
                >
                  <span>🎮</span> <span className="hidden sm:inline">Entra nel Gioco</span>
                </Link>
            </div>
          ) : (
             !location.pathname.includes('login') && 
             <Link to="/login" className="bg-red-700 hover:bg-red-600 px-4 py-2 rounded text-white transition text-sm">
                Login
             </Link>
          )}
        </div>
      </header>

      <div className="flex flex-1 overflow-hidden relative">
        
        {/* SIDEBAR (Menu Regolamento) */}
        <aside 
          className={`
            absolute inset-y-0 left-0 w-72 bg-gray-800 text-gray-200 transform transition-transform duration-300 z-30 shadow-xl flex flex-col
            md:relative md:translate-x-0
            ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}
          `}
        >
          <div className="p-4 font-bold text-gray-400 uppercase text-xs tracking-widest border-b border-gray-700 flex justify-between items-center bg-gray-900">
            <span>Indice</span>
            <button onClick={() => setSidebarOpen(false)} className="md:hidden text-lg">✕</button>
          </div>

          {/* BOTTONE CREA ROOT (Solo Staff) */}
          {canEdit && (
             <div className="p-2 border-b border-gray-700 bg-gray-800">
                <button 
                    onClick={handleCreateRoot}
                    className="w-full bg-gray-700 hover:bg-gray-600 text-white text-xs py-2 px-3 rounded flex items-center justify-center gap-2 transition"
                >
                    <span>📄</span> Nuova Pagina Principale
                </button>
             </div>
          )}
          
          <nav className="overflow-y-auto flex-1 pb-20 scrollbar-thin scrollbar-thumb-gray-600">
            {loadingMenu ? (
               <div className="p-4 text-gray-400 text-sm animate-pulse">Caricamento indice...</div>
            ) : (
               <ul>
                 {menuTree.map(node => <MenuItem key={node.id} item={node} />)}
               </ul>
            )}
          </nav>
        </aside>

        {/* CONTENUTO PRINCIPALE */}
        <main className="flex-1 overflow-y-auto p-4 md:p-8 bg-gray-50 md:m-0 scroll-smooth relative">
          <Outlet />
          
          {/* --- BOTTONE GALLEGGIANTE 'AGGIUNGI SOTTO-PAGINA' (Solo Staff) --- */}
          {canEdit && (
            <button 
                onClick={handleCreateNested}
                className="fixed bottom-8 right-8 bg-red-700 hover:bg-red-800 text-white w-14 h-14 rounded-full shadow-2xl z-50 flex items-center justify-center text-3xl transition transform hover:scale-110"
                title="Crea Sotto-Pagina qui"
            >
                <span className="relative top-0.5">+</span>
            </button>
          )}
        </main>

        {/* Overlay Mobile */}
        {isSidebarOpen && (
          <div 
            className="fixed inset-0 bg-black opacity-50 z-20 md:hidden"
            onClick={() => setSidebarOpen(false)}
          ></div>
        )}

      </div>

      {/* --- MODALE EDITOR --- */}
      {isEditorOpen && (
        <WikiPageEditorModal 
            // Passiamo il parent ID calcolato (null per Root, ID per Nested)
            initialData={{ parent: newParentId }} 
            onClose={() => setEditorOpen(false)} 
            onSuccess={(newSlug) => {
                setEditorOpen(false);
                // Ricarichiamo la pagina per aggiornare menu e contenuto
                window.location.href = newSlug ? `/regolamento/${newSlug}` : '/';
            }}
        />
      )}

    </div>
  );
}

==================================================
FILE: src\pages\WikiPage.jsx
==================================================
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import WikiRenderer from '../components/WikiRenderer';
import WikiPageEditorModal from '../components/wiki/WikiPageEditorModal'; // Importiamo il modale
import { getWikiPage } from '../api';
import { useCharacter } from '../components/CharacterContext'; // Per i permessi

export default function WikiPage({ slug: propSlug }) {
  const { slug } = useParams();
  const navigate = useNavigate();
  const currentSlug = propSlug || slug || 'home'; 
  
  // Recuperiamo i permessi
  // Nota: controlliamo isStaff all'interno del token/context
  const { isStaff, isMaster } = useCharacter(); 
  const canEdit = isStaff || isMaster; // Definisci chi può editare

  const [pageData, setPageData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Stato per il modale di modifica
  const [isEditorOpen, setEditorOpen] = useState(false);

  // Funzione di caricamento (estratta per poter ricaricare dopo l'edit)
  const fetchPage = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await getWikiPage(currentSlug);
      setPageData(data);
    } catch (err) {
      console.error("Errore fetch pagina:", err);
      setError("Pagina non trovata.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchPage();
  }, [currentSlug]);

  const handleEditSuccess = (newSlug) => {
      setEditorOpen(false);
      // Se lo slug è cambiato, navighiamo alla nuova URL
      if (newSlug && newSlug !== currentSlug) {
          navigate(`/regolamento/${newSlug}`);
      } else {
          // Altrimenti ricarichiamo i dati della pagina corrente
          fetchPage();
      }
  };

  if (loading) return <div className="p-10 text-center text-gray-500 animate-pulse">Caricamento contenuto...</div>;

  if (error || !pageData) {
    return (
        <div className="max-w-4xl mx-auto mt-10 p-6 bg-white rounded shadow text-center">
            <h2 className="text-2xl font-bold text-gray-700 mb-2">404 - Pagina non trovata</h2>
            <p className="text-gray-500 mb-4">{error}</p>
            {/* Se siamo staff, offriamo di creare la pagina qui */}
            {canEdit && (
                <button 
                    onClick={() => setEditorOpen(true)}
                    className="bg-red-700 text-white px-4 py-2 rounded hover:bg-red-800"
                >
                    Crea pagina "{currentSlug}"
                </button>
            )}
            
            {/* Modale Creazione su 404 */}
            {isEditorOpen && (
                <WikiPageEditorModal 
                    initialData={{ title: currentSlug, slug: currentSlug }}
                    onClose={() => setEditorOpen(false)}
                    onSuccess={handleEditSuccess}
                />
            )}
        </div>
    );
  }

  return (
    <div className="max-w-5xl mx-auto bg-white min-h-screen shadow-sm md:rounded-lg overflow-hidden relative group">
        
        {/* PULSANTE MODIFICA (Visibile solo a Staff/Master) */}
        {canEdit && (
            <div className="absolute top-4 right-4 z-10 opacity-30 group-hover:opacity-100 transition-opacity">
                <button 
                    onClick={() => setEditorOpen(true)}
                    className="flex items-center gap-2 bg-indigo-600 text-white px-4 py-2 rounded shadow hover:bg-indigo-700 font-bold text-sm"
                >
                    ✏️ Modifica Pagina
                </button>
            </div>
        )}

        {/* Immagine Copertina */}
        {pageData.immagine && (
            <div className="w-full h-48 md:h-64 overflow-hidden relative">
                <img src={pageData.immagine} alt={pageData.titolo} className="w-full h-full object-cover"/>
                <div className="absolute inset-0 bg-linear-to-t from-black/60 to-transparent"></div>
                <h1 className="absolute bottom-4 left-4 text-3xl md:text-5xl font-bold text-white drop-shadow-lg">{pageData.titolo}</h1>
            </div>
        )}

        <div className="p-6 md:p-10">
            {/* Titolo se non c'è immagine */}
            {!pageData.immagine && (
                <h1 className="text-3xl md:text-4xl font-bold mb-8 text-red-900 border-b pb-4 flex justify-between items-center">
                    {pageData.titolo}
                </h1>
            )}
            
            {/* Contenuto */}
            <WikiRenderer content={pageData.contenuto} />
        </div>

        {/* MODALE EDITOR */}
        {isEditorOpen && (
            <WikiPageEditorModal 
                initialData={pageData} // Passiamo i dati attuali per popolare il form
                onClose={() => setEditorOpen(false)}
                onSuccess={handleEditSuccess}
            />
        )}
    </div>
  );
}

==================================================
FILE: src\utils\htmlSanitizer.js
==================================================
export const sanitizeHtml = (htmlContent) => {
    if (!htmlContent) return "";

    // 1. FASE PRELIMINARE (Stringa): 
    // Sostituisce TUTTI i &nbsp; (e il carattere unicode corrispondente) con uno spazio normale.
    // Questo è il passaggio chiave per far funzionare il "word-wrap".
    let cleanString = htmlContent
        .replace(/&nbsp;/g, ' ')   // Sostituisce l'entità HTML
        .replace(/\u00a0/g, ' ');  // Sostituisce il carattere Unicode invisibile

    try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(cleanString, 'text/html');
        
        // 2. PULIZIA ELEMENTI
        const allElements = doc.body.querySelectorAll('*');
        allElements.forEach(el => {
            // Rimuove stili inline (es. width fisse, white-space: nowrap copiati da Word)
            el.removeAttribute('style');
            
            // Rimuove classi (spesso portano dietro colori o font strani)
            el.removeAttribute('class'); 
            
            // Opzionale: Rimuove attributi width/height da tabelle o div che rompono il layout
            el.removeAttribute('width');
            el.removeAttribute('height');
        });

        // 3. RIMOZIONE PARAGRAFI VUOTI ECCESSIVI
        // Elimina i <p> che contengono solo spazi o <br> inutili
        const paragraphs = doc.body.querySelectorAll('p');
        paragraphs.forEach(p => {
            const text = p.textContent.trim();
            const hasMedia = p.querySelector('img, iframe, video');
            
            // Se non c'è testo, non ci sono media, ed è vuoto o ha solo un <br>
            if (!text && !hasMedia) {
                if (p.innerHTML.trim() === '' || p.innerHTML === '<br>') {
                    p.remove();
                }
            }
        });

        return doc.body.innerHTML;
    } catch (e) {
        console.error("Errore sanitizzazione HTML:", e);
        // Se fallisce il parsing, restituisci almeno la stringa con gli spazi sostituiti
        return cleanString; 
    }
};
